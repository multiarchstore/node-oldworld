diff --git a/deps/simdutf/simdutf.cpp b/deps/simdutf/simdutf.cpp
index eb3e4598..4924210e 100644
--- a/deps/simdutf/simdutf.cpp
+++ b/deps/simdutf/simdutf.cpp
@@ -1,7 +1,9 @@
-/* auto-generated on 2024-12-10 14:54:53 -0500. Do not edit! */
+/* auto-generated on 2025-03-04 12:05:54 -0500. Do not edit! */
 /* begin file src/simdutf.cpp */
 #include "simdutf.h"
-// We include base64_tables once.
+
+#if SIMDUTF_FEATURE_BASE64
+  // We include base64_tables once.
 /* begin file src/tables/base64_tables.h */
 #ifndef SIMDUTF_BASE64_TABLES_H
 #define SIMDUTF_BASE64_TABLES_H
@@ -692,11872 +694,112 @@ static_assert(to_base64_url_value[uint8_t('_')] == 63,
 
 #endif // SIMDUTF_BASE64_TABLES_H
 /* end file src/tables/base64_tables.h */
-/* begin file src/implementation.cpp */
-#include <initializer_list>
-#include <climits>
-#include <type_traits>
-
-// Useful for debugging purposes
-namespace simdutf {
-namespace {
-
-template <typename T> std::string toBinaryString(T b) {
-  std::string binary = "";
-  T mask = T(1) << (sizeof(T) * CHAR_BIT - 1);
-  while (mask > 0) {
-    binary += ((b & mask) == 0) ? '0' : '1';
-    mask >>= 1;
-  }
-  return binary;
-}
-} // namespace
-} // namespace simdutf
-
-// Implementations
-// The best choice should always come first!
-/* begin file src/simdutf/arm64.h */
-#ifndef SIMDUTF_ARM64_H
-#define SIMDUTF_ARM64_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "arm64.h must be included before fallback.h"
-#endif
+#endif // SIMDUTF_FEATURE_BASE64
 
+/* begin file src/encoding_types.cpp */
 
-#ifndef SIMDUTF_IMPLEMENTATION_ARM64
-  #define SIMDUTF_IMPLEMENTATION_ARM64 (SIMDUTF_IS_ARM64)
-#endif
-#if SIMDUTF_IMPLEMENTATION_ARM64 && SIMDUTF_IS_ARM64
-  #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 1
+namespace simdutf {
+bool match_system(endianness e) {
+#if SIMDUTF_IS_BIG_ENDIAN
+  return e == endianness::BIG;
 #else
-  #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 0
+  return e == endianness::LITTLE;
 #endif
-
-
-#if SIMDUTF_IMPLEMENTATION_ARM64
-
-namespace simdutf {
-/**
- * Implementation for NEON (ARMv8).
- */
-namespace arm64 {} // namespace arm64
-} // namespace simdutf
-
-/* begin file src/simdutf/arm64/implementation.h */
-#ifndef SIMDUTF_ARM64_IMPLEMENTATION_H
-#define SIMDUTF_ARM64_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace arm64 {
-
-namespace {
-using namespace simdutf;
 }
 
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("arm64", "ARM NEON",
-                                internal::instruction_set::NEON) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-
-} // namespace arm64
-} // namespace simdutf
-
-#endif // SIMDUTF_ARM64_IMPLEMENTATION_H
-/* end file src/simdutf/arm64/implementation.h */
-
-/* begin file src/simdutf/arm64/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "arm64"
-// #define SIMDUTF_IMPLEMENTATION arm64
-/* end file src/simdutf/arm64/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/arm64/intrinsics.h */
-#ifndef SIMDUTF_ARM64_INTRINSICS_H
-#define SIMDUTF_ARM64_INTRINSICS_H
-
-
-// This should be the correct header whether
-// you use visual studio or other compilers.
-#include <arm_neon.h>
-
-#endif //  SIMDUTF_ARM64_INTRINSICS_H
-/* end file src/simdutf/arm64/intrinsics.h */
-/* begin file src/simdutf/arm64/bitmanipulation.h */
-#ifndef SIMDUTF_ARM64_BITMANIPULATION_H
-#define SIMDUTF_ARM64_BITMANIPULATION_H
+std::string to_string(encoding_type bom) {
+  switch (bom) {
+  case UTF16_LE:
+    return "UTF16 little-endian";
+  case UTF16_BE:
+    return "UTF16 big-endian";
+  case UTF32_LE:
+    return "UTF32 little-endian";
+  case UTF32_BE:
+    return "UTF32 big-endian";
+  case UTF8:
+    return "UTF8";
+  case unspecified:
+    return "unknown";
+  default:
+    return "error";
+  }
+}
 
-namespace simdutf {
-namespace arm64 {
-namespace {
+namespace BOM {
+// Note that BOM for UTF8 is discouraged.
+encoding_type check_bom(const uint8_t *byte, size_t length) {
+  if (length >= 2 && byte[0] == 0xff and byte[1] == 0xfe) {
+    if (length >= 4 && byte[2] == 0x00 and byte[3] == 0x0) {
+      return encoding_type::UTF32_LE;
+    } else {
+      return encoding_type::UTF16_LE;
+    }
+  } else if (length >= 2 && byte[0] == 0xfe and byte[1] == 0xff) {
+    return encoding_type::UTF16_BE;
+  } else if (length >= 4 && byte[0] == 0x00 and byte[1] == 0x00 and
+             byte[2] == 0xfe and byte[3] == 0xff) {
+    return encoding_type::UTF32_BE;
+  } else if (length >= 4 && byte[0] == 0xef and byte[1] == 0xbb and
+             byte[2] == 0xbf) {
+    return encoding_type::UTF8;
+  }
+  return encoding_type::unspecified;
+}
 
-/* result might be undefined when input_num is zero */
-simdutf_really_inline int count_ones(uint64_t input_num) {
-  return vaddv_u8(vcnt_u8(vcreate_u8(input_num)));
+encoding_type check_bom(const char *byte, size_t length) {
+  return check_bom(reinterpret_cast<const uint8_t *>(byte), length);
 }
 
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
-  #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-  unsigned long ret;
-  // Search the mask data from least significant bit (LSB)
-  // to the most significant bit (MSB) for a set bit (1).
-  _BitScanForward64(&ret, input_num);
-  return (int)ret;
-  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
-  return __builtin_ctzll(input_num);
-  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+size_t bom_byte_size(encoding_type bom) {
+  switch (bom) {
+  case UTF16_LE:
+    return 2;
+  case UTF16_BE:
+    return 2;
+  case UTF32_LE:
+    return 4;
+  case UTF32_BE:
+    return 4;
+  case UTF8:
+    return 3;
+  case unspecified:
+    return 0;
+  default:
+    return 0;
+  }
 }
-#endif
 
-} // unnamed namespace
-} // namespace arm64
+} // namespace BOM
 } // namespace simdutf
-
-#endif // SIMDUTF_ARM64_BITMANIPULATION_H
-/* end file src/simdutf/arm64/bitmanipulation.h */
-/* begin file src/simdutf/arm64/simd.h */
-#ifndef SIMDUTF_ARM64_SIMD_H
-#define SIMDUTF_ARM64_SIMD_H
-
-#include <type_traits>
-
+/* end file src/encoding_types.cpp */
+/* begin file src/error.cpp */
 namespace simdutf {
-namespace arm64 {
-namespace {
-namespace simd {
+// deliberately empty
+}
+/* end file src/error.cpp */
+// The large tables should be included once and they
+// should not depend on a kernel.
+/* begin file src/tables/utf8_to_utf16_tables.h */
+#ifndef SIMDUTF_UTF8_TO_UTF16_TABLES_H
+#define SIMDUTF_UTF8_TO_UTF16_TABLES_H
+#include <cstdint>
 
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+namespace simdutf {
 namespace {
-  // Start of private section with Visual Studio workaround
-
-  #ifndef simdutf_make_uint8x16_t
-    #define simdutf_make_uint8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10,   \
-                                    x11, x12, x13, x14, x15, x16)              \
-      ([=]() {                                                                 \
-        uint8_t array[16] = {x1, x2,  x3,  x4,  x5,  x6,  x7,  x8,             \
-                             x9, x10, x11, x12, x13, x14, x15, x16};           \
-        return vld1q_u8(array);                                                \
-      }())
-  #endif
-  #ifndef simdutf_make_int8x16_t
-    #define simdutf_make_int8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10,    \
-                                   x11, x12, x13, x14, x15, x16)               \
-      ([=]() {                                                                 \
-        int8_t array[16] = {x1, x2,  x3,  x4,  x5,  x6,  x7,  x8,              \
-                            x9, x10, x11, x12, x13, x14, x15, x16};            \
-        return vld1q_s8(array);                                                \
-      }())
-  #endif
-
-  #ifndef simdutf_make_uint8x8_t
-    #define simdutf_make_uint8x8_t(x1, x2, x3, x4, x5, x6, x7, x8)             \
-      ([=]() {                                                                 \
-        uint8_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                   \
-        return vld1_u8(array);                                                 \
-      }())
-  #endif
-  #ifndef simdutf_make_int8x8_t
-    #define simdutf_make_int8x8_t(x1, x2, x3, x4, x5, x6, x7, x8)              \
-      ([=]() {                                                                 \
-        int8_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                    \
-        return vld1_s8(array);                                                 \
-      }())
-  #endif
-  #ifndef simdutf_make_uint16x8_t
-    #define simdutf_make_uint16x8_t(x1, x2, x3, x4, x5, x6, x7, x8)            \
-      ([=]() {                                                                 \
-        uint16_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                  \
-        return vld1q_u16(array);                                               \
-      }())
-  #endif
-  #ifndef simdutf_make_int16x8_t
-    #define simdutf_make_int16x8_t(x1, x2, x3, x4, x5, x6, x7, x8)             \
-      ([=]() {                                                                 \
-        int16_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                   \
-        return vld1q_s16(array);                                               \
-      }())
-  #endif
-
-// End of private section with Visual Studio workaround
-} // namespace
-#endif // SIMDUTF_REGULAR_VISUAL_STUDIO
-
-template <typename T> struct simd8;
-
-//
-// Base class of simd8<uint8_t> and simd8<bool>, both of which use uint8x16_t
-// internally.
-//
-template <typename T, typename Mask = simd8<bool>> struct base_u8 {
-  uint8x16_t value;
-  static const int SIZE = sizeof(value);
-
-  // Conversion from/to SIMD register
-  simdutf_really_inline base_u8(const uint8x16_t _value) : value(_value) {}
-  simdutf_really_inline operator const uint8x16_t &() const {
-    return this->value;
-  }
-  simdutf_really_inline operator uint8x16_t &() { return this->value; }
-  simdutf_really_inline T first() const { return vgetq_lane_u8(*this, 0); }
-  simdutf_really_inline T last() const { return vgetq_lane_u8(*this, 15); }
-
-  // Bit operations
-  simdutf_really_inline simd8<T> operator|(const simd8<T> other) const {
-    return vorrq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<T> operator&(const simd8<T> other) const {
-    return vandq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<T> operator^(const simd8<T> other) const {
-    return veorq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const {
-    return vbicq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-  simdutf_really_inline simd8<T> &operator|=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd8<T> &operator&=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd8<T> &operator^=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-
-  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return vceqq_u8(lhs, rhs);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
-    return vextq_u8(prev_chunk, *this, 16 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base_u8<bool> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return vmovq_n_u8(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8(const uint8x16_t _value)
-      : base_u8<bool>(_value) {}
-  // False constructor
-  simdutf_really_inline simd8() : simd8(vdupq_n_u8(0)) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : simd8(splat(_value)) {}
-  simdutf_really_inline void store(uint8_t dst[16]) const {
-    return vst1q_u8(dst, *this);
-  }
-
-  // We return uint32_t instead of uint16_t because that seems to be more
-  // efficient for most purposes (cutting it down to uint16_t costs performance
-  // in some compilers).
-  simdutf_really_inline uint32_t to_bitmask() const {
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-    const uint8x16_t bit_mask =
-        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
-#else
-    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
-#endif
-    auto minput = *this & bit_mask;
-    uint8x16_t tmp = vpaddq_u8(minput, minput);
-    tmp = vpaddq_u8(tmp, tmp);
-    tmp = vpaddq_u8(tmp, tmp);
-    return vgetq_lane_u16(vreinterpretq_u16_u8(tmp), 0);
-  }
-
-  // Returns 4-bit out of each byte, alternating between the high 4 bits and low
-  // bits result it is 64 bit. This method is expected to be faster than none()
-  // and is equivalent when the vector register is the result of a comparison,
-  // with byte values 0xff and 0x00.
-  simdutf_really_inline uint64_t to_bitmask64() const {
-    return vget_lane_u64(
-        vreinterpret_u64_u8(vshrn_n_u16(vreinterpretq_u16_u8(*this), 4)), 0);
-  }
-
-  simdutf_really_inline bool any() const {
-    return vmaxvq_u32(vreinterpretq_u32_u8(*this)) != 0;
-  }
-  simdutf_really_inline bool none() const {
-    return vmaxvq_u32(vreinterpretq_u32_u8(*this)) == 0;
-  }
-  simdutf_really_inline bool all() const {
-    return vminvq_u32(vreinterpretq_u32_u8(*this)) == 0xFFFFF;
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base_u8<uint8_t> {
-  static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value) {
-    return vmovq_n_u8(_value);
-  }
-  static simdutf_really_inline simd8<uint8_t> zero() { return vdupq_n_u8(0); }
-  static simdutf_really_inline simd8<uint8_t> load(const uint8_t *values) {
-    return vld1q_u8(values);
-  }
-  simdutf_really_inline simd8(const uint8x16_t _value)
-      : base_u8<uint8_t>(_value) {}
-  // Zero constructor
-  simdutf_really_inline simd8() : simd8(zero()) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t values[16]) : simd8(load(values)) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Member-by-member initialization
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
-      : simd8(simdutf_make_uint8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                                      v10, v11, v12, v13, v14, v15)) {}
-#else
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
-      : simd8(uint8x16_t{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15}) {}
-#endif
-
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15);
-  }
-
-  // Store to array
-  simdutf_really_inline void store(uint8_t dst[16]) const {
-    return vst1q_u8(dst, *this);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return vqaddq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return vqsubq_u8(*this, other);
-  }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<uint8_t>
-  operator+(const simd8<uint8_t> other) const {
-    return vaddq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  operator-(const simd8<uint8_t> other) const {
-    return vsubq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t> &operator+=(const simd8<uint8_t> other) {
-    *this = *this + other;
-    return *this;
-  }
-  simdutf_really_inline simd8<uint8_t> &operator-=(const simd8<uint8_t> other) {
-    *this = *this - other;
-    return *this;
-  }
-
-  // Order-specific operations
-  simdutf_really_inline uint8_t max_val() const { return vmaxvq_u8(*this); }
-  simdutf_really_inline uint8_t min_val() const { return vminvq_u8(*this); }
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return vmaxq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return vminq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return vcleq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return vcgeq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return vcltq_u8(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return vcgtq_u8(*this, other);
-  }
-  // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
-  // = nonzero. For ARM, returns all 1's.
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return simd8<uint8_t>(*this > other);
-  }
-  // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
-  // = nonzero. For ARM, returns all 1's.
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return simd8<uint8_t>(*this < other);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return vtstq_u8(*this, bits);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    return this->max_val() < 0b10000000u;
-  }
-
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return this->max_val() != 0;
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return (*this & bits).any_bits_set_anywhere();
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return vshrq_n_u8(*this, N);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return vshlq_n_u8(*this, N);
-  }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return lookup_table.apply_lookup_16_to(*this);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-
-  template <typename T>
-  simdutf_really_inline simd8<uint8_t>
-  apply_lookup_16_to(const simd8<T> original) const {
-    return vqtbl1q_u8(*this, simd8<uint8_t>(original));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> {
-  int8x16_t value;
-
-  static simdutf_really_inline simd8<int8_t> splat(int8_t _value) {
-    return vmovq_n_s8(_value);
-  }
-  static simdutf_really_inline simd8<int8_t> zero() { return vdupq_n_s8(0); }
-  static simdutf_really_inline simd8<int8_t> load(const int8_t values[16]) {
-    return vld1q_s8(values);
-  }
-
-  // Use ST2 instead of UXTL+UXTL2 to interleave zeroes. UXTL is actually a
-  // USHLL #0, and shifting in NEON is actually quite slow.
-  //
-  // While this needs the registers to be in a specific order, bigger cores can
-  // interleave these with no overhead, and it still performs decently on little
-  // cores.
-  //    movi  v1.3d, #0
-  //      mov   v0.16b, value[0]
-  //    st2   {v0.16b, v1.16b}, [ptr], #32
-  //      mov   v0.16b, value[1]
-  //    st2   {v0.16b, v1.16b}, [ptr], #32
-  //    ...
-  template <endianness big_endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
-    int8x16x2_t pair = match_system(big_endian)
-                           ? int8x16x2_t{{this->value, vmovq_n_s8(0)}}
-                           : int8x16x2_t{{vmovq_n_s8(0), this->value}};
-    vst2q_s8(reinterpret_cast<int8_t *>(p), pair);
-  }
-
-  // currently unused
-  // Technically this could be done with ST4 like in store_ascii_as_utf16, but
-  // it is very much not worth it, as explicitly mentioned in the ARM Cortex-X1
-  // Core Software Optimization Guide:
-  //   4.18 Complex ASIMD instructions
-  //     The bandwidth of [ST4 with element size less than 64b] is limited by
-  //     decode constraints and it is advisable to avoid them when high
-  //     performing code is desired.
-  // Instead, it is better to use ZIP1+ZIP2 and two ST2.
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
-    const uint16x8_t low =
-        vreinterpretq_u16_s8(vzip1q_s8(this->value, vmovq_n_s8(0)));
-    const uint16x8_t high =
-        vreinterpretq_u16_s8(vzip2q_s8(this->value, vmovq_n_s8(0)));
-    const uint16x8x2_t low_pair{{low, vmovq_n_u16(0)}};
-    vst2q_u16(reinterpret_cast<uint16_t *>(p), low_pair);
-    const uint16x8x2_t high_pair{{high, vmovq_n_u16(0)}};
-    vst2q_u16(reinterpret_cast<uint16_t *>(p + 8), high_pair);
-  }
-
-  // In places where the table can be reused, which is most uses in simdutf, it
-  // is worth it to do 4 table lookups, as there is no direct zero extension
-  // from u8 to u32.
-  simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t *p) const {
-    const simd8<uint8_t> tb1{0, 255, 255, 255, 1, 255, 255, 255,
-                             2, 255, 255, 255, 3, 255, 255, 255};
-    const simd8<uint8_t> tb2{4, 255, 255, 255, 5, 255, 255, 255,
-                             6, 255, 255, 255, 7, 255, 255, 255};
-    const simd8<uint8_t> tb3{8,  255, 255, 255, 9,  255, 255, 255,
-                             10, 255, 255, 255, 11, 255, 255, 255};
-    const simd8<uint8_t> tb4{12, 255, 255, 255, 13, 255, 255, 255,
-                             14, 255, 255, 255, 15, 255, 255, 255};
-
-    // encourage store pairing and interleaving
-    const auto shuf1 = this->apply_lookup_16_to(tb1);
-    const auto shuf2 = this->apply_lookup_16_to(tb2);
-    shuf1.store(reinterpret_cast<int8_t *>(p));
-    shuf2.store(reinterpret_cast<int8_t *>(p + 4));
-
-    const auto shuf3 = this->apply_lookup_16_to(tb3);
-    const auto shuf4 = this->apply_lookup_16_to(tb4);
-    shuf3.store(reinterpret_cast<int8_t *>(p + 8));
-    shuf4.store(reinterpret_cast<int8_t *>(p + 12));
-  }
-  // Conversion from/to SIMD register
-  simdutf_really_inline simd8(const int8x16_t _value) : value{_value} {}
-  simdutf_really_inline operator const int8x16_t &() const {
-    return this->value;
-  }
-#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
-  simdutf_really_inline operator const uint8x16_t() const {
-    return vreinterpretq_u8_s8(this->value);
-  }
-#endif
-  simdutf_really_inline operator int8x16_t &() { return this->value; }
-
-  // Zero constructor
-  simdutf_really_inline simd8() : simd8(zero()) {}
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
-                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
-                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
-      : simd8(simdutf_make_int8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                                     v10, v11, v12, v13, v14, v15)) {}
-#else
-  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
-                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
-                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
-      : simd8(int8x16_t{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                        v13, v14, v15}) {}
-#endif
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15);
-  }
-
-  // Store to array
-  simdutf_really_inline void store(int8_t dst[16]) const {
-    return vst1q_s8(dst, value);
-  }
-  // Explicit conversion to/from unsigned
-  //
-  // Under Visual Studio/ARM64 uint8x16_t and int8x16_t are apparently the same
-  // type. In theory, we could check this occurrence with std::same_as and
-  // std::enabled_if but it is C++14 and relatively ugly and hard to read.
-#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
-  simdutf_really_inline explicit simd8(const uint8x16_t other)
-      : simd8(vreinterpretq_s8_u8(other)) {}
-#endif
-  simdutf_really_inline operator simd8<uint8_t>() const {
-    return vreinterpretq_u8_s8(this->value);
-  }
-
-  simdutf_really_inline simd8<int8_t>
-  operator|(const simd8<int8_t> other) const {
-    return vorrq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator&(const simd8<int8_t> other) const {
-    return vandq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator^(const simd8<int8_t> other) const {
-    return veorq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  bit_andnot(const simd8<int8_t> other) const {
-    return vbicq_s8(value, other.value);
-  }
-
-  // Math
-  simdutf_really_inline simd8<int8_t>
-  operator+(const simd8<int8_t> other) const {
-    return vaddq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator-(const simd8<int8_t> other) const {
-    return vsubq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t> &operator+=(const simd8<int8_t> other) {
-    *this = *this + other;
-    return *this;
-  }
-  simdutf_really_inline simd8<int8_t> &operator-=(const simd8<int8_t> other) {
-    *this = *this - other;
-    return *this;
-  }
-
-  simdutf_really_inline int8_t max_val() const { return vmaxvq_s8(value); }
-  simdutf_really_inline int8_t min_val() const { return vminvq_s8(value); }
-  simdutf_really_inline bool is_ascii() const { return this->min_val() >= 0; }
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return vmaxq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return vminq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return vcgtq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return vcltq_s8(value, other.value);
-  }
-  simdutf_really_inline simd8<bool>
-  operator==(const simd8<int8_t> other) const {
-    return vceqq_s8(value, other.value);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd8<int8_t>
-  prev(const simd8<int8_t> prev_chunk) const {
-    return vextq_s8(prev_chunk, *this, 16 - N);
-  }
-
-  // Perform a lookup assuming no value is larger than 16
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return lookup_table.apply_lookup_16_to(*this);
-  }
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-
-  template <typename T>
-  simdutf_really_inline simd8<int8_t>
-  apply_lookup_16_to(const simd8<T> original) const {
-    return vqtbl1q_s8(*this, simd8<uint8_t>(original));
-  }
-};
-
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(NUM_CHUNKS == 4,
-                "ARM kernel should use four registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
-                                 const simd8<T> chunk2, const simd8<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    this->chunks[2] |= other.chunks[2];
-    this->chunks[3] |= other.chunks[3];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
-
-  template <endianness endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 0);
-    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 1);
-    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 2);
-    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
-    this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
-    this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
-    this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-    const uint8x16_t bit_mask =
-        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
-#else
-    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
-#endif
-    // Add each of the elements next to each other, successively, to stuff each
-    // 8 byte mask into one.
-    uint8x16_t sum0 =
-        vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[0]), bit_mask),
-                  vandq_u8(uint8x16_t(this->chunks[1]), bit_mask));
-    uint8x16_t sum1 =
-        vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[2]), bit_mask),
-                  vandq_u8(uint8x16_t(this->chunks[3]), bit_mask));
-    sum0 = vpaddq_u8(sum0, sum1);
-    sum0 = vpaddq_u8(sum0, sum0);
-    return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                          this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                          this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-    return simd8x64<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
-               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
-               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                          this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
-                          this->chunks[2] > mask, this->chunks[3] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
-                          this->chunks[2] >= mask, this->chunks[3] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>(simd8<uint8_t>(uint8x16_t(this->chunks[0])) >= mask,
-                          simd8<uint8_t>(uint8x16_t(this->chunks[1])) >= mask,
-                          simd8<uint8_t>(uint8x16_t(this->chunks[2])) >= mask,
-                          simd8<uint8_t>(uint8x16_t(this->chunks[3])) >= mask)
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-/* begin file src/simdutf/arm64/simd16-inl.h */
-template <typename T> struct simd16;
-
-template <typename T, typename Mask = simd16<bool>> struct base_u16 {
-  uint16x8_t value;
-  static const int SIZE = sizeof(value);
-
-  // Conversion from/to SIMD register
-  simdutf_really_inline base_u16() = default;
-  simdutf_really_inline base_u16(const uint16x8_t _value) : value(_value) {}
-  simdutf_really_inline operator const uint16x8_t &() const {
-    return this->value;
-  }
-  simdutf_really_inline operator uint16x8_t &() { return this->value; }
-  // Bit operations
-  simdutf_really_inline simd16<T> operator|(const simd16<T> other) const {
-    return vorrq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator&(const simd16<T> other) const {
-    return vandq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator^(const simd16<T> other) const {
-    return veorq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const {
-    return vbicq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
-  simdutf_really_inline simd16<T> &operator|=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd16<T> &operator&=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd16<T> &operator^=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-
-  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
-                                               const simd16<T> rhs) {
-    return vceqq_u16(lhs, rhs);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return vextq_u18(prev_chunk, *this, 8 - N);
-  }
-};
-
-template <typename T, typename Mask = simd16<bool>>
-struct base16 : base_u16<T> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  simdutf_really_inline base16() : base_u16<T>() {}
-  simdutf_really_inline base16(const uint16x8_t _value) : base_u16<T>(_value) {}
-  template <typename Pointer>
-  simdutf_really_inline base16(const Pointer *ptr) : base16(vld1q_u16(ptr)) {}
-
-  static const int SIZE = sizeof(base_u16<T>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return vextq_u18(prev_chunk, *this, 8 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd16<bool> : base16<bool> {
-  static simdutf_really_inline simd16<bool> splat(bool _value) {
-    return vmovq_n_u16(uint16_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd16() : base16() {}
-  simdutf_really_inline simd16(const uint16x8_t _value)
-      : base16<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
-};
-
-template <typename T> struct base16_numeric : base16<T> {
-  static simdutf_really_inline simd16<T> splat(T _value) {
-    return vmovq_n_u16(_value);
-  }
-  static simdutf_really_inline simd16<T> zero() { return vdupq_n_u16(0); }
-  static simdutf_really_inline simd16<T> load(const T values[8]) {
-    return vld1q_u16(reinterpret_cast<const uint16_t *>(values));
-  }
-
-  simdutf_really_inline base16_numeric() : base16<T>() {}
-  simdutf_really_inline base16_numeric(const uint16x8_t _value)
-      : base16<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[8]) const {
-    return vst1q_u16(dst, *this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
-    return vaddq_u8(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
-    return vsubq_u8(*this, other);
-  }
-  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
-    *this = *this + other;
-    return *static_cast<simd16<T> *>(this);
-  }
-  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
-    *this = *this - other;
-    return *static_cast<simd16<T> *>(this);
-  }
-};
-
-// Signed code units
-template <> struct simd16<int16_t> : base16_numeric<int16_t> {
-  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
-#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
-  simdutf_really_inline simd16(const uint16x8_t _value)
-      : base16_numeric<int16_t>(_value) {}
-#endif
-  simdutf_really_inline simd16(const int16x8_t _value)
-      : base16_numeric<int16_t>(vreinterpretq_u16_s16(_value)) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
-  simdutf_really_inline operator simd16<uint16_t>() const;
-  simdutf_really_inline operator const uint16x8_t &() const {
-    return this->value;
-  }
-  simdutf_really_inline operator const int16x8_t() const {
-    return vreinterpretq_s16_u16(this->value);
-  }
-
-  simdutf_really_inline int16_t max_val() const {
-    return vmaxvq_s16(vreinterpretq_s16_u16(this->value));
-  }
-  simdutf_really_inline int16_t min_val() const {
-    return vminvq_s16(vreinterpretq_s16_u16(this->value));
-  }
-  // Order-sensitive comparisons
-  simdutf_really_inline simd16<int16_t>
-  max_val(const simd16<int16_t> other) const {
-    return vmaxq_s16(vreinterpretq_s16_u16(this->value),
-                     vreinterpretq_s16_u16(other.value));
-  }
-  simdutf_really_inline simd16<int16_t>
-  min_val(const simd16<int16_t> other) const {
-    return vmaxq_s16(vreinterpretq_s16_u16(this->value),
-                     vreinterpretq_s16_u16(other.value));
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<int16_t> other) const {
-    return vcgtq_s16(vreinterpretq_s16_u16(this->value),
-                     vreinterpretq_s16_u16(other.value));
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<int16_t> other) const {
-    return vcltq_s16(vreinterpretq_s16_u16(this->value),
-                     vreinterpretq_s16_u16(other.value));
-  }
-};
-
-// Unsigned code units
-template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
-  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
-  simdutf_really_inline simd16(const uint16x8_t _value)
-      : base16_numeric<uint16_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
-
-  simdutf_really_inline int16_t max_val() const { return vmaxvq_u16(*this); }
-  simdutf_really_inline int16_t min_val() const { return vminvq_u16(*this); }
-  // Saturated math
-  simdutf_really_inline simd16<uint16_t>
-  saturating_add(const simd16<uint16_t> other) const {
-    return vqaddq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  saturating_sub(const simd16<uint16_t> other) const {
-    return vqsubq_u16(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd16<uint16_t>
-  max_val(const simd16<uint16_t> other) const {
-    return vmaxq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  min_val(const simd16<uint16_t> other) const {
-    return vminq_u16(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  gt_bits(const simd16<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  lt_bits(const simd16<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<=(const simd16<uint16_t> other) const {
-    return vcleq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>=(const simd16<uint16_t> other) const {
-    return vcgeq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<uint16_t> other) const {
-    return vcgtq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<uint16_t> other) const {
-    return vcltq_u16(*this, other);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd16<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
-    return simd16<uint16_t>(vshrq_n_u16(*this, N));
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
-    return simd16<uint16_t>(vshlq_n_u16(*this, N));
-  }
-
-  // logical operations
-  simdutf_really_inline simd16<uint16_t>
-  operator|(const simd16<uint16_t> other) const {
-    return vorrq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  operator&(const simd16<uint16_t> other) const {
-    return vandq_u16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  operator^(const simd16<uint16_t> other) const {
-    return veorq_u16(*this, other);
-  }
-
-  // Pack with the unsigned saturation of two uint16_t code units into single
-  // uint8_t vector
-  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
-                                                   const simd16<uint16_t> &v1) {
-    return vqmovn_high_u16(vqmovn_u16(v0), v1);
-  }
-
-  // Change the endianness
-  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
-    return vreinterpretq_u16_u8(vrev16q_u8(vreinterpretq_u8_u16(*this)));
-  }
-};
-simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
-  return this->value;
-}
-
-template <typename T> struct simd16x32 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
-  static_assert(NUM_CHUNKS == 4,
-                "ARM kernel should use four registers per 64-byte block.");
-  simd16<T> chunks[NUM_CHUNKS];
-
-  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
-  simd16x32<T> &
-  operator=(const simd16<T> other) = delete; // no assignment allowed
-  simd16x32() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline
-  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
-            const simd16<T> chunk2, const simd16<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd16x32(const T *ptr)
-      : chunks{simd16<T>::load(ptr),
-               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd16<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
-
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
-    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
-    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
-    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-    const uint8x16_t bit_mask =
-        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
-#else
-    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
-                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
-#endif
-    // Add each of the elements next to each other, successively, to stuff each
-    // 8 byte mask into one.
-    uint8x16_t sum0 = vpaddq_u8(
-        vreinterpretq_u8_u16(this->chunks[0] & vreinterpretq_u16_u8(bit_mask)),
-        vreinterpretq_u8_u16(this->chunks[1] & vreinterpretq_u16_u8(bit_mask)));
-    uint8x16_t sum1 = vpaddq_u8(
-        vreinterpretq_u8_u16(this->chunks[2] & vreinterpretq_u16_u8(bit_mask)),
-        vreinterpretq_u8_u16(this->chunks[3] & vreinterpretq_u16_u8(bit_mask)));
-    sum0 = vpaddq_u8(sum0, sum1);
-    sum0 = vpaddq_u8(sum0, sum0);
-    return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
-  }
-
-  simdutf_really_inline void swap_bytes() {
-    this->chunks[0] = this->chunks[0].swap_bytes();
-    this->chunks[1] = this->chunks[1].swap_bytes();
-    this->chunks[2] = this->chunks[2].swap_bytes();
-    this->chunks[3] = this->chunks[3].swap_bytes();
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                           this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                           this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-
-    return simd16x32<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-    return simd16x32<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
-               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
-               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                           this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-
-}; // struct simd16x32<T>
-template <>
-simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
-    const uint16_t low, const uint16_t high) const {
-  const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
-  const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
-  simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) |
-                                         (this->chunks[0] < mask_low)),
-                        simd16<uint16_t>((this->chunks[1] > mask_high) |
-                                         (this->chunks[1] < mask_low)),
-                        simd16<uint16_t>((this->chunks[2] > mask_high) |
-                                         (this->chunks[2] < mask_low)),
-                        simd16<uint16_t>((this->chunks[3] > mask_high) |
-                                         (this->chunks[3] < mask_low)));
-  return x.to_bitmask();
-}
-/* end file src/simdutf/arm64/simd16-inl.h */
-} // namespace simd
-} // unnamed namespace
-} // namespace arm64
-} // namespace simdutf
-
-#endif // SIMDUTF_ARM64_SIMD_H
-/* end file src/simdutf/arm64/simd.h */
-
-/* begin file src/simdutf/arm64/end.h */
-/* end file src/simdutf/arm64/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_ARM64
-
-#endif // SIMDUTF_ARM64_H
-/* end file src/simdutf/arm64.h */
-/* begin file src/simdutf/icelake.h */
-#ifndef SIMDUTF_ICELAKE_H
-#define SIMDUTF_ICELAKE_H
-
-
-#ifdef __has_include
-  // How do we detect that a compiler supports vbmi2?
-  // For sure if the following header is found, we are ok?
-  #if __has_include(<avx512vbmi2intrin.h>)
-    #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
-  #endif
-#endif
-
-#ifdef _MSC_VER
-  #if _MSC_VER >= 1930
-    // Visual Studio 2022 and up support VBMI2 under x64 even if the header
-    // avx512vbmi2intrin.h is not found.
-    // Visual Studio 2019 technically supports VBMI2, but the implementation
-    // might be unreliable. Search for visualstudio2019icelakeissue in our
-    // tests.
-    #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
-  #endif
-#endif
-
-// We allow icelake on x64 as long as the compiler is known to support VBMI2.
-#ifndef SIMDUTF_IMPLEMENTATION_ICELAKE
-  #define SIMDUTF_IMPLEMENTATION_ICELAKE                                       \
-    ((SIMDUTF_IS_X86_64) && (SIMDUTF_COMPILER_SUPPORTS_VBMI2))
-#endif
-
-// To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
-// https://github.com/simdutf/simdutf/issues/1247
-#if ((SIMDUTF_IMPLEMENTATION_ICELAKE) && (SIMDUTF_IS_X86_64) && (__AVX2__) &&  \
-     (SIMDUTF_HAS_AVX512F && SIMDUTF_HAS_AVX512DQ && SIMDUTF_HAS_AVX512VL &&   \
-      SIMDUTF_HAS_AVX512VBMI2) &&                                              \
-     (!SIMDUTF_IS_32BITS))
-  #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 1
-#else
-  #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 0
-#endif
-
-#if SIMDUTF_IMPLEMENTATION_ICELAKE
-  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
-    #define SIMDUTF_TARGET_ICELAKE
-  #else
-    #define SIMDUTF_TARGET_ICELAKE                                             \
-      SIMDUTF_TARGET_REGION(                                                   \
-          "avx512f,avx512dq,avx512cd,avx512bw,avx512vbmi,avx512vbmi2,"         \
-          "avx512vl,avx2,bmi,bmi2,pclmul,lzcnt,popcnt,avx512vpopcntdq")
-  #endif
-
-namespace simdutf {
-namespace icelake {} // namespace icelake
-} // namespace simdutf
-
-  //
-  // These two need to be included outside SIMDUTF_TARGET_REGION
-  //
-/* begin file src/simdutf/icelake/intrinsics.h */
-#ifndef SIMDUTF_ICELAKE_INTRINSICS_H
-#define SIMDUTF_ICELAKE_INTRINSICS_H
-
-
-#ifdef SIMDUTF_VISUAL_STUDIO
-  // under clang within visual studio, this will include <x86intrin.h>
-  #include <intrin.h> // visual studio or clang
-  #include <immintrin.h>
-#else
-
-  #if SIMDUTF_GCC11ORMORE
-// We should not get warnings while including <x86intrin.h> yet we do
-// under some versions of GCC.
-// If the x86intrin.h header has uninitialized values that are problematic,
-// it is a GCC issue, we want to ignore these warnings.
-SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
-  #endif
-
-  #include <x86intrin.h> // elsewhere
-
-  #if SIMDUTF_GCC11ORMORE
-// cancels the suppression of the -Wuninitialized
-SIMDUTF_POP_DISABLE_WARNINGS
-  #endif
-
-  #ifndef _tzcnt_u64
-    #define _tzcnt_u64(x) __tzcnt_u64(x)
-  #endif // _tzcnt_u64
-#endif   // SIMDUTF_VISUAL_STUDIO
-
-#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
-  /**
-   * You are not supposed, normally, to include these
-   * headers directly. Instead you should either include intrin.h
-   * or x86intrin.h. However, when compiling with clang
-   * under Windows (i.e., when _MSC_VER is set), these headers
-   * only get included *if* the corresponding features are detected
-   * from macros:
-   * e.g., if __AVX2__ is set... in turn,  we normally set these
-   * macros by compiling against the corresponding architecture
-   * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
-   * software with these advanced instructions. In simdutf, we
-   * want to compile the whole program for a generic target,
-   * and only target our specific kernels. As a workaround,
-   * we directly include the needed headers. These headers would
-   * normally guard against such usage, but we carefully included
-   * <x86intrin.h>  (or <intrin.h>) before, so the headers
-   * are fooled.
-   */
-  #include <bmiintrin.h>   // for _blsr_u64
-  #include <bmi2intrin.h>  // for _pext_u64, _pdep_u64
-  #include <lzcntintrin.h> // for  __lzcnt64
-  #include <immintrin.h>   // for most things (AVX2, AVX512, _popcnt64)
-  #include <smmintrin.h>
-  #include <tmmintrin.h>
-  #include <avxintrin.h>
-  #include <avx2intrin.h>
-  // Important: we need the AVX-512 headers:
-  #include <avx512fintrin.h>
-  #include <avx512dqintrin.h>
-  #include <avx512cdintrin.h>
-  #include <avx512bwintrin.h>
-  #include <avx512vlintrin.h>
-  #include <avx512vlbwintrin.h>
-  #include <avx512vbmiintrin.h>
-  #include <avx512vbmi2intrin.h>
-  #include <avx512vpopcntdqintrin.h>
-  #include <avx512vpopcntdqvlintrin.h>
-  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
-  // has it as a macro.
-  #ifndef _blsr_u64
-    // we roll our own
-    #define _blsr_u64(n) ((n - 1) & n)
-  #endif //  _blsr_u64
-#endif   // SIMDUTF_CLANG_VISUAL_STUDIO
-
-#if defined(__GNUC__) && !defined(__clang__)
-
-  #if __GNUC__ == 8
-    #define SIMDUTF_GCC8 1
-  #elif __GNUC__ == 9
-    #define SIMDUTF_GCC9 1
-  #endif //  __GNUC__ == 8 || __GNUC__ == 9
-
-#endif // defined(__GNUC__) && !defined(__clang__)
-
-#if SIMDUTF_GCC8
-  #pragma GCC push_options
-  #pragma GCC target("avx512f")
-/**
- * GCC 8 fails to provide _mm512_set_epi8. We roll our own.
- */
-inline __m512i
-_mm512_set_epi8(uint8_t a0, uint8_t a1, uint8_t a2, uint8_t a3, uint8_t a4,
-                uint8_t a5, uint8_t a6, uint8_t a7, uint8_t a8, uint8_t a9,
-                uint8_t a10, uint8_t a11, uint8_t a12, uint8_t a13, uint8_t a14,
-                uint8_t a15, uint8_t a16, uint8_t a17, uint8_t a18, uint8_t a19,
-                uint8_t a20, uint8_t a21, uint8_t a22, uint8_t a23, uint8_t a24,
-                uint8_t a25, uint8_t a26, uint8_t a27, uint8_t a28, uint8_t a29,
-                uint8_t a30, uint8_t a31, uint8_t a32, uint8_t a33, uint8_t a34,
-                uint8_t a35, uint8_t a36, uint8_t a37, uint8_t a38, uint8_t a39,
-                uint8_t a40, uint8_t a41, uint8_t a42, uint8_t a43, uint8_t a44,
-                uint8_t a45, uint8_t a46, uint8_t a47, uint8_t a48, uint8_t a49,
-                uint8_t a50, uint8_t a51, uint8_t a52, uint8_t a53, uint8_t a54,
-                uint8_t a55, uint8_t a56, uint8_t a57, uint8_t a58, uint8_t a59,
-                uint8_t a60, uint8_t a61, uint8_t a62, uint8_t a63) {
-  return _mm512_set_epi64(
-      uint64_t(a7) + (uint64_t(a6) << 8) + (uint64_t(a5) << 16) +
-          (uint64_t(a4) << 24) + (uint64_t(a3) << 32) + (uint64_t(a2) << 40) +
-          (uint64_t(a1) << 48) + (uint64_t(a0) << 56),
-      uint64_t(a15) + (uint64_t(a14) << 8) + (uint64_t(a13) << 16) +
-          (uint64_t(a12) << 24) + (uint64_t(a11) << 32) +
-          (uint64_t(a10) << 40) + (uint64_t(a9) << 48) + (uint64_t(a8) << 56),
-      uint64_t(a23) + (uint64_t(a22) << 8) + (uint64_t(a21) << 16) +
-          (uint64_t(a20) << 24) + (uint64_t(a19) << 32) +
-          (uint64_t(a18) << 40) + (uint64_t(a17) << 48) + (uint64_t(a16) << 56),
-      uint64_t(a31) + (uint64_t(a30) << 8) + (uint64_t(a29) << 16) +
-          (uint64_t(a28) << 24) + (uint64_t(a27) << 32) +
-          (uint64_t(a26) << 40) + (uint64_t(a25) << 48) + (uint64_t(a24) << 56),
-      uint64_t(a39) + (uint64_t(a38) << 8) + (uint64_t(a37) << 16) +
-          (uint64_t(a36) << 24) + (uint64_t(a35) << 32) +
-          (uint64_t(a34) << 40) + (uint64_t(a33) << 48) + (uint64_t(a32) << 56),
-      uint64_t(a47) + (uint64_t(a46) << 8) + (uint64_t(a45) << 16) +
-          (uint64_t(a44) << 24) + (uint64_t(a43) << 32) +
-          (uint64_t(a42) << 40) + (uint64_t(a41) << 48) + (uint64_t(a40) << 56),
-      uint64_t(a55) + (uint64_t(a54) << 8) + (uint64_t(a53) << 16) +
-          (uint64_t(a52) << 24) + (uint64_t(a51) << 32) +
-          (uint64_t(a50) << 40) + (uint64_t(a49) << 48) + (uint64_t(a48) << 56),
-      uint64_t(a63) + (uint64_t(a62) << 8) + (uint64_t(a61) << 16) +
-          (uint64_t(a60) << 24) + (uint64_t(a59) << 32) +
-          (uint64_t(a58) << 40) + (uint64_t(a57) << 48) +
-          (uint64_t(a56) << 56));
-}
-  #pragma GCC pop_options
-#endif // SIMDUTF_GCC8
-
-#endif // SIMDUTF_HASWELL_INTRINSICS_H
-/* end file src/simdutf/icelake/intrinsics.h */
-/* begin file src/simdutf/icelake/implementation.h */
-#ifndef SIMDUTF_ICELAKE_IMPLEMENTATION_H
-#define SIMDUTF_ICELAKE_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace icelake {
-
-namespace {
-using namespace simdutf;
-}
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation(
-            "icelake",
-            "Intel AVX512 (AVX-512BW, AVX-512CD, AVX-512VL, AVX-512VBMI2 "
-            "extensions)",
-            internal::instruction_set::AVX2 | internal::instruction_set::BMI1 |
-                internal::instruction_set::BMI2 |
-                internal::instruction_set::AVX512BW |
-                internal::instruction_set::AVX512CD |
-                internal::instruction_set::AVX512VL |
-                internal::instruction_set::AVX512VBMI2 |
-                internal::instruction_set::AVX512VPOPCNTDQ) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-
-} // namespace icelake
-} // namespace simdutf
-
-#endif // SIMDUTF_ICELAKE_IMPLEMENTATION_H
-/* end file src/simdutf/icelake/implementation.h */
-
-  //
-  // The rest need to be inside the region
-  //
-/* begin file src/simdutf/icelake/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "icelake"
-// #define SIMDUTF_IMPLEMENTATION icelake
-
-#if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
-// nothing needed.
-#else
-SIMDUTF_TARGET_ICELAKE
-#endif
-
-#if SIMDUTF_GCC11ORMORE // workaround for
-                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
-// clang-format off
-SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
-// clang-format on
-#endif // end of workaround
-/* end file src/simdutf/icelake/begin.h */
-  // Declarations
-/* begin file src/simdutf/icelake/bitmanipulation.h */
-#ifndef SIMDUTF_ICELAKE_BITMANIPULATION_H
-#define SIMDUTF_ICELAKE_BITMANIPULATION_H
-
-namespace simdutf {
-namespace icelake {
-namespace {
-
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
-  // note: we do not support legacy 32-bit Windows
-  return __popcnt64(input_num); // Visual Studio wants two underscores
-}
-#else
-simdutf_really_inline long long int count_ones(uint64_t input_num) {
-  return _popcnt64(input_num);
-}
-#endif
-
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
-  #if SIMDUTF_REGULAR_VISUAL_STUDIO
-  return (int)_tzcnt_u64(input_num);
-  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
-  return __builtin_ctzll(input_num);
-  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
-}
-#endif
-
-} // unnamed namespace
-} // namespace icelake
-} // namespace simdutf
-
-#endif // SIMDUTF_ICELAKE_BITMANIPULATION_H
-/* end file src/simdutf/icelake/bitmanipulation.h */
-/* begin file src/simdutf/icelake/end.h */
-#if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
-// nothing needed.
-#else
-SIMDUTF_UNTARGET_REGION
-#endif
-
-
-#if SIMDUTF_GCC11ORMORE // workaround for
-                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
-SIMDUTF_POP_DISABLE_WARNINGS
-#endif // end of workaround
-/* end file src/simdutf/icelake/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_ICELAKE
-#endif // SIMDUTF_ICELAKE_H
-/* end file src/simdutf/icelake.h */
-/* begin file src/simdutf/haswell.h */
-#ifndef SIMDUTF_HASWELL_H
-#define SIMDUTF_HASWELL_H
-
-#ifdef SIMDUTF_WESTMERE_H
-  #error "haswell.h must be included before westmere.h"
-#endif
-#ifdef SIMDUTF_FALLBACK_H
-  #error "haswell.h must be included before fallback.h"
-#endif
-
-
-// Default Haswell to on if this is x86-64. Even if we are not compiled for it,
-// it could be selected at runtime.
-#ifndef SIMDUTF_IMPLEMENTATION_HASWELL
-  //
-  // You do not want to restrict it like so: SIMDUTF_IS_X86_64 && __AVX2__
-  // because we want to rely on *runtime dispatch*.
-  //
-  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
-    #define SIMDUTF_IMPLEMENTATION_HASWELL 0
-  #else
-    #define SIMDUTF_IMPLEMENTATION_HASWELL (SIMDUTF_IS_X86_64)
-  #endif
-
-#endif
-// To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
-// https://github.com/simdutf/simdutf/issues/1247
-#if ((SIMDUTF_IMPLEMENTATION_HASWELL) && (SIMDUTF_IS_X86_64) && (__AVX2__))
-  #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 1
-#else
-  #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 0
-#endif
-
-#if SIMDUTF_IMPLEMENTATION_HASWELL
-
-  #define SIMDUTF_TARGET_HASWELL SIMDUTF_TARGET_REGION("avx2,bmi,lzcnt,popcnt")
-
-namespace simdutf {
-/**
- * Implementation for Haswell (Intel AVX2).
- */
-namespace haswell {} // namespace haswell
-} // namespace simdutf
-
-  //
-  // These two need to be included outside SIMDUTF_TARGET_REGION
-  //
-/* begin file src/simdutf/haswell/implementation.h */
-#ifndef SIMDUTF_HASWELL_IMPLEMENTATION_H
-#define SIMDUTF_HASWELL_IMPLEMENTATION_H
-
-
-// The constructor may be executed on any host, so we take care not to use
-// SIMDUTF_TARGET_REGION
-namespace simdutf {
-namespace haswell {
-
-using namespace simdutf;
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("haswell", "Intel/AMD AVX2",
-                                internal::instruction_set::AVX2 |
-                                    internal::instruction_set::BMI1 |
-                                    internal::instruction_set::BMI2) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused virtual size_t
-  maximal_binary_length_from_base64(const char *input,
-                                    size_t length) const noexcept;
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual size_t
-  maximal_binary_length_from_base64(const char16_t *input,
-                                    size_t length) const noexcept;
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual size_t
-  base64_length_from_binary(size_t length,
-                            base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-
-} // namespace haswell
-} // namespace simdutf
-
-#endif // SIMDUTF_HASWELL_IMPLEMENTATION_H
-/* end file src/simdutf/haswell/implementation.h */
-/* begin file src/simdutf/haswell/intrinsics.h */
-#ifndef SIMDUTF_HASWELL_INTRINSICS_H
-#define SIMDUTF_HASWELL_INTRINSICS_H
-
-
-#ifdef SIMDUTF_VISUAL_STUDIO
-  // under clang within visual studio, this will include <x86intrin.h>
-  #include <intrin.h> // visual studio or clang
-#else
-
-  #if SIMDUTF_GCC11ORMORE
-// We should not get warnings while including <x86intrin.h> yet we do
-// under some versions of GCC.
-// If the x86intrin.h header has uninitialized values that are problematic,
-// it is a GCC issue, we want to ignore these warnings.
-SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
-  #endif
-
-  #include <x86intrin.h> // elsewhere
-
-  #if SIMDUTF_GCC11ORMORE
-// cancels the suppression of the -Wuninitialized
-SIMDUTF_POP_DISABLE_WARNINGS
-  #endif
-
-#endif // SIMDUTF_VISUAL_STUDIO
-
-#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
-  /**
-   * You are not supposed, normally, to include these
-   * headers directly. Instead you should either include intrin.h
-   * or x86intrin.h. However, when compiling with clang
-   * under Windows (i.e., when _MSC_VER is set), these headers
-   * only get included *if* the corresponding features are detected
-   * from macros:
-   * e.g., if __AVX2__ is set... in turn,  we normally set these
-   * macros by compiling against the corresponding architecture
-   * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
-   * software with these advanced instructions. In simdutf, we
-   * want to compile the whole program for a generic target,
-   * and only target our specific kernels. As a workaround,
-   * we directly include the needed headers. These headers would
-   * normally guard against such usage, but we carefully included
-   * <x86intrin.h>  (or <intrin.h>) before, so the headers
-   * are fooled.
-   */
-  #include <bmiintrin.h>   // for _blsr_u64
-  #include <lzcntintrin.h> // for  __lzcnt64
-  #include <immintrin.h>   // for most things (AVX2, AVX512, _popcnt64)
-  #include <smmintrin.h>
-  #include <tmmintrin.h>
-  #include <avxintrin.h>
-  #include <avx2intrin.h>
-  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
-  // has it as a macro.
-  #ifndef _blsr_u64
-    // we roll our own
-    #define _blsr_u64(n) ((n - 1) & n)
-  #endif //  _blsr_u64
-#endif   // SIMDUTF_CLANG_VISUAL_STUDIO
-
-#endif // SIMDUTF_HASWELL_INTRINSICS_H
-/* end file src/simdutf/haswell/intrinsics.h */
-
-  //
-  // The rest need to be inside the region
-  //
-/* begin file src/simdutf/haswell/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "haswell"
-// #define SIMDUTF_IMPLEMENTATION haswell
-
-#if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
-// nothing needed.
-#else
-SIMDUTF_TARGET_HASWELL
-#endif
-
-#if SIMDUTF_GCC11ORMORE // workaround for
-                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
-// clang-format off
-SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
-// clang-format on
-#endif // end of workaround
-/* end file src/simdutf/haswell/begin.h */
-  // Declarations
-/* begin file src/simdutf/haswell/bitmanipulation.h */
-#ifndef SIMDUTF_HASWELL_BITMANIPULATION_H
-#define SIMDUTF_HASWELL_BITMANIPULATION_H
-
-namespace simdutf {
-namespace haswell {
-namespace {
-
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
-  // note: we do not support legacy 32-bit Windows
-  return __popcnt64(input_num); // Visual Studio wants two underscores
-}
-#else
-simdutf_really_inline long long int count_ones(uint64_t input_num) {
-  return _popcnt64(input_num);
-}
-#endif
-
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_inline int trailing_zeroes(uint64_t input_num) {
-  #if SIMDUTF_REGULAR_VISUAL_STUDIO
-  return (int)_tzcnt_u64(input_num);
-  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
-  return __builtin_ctzll(input_num);
-  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
-}
-#endif
-
-} // unnamed namespace
-} // namespace haswell
-} // namespace simdutf
-
-#endif // SIMDUTF_HASWELL_BITMANIPULATION_H
-/* end file src/simdutf/haswell/bitmanipulation.h */
-/* begin file src/simdutf/haswell/simd.h */
-#ifndef SIMDUTF_HASWELL_SIMD_H
-#define SIMDUTF_HASWELL_SIMD_H
-
-namespace simdutf {
-namespace haswell {
-namespace {
-namespace simd {
-
-// Forward-declared so they can be used by splat and friends.
-template <typename Child> struct base {
-  __m256i value;
-
-  // Zero constructor
-  simdutf_really_inline base() : value{__m256i()} {}
-
-  // Conversion from SIMD register
-  simdutf_really_inline base(const __m256i _value) : value(_value) {}
-  // Conversion to SIMD register
-  simdutf_really_inline operator const __m256i &() const { return this->value; }
-  simdutf_really_inline operator __m256i &() { return this->value; }
-  template <endianness big_endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    __m256i first = _mm256_cvtepu8_epi16(_mm256_castsi256_si128(*this));
-    __m256i second = _mm256_cvtepu8_epi16(_mm256_extractf128_si256(*this, 1));
-    if (big_endian) {
-      const __m256i swap = _mm256_setr_epi8(
-          1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
-          21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
-      first = _mm256_shuffle_epi8(first, swap);
-      second = _mm256_shuffle_epi8(second, swap);
-    }
-    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr), first);
-    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 16), second);
-  }
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr),
-                        _mm256_cvtepu8_epi32(_mm256_castsi256_si128(*this)));
-    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 8),
-                        _mm256_cvtepu8_epi32(_mm256_castsi256_si128(
-                            _mm256_srli_si256(*this, 8))));
-    _mm256_storeu_si256(
-        reinterpret_cast<__m256i *>(ptr + 16),
-        _mm256_cvtepu8_epi32(_mm256_extractf128_si256(*this, 1)));
-    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 24),
-                        _mm256_cvtepu8_epi32(_mm_srli_si128(
-                            _mm256_extractf128_si256(*this, 1), 8)));
-  }
-  // Bit operations
-  simdutf_really_inline Child operator|(const Child other) const {
-    return _mm256_or_si256(*this, other);
-  }
-  simdutf_really_inline Child operator&(const Child other) const {
-    return _mm256_and_si256(*this, other);
-  }
-  simdutf_really_inline Child operator^(const Child other) const {
-    return _mm256_xor_si256(*this, other);
-  }
-  simdutf_really_inline Child bit_andnot(const Child other) const {
-    return _mm256_andnot_si256(other, *this);
-  }
-  simdutf_really_inline Child &operator|=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator&=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator^=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-};
-
-// Forward-declared so they can be used by splat and friends.
-template <typename T> struct simd8;
-
-template <typename T, typename Mask = simd8<bool>>
-struct base8 : base<simd8<T>> {
-  typedef uint32_t bitmask_t;
-  typedef uint64_t bitmask2_t;
-
-  simdutf_really_inline base8() : base<simd8<T>>() {}
-  simdutf_really_inline base8(const __m256i _value) : base<simd8<T>>(_value) {}
-  simdutf_really_inline T first() const {
-    return _mm256_extract_epi8(*this, 0);
-  }
-  simdutf_really_inline T last() const {
-    return _mm256_extract_epi8(*this, 31);
-  }
-  friend simdutf_always_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return _mm256_cmpeq_epi8(lhs, rhs);
-  }
-
-  static const int SIZE = sizeof(base<T>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
-    return _mm256_alignr_epi8(
-        *this, _mm256_permute2x128_si256(prev_chunk, *this, 0x21), 16 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base8<bool> {
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return _mm256_set1_epi8(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8() : base8() {}
-  simdutf_really_inline simd8(const __m256i _value) : base8<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
-
-  simdutf_really_inline uint32_t to_bitmask() const {
-    return uint32_t(_mm256_movemask_epi8(*this));
-  }
-  simdutf_really_inline bool any() const {
-    return !_mm256_testz_si256(*this, *this);
-  }
-  simdutf_really_inline bool none() const {
-    return _mm256_testz_si256(*this, *this);
-  }
-  simdutf_really_inline bool all() const {
-    return static_cast<uint32_t>(_mm256_movemask_epi8(*this)) == 0xFFFFFFFF;
-  }
-  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base8_numeric : base8<T> {
-  static simdutf_really_inline simd8<T> splat(T _value) {
-    return _mm256_set1_epi8(_value);
-  }
-  static simdutf_really_inline simd8<T> zero() {
-    return _mm256_setzero_si256();
-  }
-  static simdutf_really_inline simd8<T> load(const T values[32]) {
-    return _mm256_loadu_si256(reinterpret_cast<const __m256i *>(values));
-  }
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
-                                                  T v5, T v6, T v7, T v8, T v9,
-                                                  T v10, T v11, T v12, T v13,
-                                                  T v14, T v15) {
-    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
-                    v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                    v12, v13, v14, v15);
-  }
-
-  simdutf_really_inline base8_numeric() : base8<T>() {}
-  simdutf_really_inline base8_numeric(const __m256i _value)
-      : base8<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[32]) const {
-    return _mm256_storeu_si256(reinterpret_cast<__m256i *>(dst), *this);
-  }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
-    return _mm256_add_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
-    return _mm256_sub_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
-    *this = *this + other;
-    return *static_cast<simd8<T> *>(this);
-  }
-  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
-    *this = *this - other;
-    return *static_cast<simd8<T> *>(this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return _mm256_shuffle_epi8(lookup_table, *this);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> : base8_numeric<int8_t> {
-  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
-  simdutf_really_inline simd8(const __m256i _value)
-      : base8_numeric<int8_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t values[32]) : simd8(load(values)) {}
-  simdutf_really_inline operator simd8<uint8_t>() const;
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
-        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
-        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
-        int8_t v30, int8_t v31)
-      : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                               v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
-                               v22, v23, v24, v25, v26, v27, v28, v29, v30,
-                               v31)) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                         v10, v11, v12, v13, v14, v15);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    return _mm256_movemask_epi8(*this) == 0;
-  }
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return _mm256_max_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return _mm256_min_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return _mm256_cmpgt_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return _mm256_cmpgt_epi8(other, *this);
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
-  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
-  simdutf_really_inline simd8(const __m256i _value)
-      : base8_numeric<uint8_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t values[32]) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
-        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
-        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
-        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
-        uint8_t v31)
-      : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                               v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
-                               v22, v23, v24, v25, v26, v27, v28, v29, v30,
-                               v31)) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                          v10, v11, v12, v13, v14, v15);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return _mm256_adds_epu8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return _mm256_subs_epu8(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return _mm256_max_epu8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return _mm256_min_epu8(other, *this);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return this->lt_bits(other).any_bits_set();
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> bits_not_set() const {
-    return *this == uint8_t(0);
-  }
-  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    return _mm256_movemask_epi8(*this) == 0;
-  }
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return _mm256_testz_si256(*this, *this);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
-    return _mm256_testz_si256(*this, bits);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return simd8<uint8_t>(_mm256_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return simd8<uint8_t>(_mm256_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
-  }
-  // Get one of the bits and make a bitmask out of it.
-  // e.g. value.get_bit<7>() gets the high bit
-  template <int N> simdutf_really_inline int get_bit() const {
-    return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 7 - N));
-  }
-};
-simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
-  return this->value;
-}
-
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(NUM_CHUNKS == 2,
-                "Haswell kernel should use two registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
-      : chunks{chunk0, chunk1} {}
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r_hi = this->chunks[1].to_bitmask();
-    return r_lo | (r_hi << 32);
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return this->chunks[0] | this->chunks[1];
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  template <endianness endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 0);
-    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 1);
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
-    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
-  }
-
-  simdutf_really_inline simd8x64<T> bit_or(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
-    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
-                          this->chunks[1] == other.chunks[1])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-    return simd8x64<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
-                          (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-
-/* begin file src/simdutf/haswell/simd16-inl.h */
-#ifdef __GNUC__
-  #if __GNUC__ < 8
-    #define _mm256_set_m128i(xmm1, xmm2)                                       \
-      _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1),                  \
-                                _mm256_castsi128_si256(xmm2), 2)
-    #define _mm256_setr_m128i(xmm2, xmm1)                                      \
-      _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1),                  \
-                                _mm256_castsi128_si256(xmm2), 2)
-  #endif
-#endif
-
-template <typename T> struct simd16;
-
-template <typename T, typename Mask = simd16<bool>>
-struct base16 : base<simd16<T>> {
-  using bitmask_type = uint32_t;
-
-  simdutf_really_inline base16() : base<simd16<T>>() {}
-  simdutf_really_inline base16(const __m256i _value)
-      : base<simd16<T>>(_value) {}
-  template <typename Pointer>
-  simdutf_really_inline base16(const Pointer *ptr)
-      : base16(_mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr))) {}
-  friend simdutf_always_inline Mask operator==(const simd16<T> lhs,
-                                               const simd16<T> rhs) {
-    return _mm256_cmpeq_epi16(lhs, rhs);
-  }
-
-  /// the size of vector in bytes
-  static const int SIZE = sizeof(base<simd16<T>>::value);
-
-  /// the number of elements of type T a vector can hold
-  static const int ELEMENTS = SIZE / sizeof(T);
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return _mm256_alignr_epi8(*this, prev_chunk, 16 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd16<bool> : base16<bool> {
-  static simdutf_really_inline simd16<bool> splat(bool _value) {
-    return _mm256_set1_epi16(uint16_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd16() : base16() {}
-  simdutf_really_inline simd16(const __m256i _value) : base16<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
-
-  simdutf_really_inline bitmask_type to_bitmask() const {
-    return _mm256_movemask_epi8(*this);
-  }
-  simdutf_really_inline bool any() const {
-    return !_mm256_testz_si256(*this, *this);
-  }
-  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base16_numeric : base16<T> {
-  static simdutf_really_inline simd16<T> splat(T _value) {
-    return _mm256_set1_epi16(_value);
-  }
-  static simdutf_really_inline simd16<T> zero() {
-    return _mm256_setzero_si256();
-  }
-  static simdutf_really_inline simd16<T> load(const T values[8]) {
-    return _mm256_loadu_si256(reinterpret_cast<const __m256i *>(values));
-  }
-
-  simdutf_really_inline base16_numeric() : base16<T>() {}
-  simdutf_really_inline base16_numeric(const __m256i _value)
-      : base16<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[8]) const {
-    return _mm256_storeu_si256(reinterpret_cast<__m256i *>(dst), *this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
-    return _mm256_add_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
-    return _mm256_sub_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
-    *this = *this + other;
-    return *static_cast<simd16<T> *>(this);
-  }
-  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
-    *this = *this - other;
-    return *static_cast<simd16<T> *>(this);
-  }
-};
-
-// Signed code units
-template <> struct simd16<int16_t> : base16_numeric<int16_t> {
-  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
-  simdutf_really_inline simd16(const __m256i _value)
-      : base16_numeric<int16_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
-  // Order-sensitive comparisons
-  simdutf_really_inline simd16<int16_t>
-  max_val(const simd16<int16_t> other) const {
-    return _mm256_max_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<int16_t>
-  min_val(const simd16<int16_t> other) const {
-    return _mm256_min_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<int16_t> other) const {
-    return _mm256_cmpgt_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<int16_t> other) const {
-    return _mm256_cmpgt_epi16(other, *this);
-  }
-};
-
-// Unsigned code units
-template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
-  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
-  simdutf_really_inline simd16(const __m256i _value)
-      : base16_numeric<uint16_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
-
-  // Saturated math
-  simdutf_really_inline simd16<uint16_t>
-  saturating_add(const simd16<uint16_t> other) const {
-    return _mm256_adds_epu16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  saturating_sub(const simd16<uint16_t> other) const {
-    return _mm256_subs_epu16(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd16<uint16_t>
-  max_val(const simd16<uint16_t> other) const {
-    return _mm256_max_epu16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  min_val(const simd16<uint16_t> other) const {
-    return _mm256_min_epu16(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  gt_bits(const simd16<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  lt_bits(const simd16<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<=(const simd16<uint16_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd16<bool>
-  operator>=(const simd16<uint16_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<uint16_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<uint16_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd16<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return _mm256_testz_si256(*this, *this);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool
-  bits_not_set_anywhere(simd16<uint16_t> bits) const {
-    return _mm256_testz_si256(*this, bits);
-  }
-  simdutf_really_inline bool
-  any_bits_set_anywhere(simd16<uint16_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
-    return simd16<uint16_t>(_mm256_srli_epi16(*this, N));
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
-    return simd16<uint16_t>(_mm256_slli_epi16(*this, N));
-  }
-  // Get one of the bits and make a bitmask out of it.
-  // e.g. value.get_bit<7>() gets the high bit
-  template <int N> simdutf_really_inline int get_bit() const {
-    return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 15 - N));
-  }
-
-  // Change the endianness
-  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
-    const __m256i swap = _mm256_setr_epi8(
-        1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
-        21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
-    return _mm256_shuffle_epi8(*this, swap);
-  }
-
-  // Pack with the unsigned saturation of two uint16_t code units into single
-  // uint8_t vector
-  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
-                                                   const simd16<uint16_t> &v1) {
-    // Note: the AVX2 variant of pack operates on 128-bit lanes, thus
-    //       we have to shuffle lanes in order to produce bytes in the
-    //       correct order.
-
-    // get the 0th lanes
-    const __m128i lo_0 = _mm256_extracti128_si256(v0, 0);
-    const __m128i lo_1 = _mm256_extracti128_si256(v1, 0);
-
-    // get the 1st lanes
-    const __m128i hi_0 = _mm256_extracti128_si256(v0, 1);
-    const __m128i hi_1 = _mm256_extracti128_si256(v1, 1);
-
-    // build new vectors (shuffle lanes)
-    const __m256i t0 = _mm256_set_m128i(lo_1, lo_0);
-    const __m256i t1 = _mm256_set_m128i(hi_1, hi_0);
-
-    // pack code units in linear order from v0 and v1
-    return _mm256_packus_epi16(t0, t1);
-  }
-};
-
-template <typename T> struct simd16x32 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
-  static_assert(NUM_CHUNKS == 2,
-                "Haswell kernel should use two registers per 64-byte block.");
-  simd16<T> chunks[NUM_CHUNKS];
-
-  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
-  simd16x32<T> &
-  operator=(const simd16<T> other) = delete; // no assignment allowed
-  simd16x32() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd16x32(const simd16<T> chunk0,
-                                  const simd16<T> chunk1)
-      : chunks{chunk0, chunk1} {}
-  simdutf_really_inline simd16x32(const T *ptr)
-      : chunks{simd16<T>::load(ptr),
-               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r_hi = this->chunks[1].to_bitmask();
-    return r_lo | (r_hi << 32);
-  }
-
-  simdutf_really_inline simd16<T> reduce_or() const {
-    return this->chunks[0] | this->chunks[1];
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
-    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
-  }
-
-  simdutf_really_inline simd16x32<T> bit_or(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
-  }
-
-  simdutf_really_inline void swap_bytes() {
-    this->chunks[0] = this->chunks[0].swap_bytes();
-    this->chunks[1] = this->chunks[1].swap_bytes();
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
-    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
-                           this->chunks[1] == other.chunks[1])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-
-    return simd16x32<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
-    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
-    return simd16x32<bool>(
-               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
-               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
-        .to_bitmask();
-  }
-}; // struct simd16x32<T>
-/* end file src/simdutf/haswell/simd16-inl.h */
-
-} // namespace simd
-
-} // unnamed namespace
-} // namespace haswell
-} // namespace simdutf
-
-#endif // SIMDUTF_HASWELL_SIMD_H
-/* end file src/simdutf/haswell/simd.h */
-
-/* begin file src/simdutf/haswell/end.h */
-#if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
-// nothing needed.
-#else
-SIMDUTF_UNTARGET_REGION
-#endif
-
-
-#if SIMDUTF_GCC11ORMORE // workaround for
-                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
-SIMDUTF_POP_DISABLE_WARNINGS
-#endif // end of workaround
-/* end file src/simdutf/haswell/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_HASWELL
-#endif // SIMDUTF_HASWELL_COMMON_H
-/* end file src/simdutf/haswell.h */
-/* begin file src/simdutf/westmere.h */
-#ifndef SIMDUTF_WESTMERE_H
-#define SIMDUTF_WESTMERE_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "westmere.h must be included before fallback.h"
-#endif
-
-
-// Default Westmere to on if this is x86-64, unless we'll always select Haswell.
-#ifndef SIMDUTF_IMPLEMENTATION_WESTMERE
-  //
-  // You do not want to set it to (SIMDUTF_IS_X86_64 &&
-  // !SIMDUTF_REQUIRES_HASWELL) because you want to rely on runtime dispatch!
-  //
-  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE || SIMDUTF_CAN_ALWAYS_RUN_HASWELL
-    #define SIMDUTF_IMPLEMENTATION_WESTMERE 0
-  #else
-    #define SIMDUTF_IMPLEMENTATION_WESTMERE (SIMDUTF_IS_X86_64)
-  #endif
-
-#endif
-
-#if (SIMDUTF_IMPLEMENTATION_WESTMERE && SIMDUTF_IS_X86_64 && __SSE4_2__)
-  #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 1
-#else
-  #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 0
-#endif
-
-#if SIMDUTF_IMPLEMENTATION_WESTMERE
-
-  #define SIMDUTF_TARGET_WESTMERE SIMDUTF_TARGET_REGION("sse4.2,popcnt")
-
-namespace simdutf {
-/**
- * Implementation for Westmere (Intel SSE4.2).
- */
-namespace westmere {} // namespace westmere
-} // namespace simdutf
-
-  //
-  // These two need to be included outside SIMDUTF_TARGET_REGION
-  //
-/* begin file src/simdutf/westmere/implementation.h */
-#ifndef SIMDUTF_WESTMERE_IMPLEMENTATION_H
-#define SIMDUTF_WESTMERE_IMPLEMENTATION_H
-
-
-// The constructor may be executed on any host, so we take care not to use
-// SIMDUTF_TARGET_REGION
-namespace simdutf {
-namespace westmere {
-
-namespace {
-using namespace simdutf;
-}
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("westmere", "Intel/AMD SSE4.2",
-                                internal::instruction_set::SSE42) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-
-} // namespace westmere
-} // namespace simdutf
-
-#endif // SIMDUTF_WESTMERE_IMPLEMENTATION_H
-/* end file src/simdutf/westmere/implementation.h */
-/* begin file src/simdutf/westmere/intrinsics.h */
-#ifndef SIMDUTF_WESTMERE_INTRINSICS_H
-#define SIMDUTF_WESTMERE_INTRINSICS_H
-
-#ifdef SIMDUTF_VISUAL_STUDIO
-  // under clang within visual studio, this will include <x86intrin.h>
-  #include <intrin.h> // visual studio or clang
-#else
-
-  #if SIMDUTF_GCC11ORMORE
-// We should not get warnings while including <x86intrin.h> yet we do
-// under some versions of GCC.
-// If the x86intrin.h header has uninitialized values that are problematic,
-// it is a GCC issue, we want to ignore these warnings.
-SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
-  #endif
-
-  #include <x86intrin.h> // elsewhere
-
-  #if SIMDUTF_GCC11ORMORE
-// cancels the suppression of the -Wuninitialized
-SIMDUTF_POP_DISABLE_WARNINGS
-  #endif
-
-#endif // SIMDUTF_VISUAL_STUDIO
-
-#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
-  /**
-   * You are not supposed, normally, to include these
-   * headers directly. Instead you should either include intrin.h
-   * or x86intrin.h. However, when compiling with clang
-   * under Windows (i.e., when _MSC_VER is set), these headers
-   * only get included *if* the corresponding features are detected
-   * from macros:
-   */
-  #include <smmintrin.h> // for _mm_alignr_epi8
-#endif
-
-#endif // SIMDUTF_WESTMERE_INTRINSICS_H
-/* end file src/simdutf/westmere/intrinsics.h */
-
-  //
-  // The rest need to be inside the region
-  //
-/* begin file src/simdutf/westmere/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "westmere"
-// #define SIMDUTF_IMPLEMENTATION westmere
-
-#if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
-// nothing needed.
-#else
-SIMDUTF_TARGET_WESTMERE
-#endif
-/* end file src/simdutf/westmere/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/westmere/bitmanipulation.h */
-#ifndef SIMDUTF_WESTMERE_BITMANIPULATION_H
-#define SIMDUTF_WESTMERE_BITMANIPULATION_H
-
-namespace simdutf {
-namespace westmere {
-namespace {
-
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
-  // note: we do not support legacy 32-bit Windows
-  return __popcnt64(input_num); // Visual Studio wants two underscores
-}
-#else
-simdutf_really_inline long long int count_ones(uint64_t input_num) {
-  return _popcnt64(input_num);
-}
-#endif
-
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
-  #if SIMDUTF_REGULAR_VISUAL_STUDIO
-  unsigned long ret;
-  _BitScanForward64(&ret, input_num);
-  return (int)ret;
-  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
-  return __builtin_ctzll(input_num);
-  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
-}
-#endif
-
-} // unnamed namespace
-} // namespace westmere
-} // namespace simdutf
-
-#endif // SIMDUTF_WESTMERE_BITMANIPULATION_H
-/* end file src/simdutf/westmere/bitmanipulation.h */
-/* begin file src/simdutf/westmere/simd.h */
-#ifndef SIMDUTF_WESTMERE_SIMD_H
-#define SIMDUTF_WESTMERE_SIMD_H
-
-namespace simdutf {
-namespace westmere {
-namespace {
-namespace simd {
-
-template <typename Child> struct base {
-  __m128i value;
-
-  // Zero constructor
-  simdutf_really_inline base() : value{__m128i()} {}
-
-  // Conversion from SIMD register
-  simdutf_really_inline base(const __m128i _value) : value(_value) {}
-  // Conversion to SIMD register
-  simdutf_really_inline operator const __m128i &() const { return this->value; }
-  simdutf_really_inline operator __m128i &() { return this->value; }
-  template <endianness big_endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
-    __m128i first = _mm_cvtepu8_epi16(*this);
-    __m128i second = _mm_cvtepu8_epi16(_mm_srli_si128(*this, 8));
-    if (big_endian) {
-      const __m128i swap =
-          _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
-      first = _mm_shuffle_epi8(first, swap);
-      second = _mm_shuffle_epi8(second, swap);
-    }
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p), first);
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 8), second);
-  }
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p), _mm_cvtepu8_epi32(*this));
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 4),
-                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 4)));
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 8),
-                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 8)));
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 12),
-                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 12)));
-  }
-  // Bit operations
-  simdutf_really_inline Child operator|(const Child other) const {
-    return _mm_or_si128(*this, other);
-  }
-  simdutf_really_inline Child operator&(const Child other) const {
-    return _mm_and_si128(*this, other);
-  }
-  simdutf_really_inline Child operator^(const Child other) const {
-    return _mm_xor_si128(*this, other);
-  }
-  simdutf_really_inline Child bit_andnot(const Child other) const {
-    return _mm_andnot_si128(other, *this);
-  }
-  simdutf_really_inline Child &operator|=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator&=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator^=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-};
-
-// Forward-declared so they can be used by splat and friends.
-template <typename T> struct simd8;
-
-template <typename T, typename Mask = simd8<bool>>
-struct base8 : base<simd8<T>> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  simdutf_really_inline T first() const { return _mm_extract_epi8(*this, 0); }
-  simdutf_really_inline T last() const { return _mm_extract_epi8(*this, 15); }
-  simdutf_really_inline base8() : base<simd8<T>>() {}
-  simdutf_really_inline base8(const __m128i _value) : base<simd8<T>>(_value) {}
-
-  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return _mm_cmpeq_epi8(lhs, rhs);
-  }
-
-  static const int SIZE = sizeof(base<simd8<T>>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
-    return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base8<bool> {
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return _mm_set1_epi8(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8() : base8() {}
-  simdutf_really_inline simd8(const __m128i _value) : base8<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
-
-  simdutf_really_inline int to_bitmask() const {
-    return _mm_movemask_epi8(*this);
-  }
-  simdutf_really_inline bool any() const {
-    return !_mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline bool none() const {
-    return _mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline bool all() const {
-    return _mm_movemask_epi8(*this) == 0xFFFF;
-  }
-  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base8_numeric : base8<T> {
-  static simdutf_really_inline simd8<T> splat(T _value) {
-    return _mm_set1_epi8(_value);
-  }
-  static simdutf_really_inline simd8<T> zero() { return _mm_setzero_si128(); }
-  static simdutf_really_inline simd8<T> load(const T values[16]) {
-    return _mm_loadu_si128(reinterpret_cast<const __m128i *>(values));
-  }
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
-                                                  T v5, T v6, T v7, T v8, T v9,
-                                                  T v10, T v11, T v12, T v13,
-                                                  T v14, T v15) {
-    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
-                    v14, v15);
-  }
-
-  simdutf_really_inline base8_numeric() : base8<T>() {}
-  simdutf_really_inline base8_numeric(const __m128i _value)
-      : base8<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[16]) const {
-    return _mm_storeu_si128(reinterpret_cast<__m128i *>(dst), *this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
-    return _mm_add_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
-    return _mm_sub_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
-    *this = *this + other;
-    return *static_cast<simd8<T> *>(this);
-  }
-  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
-    *this = *this - other;
-    return *static_cast<simd8<T> *>(this);
-  }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return _mm_shuffle_epi8(lookup_table, *this);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> : base8_numeric<int8_t> {
-  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
-  simdutf_really_inline simd8(const __m128i _value)
-      : base8_numeric<int8_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
-                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
-                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
-      : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                            v12, v13, v14, v15)) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15);
-  }
-  simdutf_really_inline operator simd8<uint8_t>() const;
-  simdutf_really_inline bool is_ascii() const {
-    return _mm_movemask_epi8(*this) == 0;
-  }
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return _mm_max_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return _mm_min_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return _mm_cmpgt_epi8(*this, other);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return _mm_cmpgt_epi8(other, *this);
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
-  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
-  simdutf_really_inline simd8(const __m128i _value)
-      : base8_numeric<uint8_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
-      : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                            v12, v13, v14, v15)) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return _mm_adds_epu8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return _mm_subs_epu8(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return _mm_max_epu8(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return _mm_min_epu8(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> bits_not_set() const {
-    return *this == uint8_t(0);
-  }
-  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    return _mm_movemask_epi8(*this) == 0;
-  }
-
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return _mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
-    return _mm_testz_si128(*this, bits);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return simd8<uint8_t>(_mm_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return simd8<uint8_t>(_mm_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
-  }
-  // Get one of the bits and make a bitmask out of it.
-  // e.g. value.get_bit<7>() gets the high bit
-  template <int N> simdutf_really_inline int get_bit() const {
-    return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
-  }
-};
-simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
-  return this->value;
-}
-
-// Unsigned bytes
-template <> struct simd8<uint16_t> : base<uint16_t> {
-  static simdutf_really_inline simd8<uint16_t> splat(uint16_t _value) {
-    return _mm_set1_epi16(_value);
-  }
-  static simdutf_really_inline simd8<uint16_t> load(const uint16_t values[8]) {
-    return _mm_loadu_si128(reinterpret_cast<const __m128i *>(values));
-  }
-
-  simdutf_really_inline simd8() : base<uint16_t>() {}
-  simdutf_really_inline simd8(const __m128i _value) : base<uint16_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint16_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint16_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline simd8(uint16_t v0, uint16_t v1, uint16_t v2,
-                              uint16_t v3, uint16_t v4, uint16_t v5,
-                              uint16_t v6, uint16_t v7)
-      : simd8(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7)) {}
-
-  // Saturated math
-  simdutf_really_inline simd8<uint16_t>
-  saturating_add(const simd8<uint16_t> other) const {
-    return _mm_adds_epu16(*this, other);
-  }
-  simdutf_really_inline simd8<uint16_t>
-  saturating_sub(const simd8<uint16_t> other) const {
-    return _mm_subs_epu16(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint16_t>
-  max_val(const simd8<uint16_t> other) const {
-    return _mm_max_epu16(*this, other);
-  }
-  simdutf_really_inline simd8<uint16_t>
-  min_val(const simd8<uint16_t> other) const {
-    return _mm_min_epu16(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint16_t>
-  gt_bits(const simd8<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint16_t>
-  lt_bits(const simd8<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint16_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint16_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator==(const simd8<uint16_t> other) const {
-    return _mm_cmpeq_epi16(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator&(const simd8<uint16_t> other) const {
-    return _mm_and_si128(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator|(const simd8<uint16_t> other) const {
-    return _mm_or_si128(*this, other);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  simdutf_really_inline simd8<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return _mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint16_t> bits) const {
-    return _mm_testz_si128(*this, bits);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint16_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-};
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(NUM_CHUNKS == 4,
-                "Westmere kernel should use four registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
-                                 const simd8<T> chunk2, const simd8<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    this->chunks[2] |= other.chunks[2];
-    this->chunks[3] |= other.chunks[3];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  template <endianness endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 0);
-    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 1);
-    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 2);
-    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
-    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
-    this->chunks[2].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 2);
-    this->chunks[3].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r1 = this->chunks[1].to_bitmask();
-    uint64_t r2 = this->chunks[2].to_bitmask();
-    uint64_t r3 = this->chunks[3].to_bitmask();
-    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                          this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
-    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
-                          this->chunks[1] == other.chunks[1],
-                          this->chunks[2] == other.chunks[2],
-                          this->chunks[3] == other.chunks[3])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                          this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low - 1);
-    const simd8<T> mask_high = simd8<T>::splat(high + 1);
-    return simd8x64<bool>(
-               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
-               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
-               (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
-               (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                          this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
-                          this->chunks[2] > mask, this->chunks[3] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
-                          this->chunks[2] >= mask, this->chunks[3] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>(simd8<uint8_t>(__m128i(this->chunks[0])) >= mask,
-                          simd8<uint8_t>(__m128i(this->chunks[1])) >= mask,
-                          simd8<uint8_t>(__m128i(this->chunks[2])) >= mask,
-                          simd8<uint8_t>(__m128i(this->chunks[3])) >= mask)
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-
-/* begin file src/simdutf/westmere/simd16-inl.h */
-template <typename T> struct simd16;
-
-template <typename T, typename Mask = simd16<bool>>
-struct base16 : base<simd16<T>> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  simdutf_really_inline base16() : base<simd16<T>>() {}
-  simdutf_really_inline base16(const __m128i _value)
-      : base<simd16<T>>(_value) {}
-  template <typename Pointer>
-  simdutf_really_inline base16(const Pointer *ptr)
-      : base16(_mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr))) {}
-
-  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
-                                               const simd16<T> rhs) {
-    return _mm_cmpeq_epi16(lhs, rhs);
-  }
-
-  static const int SIZE = sizeof(base<simd16<T>>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd16<bool> : base16<bool> {
-  static simdutf_really_inline simd16<bool> splat(bool _value) {
-    return _mm_set1_epi16(uint16_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd16() : base16() {}
-  simdutf_really_inline simd16(const __m128i _value) : base16<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
-
-  simdutf_really_inline int to_bitmask() const {
-    return _mm_movemask_epi8(*this);
-  }
-  simdutf_really_inline bool any() const {
-    return !_mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base16_numeric : base16<T> {
-  static simdutf_really_inline simd16<T> splat(T _value) {
-    return _mm_set1_epi16(_value);
-  }
-  static simdutf_really_inline simd16<T> zero() { return _mm_setzero_si128(); }
-  static simdutf_really_inline simd16<T> load(const T values[8]) {
-    return _mm_loadu_si128(reinterpret_cast<const __m128i *>(values));
-  }
-
-  simdutf_really_inline base16_numeric() : base16<T>() {}
-  simdutf_really_inline base16_numeric(const __m128i _value)
-      : base16<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[8]) const {
-    return _mm_storeu_si128(reinterpret_cast<__m128i *>(dst), *this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
-    return _mm_add_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
-    return _mm_sub_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
-    *this = *this + other;
-    return *static_cast<simd16<T> *>(this);
-  }
-  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
-    *this = *this - other;
-    return *static_cast<simd16<T> *>(this);
-  }
-};
-
-// Signed code units
-template <> struct simd16<int16_t> : base16_numeric<int16_t> {
-  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
-  simdutf_really_inline simd16(const __m128i _value)
-      : base16_numeric<int16_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
-  // Member-by-member initialization
-  simdutf_really_inline simd16(int16_t v0, int16_t v1, int16_t v2, int16_t v3,
-                               int16_t v4, int16_t v5, int16_t v6, int16_t v7)
-      : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7)) {}
-  simdutf_really_inline operator simd16<uint16_t>() const;
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd16<int16_t>
-  max_val(const simd16<int16_t> other) const {
-    return _mm_max_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<int16_t>
-  min_val(const simd16<int16_t> other) const {
-    return _mm_min_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<int16_t> other) const {
-    return _mm_cmpgt_epi16(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<int16_t> other) const {
-    return _mm_cmpgt_epi16(other, *this);
-  }
-};
-
-// Unsigned code units
-template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
-  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
-  simdutf_really_inline simd16(const __m128i _value)
-      : base16_numeric<uint16_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
-  // Member-by-member initialization
-  simdutf_really_inline simd16(uint16_t v0, uint16_t v1, uint16_t v2,
-                               uint16_t v3, uint16_t v4, uint16_t v5,
-                               uint16_t v6, uint16_t v7)
-      : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7)) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd16<uint16_t>
-  repeat_16(uint16_t v0, uint16_t v1, uint16_t v2, uint16_t v3, uint16_t v4,
-            uint16_t v5, uint16_t v6, uint16_t v7) {
-    return simd16<uint16_t>(v0, v1, v2, v3, v4, v5, v6, v7);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd16<uint16_t>
-  saturating_add(const simd16<uint16_t> other) const {
-    return _mm_adds_epu16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  saturating_sub(const simd16<uint16_t> other) const {
-    return _mm_subs_epu16(*this, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd16<uint16_t>
-  max_val(const simd16<uint16_t> other) const {
-    return _mm_max_epu16(*this, other);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  min_val(const simd16<uint16_t> other) const {
-    return _mm_min_epu16(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  gt_bits(const simd16<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  lt_bits(const simd16<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<=(const simd16<uint16_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd16<bool>
-  operator>=(const simd16<uint16_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<uint16_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<uint16_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd16<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return _mm_testz_si128(*this, *this);
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool
-  bits_not_set_anywhere(simd16<uint16_t> bits) const {
-    return _mm_testz_si128(*this, bits);
-  }
-  simdutf_really_inline bool
-  any_bits_set_anywhere(simd16<uint16_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
-    return simd16<uint16_t>(_mm_srli_epi16(*this, N));
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
-    return simd16<uint16_t>(_mm_slli_epi16(*this, N));
-  }
-  // Get one of the bits and make a bitmask out of it.
-  // e.g. value.get_bit<7>() gets the high bit
-  template <int N> simdutf_really_inline int get_bit() const {
-    return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
-  }
-
-  // Change the endianness
-  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
-    const __m128i swap =
-        _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
-    return _mm_shuffle_epi8(*this, swap);
-  }
-
-  // Pack with the unsigned saturation of two uint16_t code units into single
-  // uint8_t vector
-  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
-                                                   const simd16<uint16_t> &v1) {
-    return _mm_packus_epi16(v0, v1);
-  }
-};
-simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
-  return this->value;
-}
-
-template <typename T> struct simd16x32 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
-  static_assert(NUM_CHUNKS == 4,
-                "Westmere kernel should use four registers per 64-byte block.");
-  simd16<T> chunks[NUM_CHUNKS];
-
-  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
-  simd16x32<T> &
-  operator=(const simd16<T> other) = delete; // no assignment allowed
-  simd16x32() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline
-  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
-            const simd16<T> chunk2, const simd16<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd16x32(const T *ptr)
-      : chunks{simd16<T>::load(ptr),
-               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd16<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
-    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
-    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
-    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r1 = this->chunks[1].to_bitmask();
-    uint64_t r2 = this->chunks[2].to_bitmask();
-    uint64_t r3 = this->chunks[3].to_bitmask();
-    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
-  }
-
-  simdutf_really_inline void swap_bytes() {
-    this->chunks[0] = this->chunks[0].swap_bytes();
-    this->chunks[1] = this->chunks[1].swap_bytes();
-    this->chunks[2] = this->chunks[2].swap_bytes();
-    this->chunks[3] = this->chunks[3].swap_bytes();
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                           this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
-    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
-                           this->chunks[1] == other.chunks[1],
-                           this->chunks[2] == other.chunks[2],
-                           this->chunks[3] == other.chunks[3])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                           this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-
-    return simd16x32<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
-    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
-    return simd16x32<bool>(
-               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
-               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
-               (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
-               (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                           this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-}; // struct simd16x32<T>
-/* end file src/simdutf/westmere/simd16-inl.h */
-
-} // namespace simd
-} // unnamed namespace
-} // namespace westmere
-} // namespace simdutf
-
-#endif // SIMDUTF_WESTMERE_SIMD_INPUT_H
-/* end file src/simdutf/westmere/simd.h */
-
-/* begin file src/simdutf/westmere/end.h */
-#if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
-// nothing needed.
-#else
-SIMDUTF_UNTARGET_REGION
-#endif
-
-/* end file src/simdutf/westmere/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_WESTMERE
-#endif // SIMDUTF_WESTMERE_COMMON_H
-/* end file src/simdutf/westmere.h */
-/* begin file src/simdutf/ppc64.h */
-#ifndef SIMDUTF_PPC64_H
-#define SIMDUTF_PPC64_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "ppc64.h must be included before fallback.h"
-#endif
-
-
-#ifndef SIMDUTF_IMPLEMENTATION_PPC64
-  #define SIMDUTF_IMPLEMENTATION_PPC64 (SIMDUTF_IS_PPC64)
-#endif
-#define SIMDUTF_CAN_ALWAYS_RUN_PPC64                                           \
-  SIMDUTF_IMPLEMENTATION_PPC64 &&SIMDUTF_IS_PPC64
-
-
-#if SIMDUTF_IMPLEMENTATION_PPC64
-
-namespace simdutf {
-/**
- * Implementation for ALTIVEC (PPC64).
- */
-namespace ppc64 {} // namespace ppc64
-} // namespace simdutf
-
-/* begin file src/simdutf/ppc64/implementation.h */
-#ifndef SIMDUTF_PPC64_IMPLEMENTATION_H
-#define SIMDUTF_PPC64_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace ppc64 {
-
-namespace {
-using namespace simdutf;
-} // namespace
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("ppc64", "PPC64 ALTIVEC",
-                                internal::instruction_set::ALTIVEC) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-
-} // namespace ppc64
-} // namespace simdutf
-
-#endif // SIMDUTF_PPC64_IMPLEMENTATION_H
-/* end file src/simdutf/ppc64/implementation.h */
-
-/* begin file src/simdutf/ppc64/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "ppc64"
-// #define SIMDUTF_IMPLEMENTATION ppc64
-/* end file src/simdutf/ppc64/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/ppc64/intrinsics.h */
-#ifndef SIMDUTF_PPC64_INTRINSICS_H
-#define SIMDUTF_PPC64_INTRINSICS_H
-
-
-// This should be the correct header whether
-// you use visual studio or other compilers.
-#include <altivec.h>
-
-// These are defined by altivec.h in GCC toolchain, it is safe to undef them.
-#ifdef bool
-  #undef bool
-#endif
-
-#ifdef vector
-  #undef vector
-#endif
-
-#endif //  SIMDUTF_PPC64_INTRINSICS_H
-/* end file src/simdutf/ppc64/intrinsics.h */
-/* begin file src/simdutf/ppc64/bitmanipulation.h */
-#ifndef SIMDUTF_PPC64_BITMANIPULATION_H
-#define SIMDUTF_PPC64_BITMANIPULATION_H
-
-namespace simdutf {
-namespace ppc64 {
-namespace {
-
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
-simdutf_really_inline int count_ones(uint64_t input_num) {
-  // note: we do not support legacy 32-bit Windows
-  return __popcnt64(input_num); // Visual Studio wants two underscores
-}
-#else
-simdutf_really_inline int count_ones(uint64_t input_num) {
-  return __builtin_popcountll(input_num);
-}
-#endif
-
-} // unnamed namespace
-} // namespace ppc64
-} // namespace simdutf
-
-#endif // SIMDUTF_PPC64_BITMANIPULATION_H
-/* end file src/simdutf/ppc64/bitmanipulation.h */
-/* begin file src/simdutf/ppc64/simd.h */
-#ifndef SIMDUTF_PPC64_SIMD_H
-#define SIMDUTF_PPC64_SIMD_H
-
-#include <type_traits>
-
-namespace simdutf {
-namespace ppc64 {
-namespace {
-namespace simd {
-
-using __m128i = __vector unsigned char;
-
-template <typename Child> struct base {
-  __m128i value;
-
-  // Zero constructor
-  simdutf_really_inline base() : value{__m128i()} {}
-
-  // Conversion from SIMD register
-  simdutf_really_inline base(const __m128i _value) : value(_value) {}
-
-  // Conversion to SIMD register
-  simdutf_really_inline operator const __m128i &() const { return this->value; }
-  simdutf_really_inline operator __m128i &() { return this->value; }
-
-  // Bit operations
-  simdutf_really_inline Child operator|(const Child other) const {
-    return vec_or(this->value, (__m128i)other);
-  }
-  simdutf_really_inline Child operator&(const Child other) const {
-    return vec_and(this->value, (__m128i)other);
-  }
-  simdutf_really_inline Child operator^(const Child other) const {
-    return vec_xor(this->value, (__m128i)other);
-  }
-  simdutf_really_inline Child bit_andnot(const Child other) const {
-    return vec_andc(this->value, (__m128i)other);
-  }
-  simdutf_really_inline Child &operator|=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator&=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator^=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-};
-
-// Forward-declared so they can be used by splat and friends.
-template <typename T> struct simd8;
-
-template <typename T, typename Mask = simd8<bool>>
-struct base8 : base<simd8<T>> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  simdutf_really_inline base8() : base<simd8<T>>() {}
-  simdutf_really_inline base8(const __m128i _value) : base<simd8<T>>(_value) {}
-
-  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return (__m128i)vec_cmpeq(lhs.value, (__m128i)rhs);
-  }
-
-  static const int SIZE = sizeof(base<simd8<T>>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(simd8<T> prev_chunk) const {
-    __m128i chunk = this->value;
-#ifdef __LITTLE_ENDIAN__
-    chunk = (__m128i)vec_reve(this->value);
-    prev_chunk = (__m128i)vec_reve((__m128i)prev_chunk);
-#endif
-    chunk = (__m128i)vec_sld((__m128i)prev_chunk, (__m128i)chunk, 16 - N);
-#ifdef __LITTLE_ENDIAN__
-    chunk = (__m128i)vec_reve((__m128i)chunk);
-#endif
-    return chunk;
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base8<bool> {
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return (__m128i)vec_splats((unsigned char)(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8() : base8() {}
-  simdutf_really_inline simd8(const __m128i _value) : base8<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
-
-  simdutf_really_inline int to_bitmask() const {
-    __vector unsigned long long result;
-    const __m128i perm_mask = {0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
-                               0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00};
-
-    result = ((__vector unsigned long long)vec_vbpermq((__m128i)this->value,
-                                                       (__m128i)perm_mask));
-#ifdef __LITTLE_ENDIAN__
-    return static_cast<int>(result[1]);
-#else
-    return static_cast<int>(result[0]);
-#endif
-  }
-  simdutf_really_inline bool any() const {
-    return !vec_all_eq(this->value, (__m128i)vec_splats(0));
-  }
-  simdutf_really_inline simd8<bool> operator~() const {
-    return this->value ^ (__m128i)splat(true);
-  }
-};
-
-template <typename T> struct base8_numeric : base8<T> {
-  static simdutf_really_inline simd8<T> splat(T value) {
-    (void)value;
-    return (__m128i)vec_splats(value);
-  }
-  static simdutf_really_inline simd8<T> zero() { return splat(0); }
-  static simdutf_really_inline simd8<T> load(const T values[16]) {
-    return (__m128i)(vec_vsx_ld(0, reinterpret_cast<const uint8_t *>(values)));
-  }
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
-                                                  T v5, T v6, T v7, T v8, T v9,
-                                                  T v10, T v11, T v12, T v13,
-                                                  T v14, T v15) {
-    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
-                    v14, v15);
-  }
-
-  simdutf_really_inline base8_numeric() : base8<T>() {}
-  simdutf_really_inline base8_numeric(const __m128i _value)
-      : base8<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[16]) const {
-    vec_vsx_st(this->value, 0, reinterpret_cast<__m128i *>(dst));
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
-    return (__m128i)((__m128i)this->value + (__m128i)other);
-  }
-  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
-    return (__m128i)((__m128i)this->value - (__m128i)other);
-  }
-  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
-    *this = *this + other;
-    return *static_cast<simd8<T> *>(this);
-  }
-  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
-    *this = *this - other;
-    return *static_cast<simd8<T> *>(this);
-  }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return (__m128i)vec_perm((__m128i)lookup_table, (__m128i)lookup_table,
-                             this->value);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> : base8_numeric<int8_t> {
-  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
-  simdutf_really_inline simd8(const __m128i _value)
-      : base8_numeric<int8_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
-                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
-                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
-      : simd8((__m128i)(__vector signed char){v0, v1, v2, v3, v4, v5, v6, v7,
-                                              v8, v9, v10, v11, v12, v13, v14,
-                                              v15}) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15);
-  }
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return (__m128i)vec_max((__vector signed char)this->value,
-                            (__vector signed char)(__m128i)other);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return (__m128i)vec_min((__vector signed char)this->value,
-                            (__vector signed char)(__m128i)other);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return (__m128i)vec_cmpgt((__vector signed char)this->value,
-                              (__vector signed char)(__m128i)other);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return (__m128i)vec_cmplt((__vector signed char)this->value,
-                              (__vector signed char)(__m128i)other);
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
-  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
-  simdutf_really_inline simd8(const __m128i _value)
-      : base8_numeric<uint8_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
-      : simd8((__m128i){v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                        v13, v14, v15}) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return (__m128i)vec_adds(this->value, (__m128i)other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return (__m128i)vec_subs(this->value, (__m128i)other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return (__m128i)vec_max(this->value, (__m128i)other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return (__m128i)vec_min(this->value, (__m128i)other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return other.max_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return other.min_val(*this) == other;
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return this->gt_bits(other).any_bits_set();
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> bits_not_set() const {
-    return (__m128i)vec_cmpeq(this->value, (__m128i)vec_splats(uint8_t(0)));
-  }
-  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->saturating_sub(0b01111111u).bits_not_set_anywhere();
-  }
-
-  simdutf_really_inline bool bits_not_set_anywhere() const {
-    return vec_all_eq(this->value, (__m128i)vec_splats(0));
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return !bits_not_set_anywhere();
-  }
-  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
-    return vec_all_eq(vec_and(this->value, (__m128i)bits),
-                      (__m128i)vec_splats(0));
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return !bits_not_set_anywhere(bits);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return simd8<uint8_t>(
-        (__m128i)vec_sr(this->value, (__m128i)vec_splat_u8(N)));
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return simd8<uint8_t>(
-        (__m128i)vec_sl(this->value, (__m128i)vec_splat_u8(N)));
-  }
-};
-
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(NUM_CHUNKS == 4,
-                "PPC64 kernel should use four registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
-                                 const simd8<T> chunk2, const simd8<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    this->chunks[2] |= other.chunks[2];
-    this->chunks[3] |= other.chunks[3];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return input.reduce_or().is_ascii();
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r1 = this->chunks[1].to_bitmask();
-    uint64_t r2 = this->chunks[2].to_bitmask();
-    uint64_t r3 = this->chunks[3].to_bitmask();
-    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                          this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
-    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
-                          this->chunks[1] == other.chunks[1],
-                          this->chunks[2] == other.chunks[2],
-                          this->chunks[3] == other.chunks[3])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                          this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-    return simd8x64<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
-               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
-               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                          this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
-                          this->chunks[2] > mask, this->chunks[3] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
-                          this->chunks[2] >= mask, this->chunks[3] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>(simd8<uint8_t>(this->chunks[0]) >= mask,
-                          simd8<uint8_t>(this->chunks[1]) >= mask,
-                          simd8<uint8_t>(this->chunks[2]) >= mask,
-                          simd8<uint8_t>(this->chunks[3]) >= mask)
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-
-} // namespace simd
-} // unnamed namespace
-} // namespace ppc64
-} // namespace simdutf
-
-#endif // SIMDUTF_PPC64_SIMD_INPUT_H
-/* end file src/simdutf/ppc64/simd.h */
-
-/* begin file src/simdutf/ppc64/end.h */
-/* end file src/simdutf/ppc64/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_PPC64
-
-#endif // SIMDUTF_PPC64_H
-/* end file src/simdutf/ppc64.h */
-/* begin file src/simdutf/rvv.h */
-#ifndef SIMDUTF_RVV_H
-#define SIMDUTF_RVV_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "rvv.h must be included before fallback.h"
-#endif
-
-
-#define SIMDUTF_CAN_ALWAYS_RUN_RVV SIMDUTF_IS_RVV
-
-#ifndef SIMDUTF_IMPLEMENTATION_RVV
-  #define SIMDUTF_IMPLEMENTATION_RVV                                           \
-    (SIMDUTF_CAN_ALWAYS_RUN_RVV ||                                             \
-     (SIMDUTF_IS_RISCV64 && SIMDUTF_HAS_RVV_INTRINSICS &&                      \
-      SIMDUTF_HAS_RVV_TARGET_REGION))
-#endif
-
-#if SIMDUTF_IMPLEMENTATION_RVV
-
-  #if SIMDUTF_CAN_ALWAYS_RUN_RVV
-    #define SIMDUTF_TARGET_RVV
-  #else
-    #define SIMDUTF_TARGET_RVV SIMDUTF_TARGET_REGION("arch=+v")
-  #endif
-  #if !SIMDUTF_IS_ZVBB && SIMDUTF_HAS_ZVBB_INTRINSICS
-    #define SIMDUTF_TARGET_ZVBB SIMDUTF_TARGET_REGION("arch=+v,+zvbb")
-  #endif
-
-namespace simdutf {
-namespace rvv {} // namespace rvv
-} // namespace simdutf
-
-/* begin file src/simdutf/rvv/implementation.h */
-#ifndef SIMDUTF_RVV_IMPLEMENTATION_H
-#define SIMDUTF_RVV_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace rvv {
-
-namespace {
-using namespace simdutf;
-} // namespace
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("rvv", "RISC-V Vector Extension",
-                                internal::instruction_set::RVV),
-        _supports_zvbb(internal::detect_supported_architectures() &
-                       internal::instruction_set::ZVBB) {}
-  simdutf_warn_unused int detect_encodings(const char *buf,
-                                           size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t len,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t len) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t len) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *buf, size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *buf, size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf16le(const char16_t *buf, size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf16be(const char16_t *buf, size_t len) const noexcept;
-  simdutf_warn_unused size_t utf16_length_from_utf8(const char *buf,
-                                                    size_t len) const noexcept;
-  simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t *buf,
-                                                    size_t len) const noexcept;
-  simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t *buf,
-                                                     size_t len) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf8(const char *buf,
-                                                    size_t len) const noexcept;
-  simdutf_warn_unused size_t latin1_length_from_utf8(const char *buf,
-                                                     size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t len) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t len) const noexcept;
-  simdutf_warn_unused size_t utf8_length_from_latin1(const char *buf,
-                                                     size_t len) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-
-private:
-  const bool _supports_zvbb;
-
-#if SIMDUTF_IS_ZVBB
-  bool supports_zvbb() const { return true; }
-#elif SIMDUTF_HAS_ZVBB_INTRINSICS
-  bool supports_zvbb() const { return _supports_zvbb; }
-#else
-  bool supports_zvbb() const { return false; }
-#endif
-};
-
-} // namespace rvv
-} // namespace simdutf
-
-#endif // SIMDUTF_RVV_IMPLEMENTATION_H
-/* end file src/simdutf/rvv/implementation.h */
-/* begin file src/simdutf/rvv/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "rvv"
-// #define SIMDUTF_IMPLEMENTATION rvv
-
-#if SIMDUTF_CAN_ALWAYS_RUN_RVV
-// nothing needed.
-#else
-SIMDUTF_TARGET_RVV
-#endif
-/* end file src/simdutf/rvv/begin.h */
-/* begin file src/simdutf/rvv/intrinsics.h */
-#ifndef SIMDUTF_RVV_INTRINSICS_H
-#define SIMDUTF_RVV_INTRINSICS_H
-
-
-#include <riscv_vector.h>
-
-#if __riscv_v_intrinsic >= 1000000 || __GCC__ >= 14
-  #define simdutf_vrgather_u8m1x2(tbl, idx)                                    \
-    __riscv_vcreate_v_u8m1_u8m2(                                               \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 0),        \
-                                 __riscv_vsetvlmax_e8m1()),                    \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1),        \
-                                 __riscv_vsetvlmax_e8m1()));
-
-  #define simdutf_vrgather_u8m1x4(tbl, idx)                                    \
-    __riscv_vcreate_v_u8m1_u8m4(                                               \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 0),        \
-                                 __riscv_vsetvlmax_e8m1()),                    \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 1),        \
-                                 __riscv_vsetvlmax_e8m1()),                    \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2),        \
-                                 __riscv_vsetvlmax_e8m1()),                    \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3),        \
-                                 __riscv_vsetvlmax_e8m1()));
-#else
-  // This has worse codegen on gcc
-  #define simdutf_vrgather_u8m1x2(tbl, idx)                                    \
-    __riscv_vset_v_u8m1_u8m2(                                                  \
-        __riscv_vlmul_ext_v_u8m1_u8m2(__riscv_vrgather_vv_u8m1(                \
-            tbl, __riscv_vget_v_u8m2_u8m1(idx, 0), __riscv_vsetvlmax_e8m1())), \
-        1,                                                                     \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1),        \
-                                 __riscv_vsetvlmax_e8m1()))
-
-  #define simdutf_vrgather_u8m1x4(tbl, idx)                                    \
-    __riscv_vset_v_u8m1_u8m4(                                                  \
-        __riscv_vset_v_u8m1_u8m4(                                              \
-            __riscv_vset_v_u8m1_u8m4(                                          \
-                __riscv_vlmul_ext_v_u8m1_u8m4(__riscv_vrgather_vv_u8m1(        \
-                    tbl, __riscv_vget_v_u8m4_u8m1(idx, 0),                     \
-                    __riscv_vsetvlmax_e8m1())),                                \
-                1,                                                             \
-                __riscv_vrgather_vv_u8m1(tbl,                                  \
-                                         __riscv_vget_v_u8m4_u8m1(idx, 1),     \
-                                         __riscv_vsetvlmax_e8m1())),           \
-            2,                                                                 \
-            __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2),    \
-                                     __riscv_vsetvlmax_e8m1())),               \
-        3,                                                                     \
-        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3),        \
-                                 __riscv_vsetvlmax_e8m1()))
-#endif
-
-/* Zvbb adds dedicated support for endianness swaps with vrev8, but if we can't
- * use that, we have to emulate it with the standard V extension.
- * Using LMUL=1 vrgathers could be faster than the srl+macc variant, but that
- * would increase register pressure, and vrgather implementations performance
- * varies a lot. */
-enum class simdutf_ByteFlip { NONE, V, ZVBB };
-
-template <simdutf_ByteFlip method>
-simdutf_really_inline static uint16_t simdutf_byteflip(uint16_t v) {
-  if (method != simdutf_ByteFlip::NONE)
-    return (uint16_t)((v * 1u) << 8 | (v * 1u) >> 8);
-  return v;
-}
-
-#ifdef SIMDUTF_TARGET_ZVBB
-SIMDUTF_UNTARGET_REGION
-SIMDUTF_TARGET_ZVBB
-#endif
-
-template <simdutf_ByteFlip method>
-simdutf_really_inline static vuint16m1_t simdutf_byteflip(vuint16m1_t v,
-                                                          size_t vl) {
-#if SIMDUTF_HAS_ZVBB_INTRINSICS
-  if (method == simdutf_ByteFlip::ZVBB)
-    return __riscv_vrev8_v_u16m1(v, vl);
-#endif
-  if (method == simdutf_ByteFlip::V)
-    return __riscv_vmacc_vx_u16m1(__riscv_vsrl_vx_u16m1(v, 8, vl), 0x100, v,
-                                  vl);
-  return v;
-}
-
-template <simdutf_ByteFlip method>
-simdutf_really_inline static vuint16m2_t simdutf_byteflip(vuint16m2_t v,
-                                                          size_t vl) {
-#if SIMDUTF_HAS_ZVBB_INTRINSICS
-  if (method == simdutf_ByteFlip::ZVBB)
-    return __riscv_vrev8_v_u16m2(v, vl);
-#endif
-  if (method == simdutf_ByteFlip::V)
-    return __riscv_vmacc_vx_u16m2(__riscv_vsrl_vx_u16m2(v, 8, vl), 0x100, v,
-                                  vl);
-  return v;
-}
-
-template <simdutf_ByteFlip method>
-simdutf_really_inline static vuint16m4_t simdutf_byteflip(vuint16m4_t v,
-                                                          size_t vl) {
-#if SIMDUTF_HAS_ZVBB_INTRINSICS
-  if (method == simdutf_ByteFlip::ZVBB)
-    return __riscv_vrev8_v_u16m4(v, vl);
-#endif
-  if (method == simdutf_ByteFlip::V)
-    return __riscv_vmacc_vx_u16m4(__riscv_vsrl_vx_u16m4(v, 8, vl), 0x100, v,
-                                  vl);
-  return v;
-}
-
-template <simdutf_ByteFlip method>
-simdutf_really_inline static vuint16m8_t simdutf_byteflip(vuint16m8_t v,
-                                                          size_t vl) {
-#if SIMDUTF_HAS_ZVBB_INTRINSICS
-  if (method == simdutf_ByteFlip::ZVBB)
-    return __riscv_vrev8_v_u16m8(v, vl);
-#endif
-  if (method == simdutf_ByteFlip::V)
-    return __riscv_vmacc_vx_u16m8(__riscv_vsrl_vx_u16m8(v, 8, vl), 0x100, v,
-                                  vl);
-  return v;
-}
-
-#ifdef SIMDUTF_TARGET_ZVBB
-SIMDUTF_UNTARGET_REGION
-SIMDUTF_TARGET_RVV
-#endif
-
-#endif //  SIMDUTF_RVV_INTRINSICS_H
-/* end file src/simdutf/rvv/intrinsics.h */
-/* begin file src/simdutf/rvv/end.h */
-#if SIMDUTF_CAN_ALWAYS_RUN_RVV
-// nothing needed.
-#else
-SIMDUTF_UNTARGET_REGION
-#endif
-
-/* end file src/simdutf/rvv/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_RVV
-
-#endif // SIMDUTF_RVV_H
-/* end file src/simdutf/rvv.h */
-/* begin file src/simdutf/lsx.h */
-#ifndef SIMDUTF_LSX_H
-#define SIMDUTF_LSX_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "lsx.h must be included before fallback.h"
-#endif
-
-
-#ifndef SIMDUTF_IMPLEMENTATION_LSX
-  #define SIMDUTF_IMPLEMENTATION_LSX (SIMDUTF_IS_LSX)
-#endif
-#if SIMDUTF_IMPLEMENTATION_LSX && SIMDUTF_IS_LSX
-  #define SIMDUTF_CAN_ALWAYS_RUN_LSX 1
-#else
-  #define SIMDUTF_CAN_ALWAYS_RUN_LSX 0
-#endif
-
-#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
-
-#if SIMDUTF_IMPLEMENTATION_LSX
-
-namespace simdutf {
-/**
- * Implementation for LoongArch SX.
- */
-namespace lsx {} // namespace lsx
-} // namespace simdutf
-
-/* begin file src/simdutf/lsx/implementation.h */
-#ifndef SIMDUTF_LSX_IMPLEMENTATION_H
-#define SIMDUTF_LSX_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace lsx {
-
-namespace {
-using namespace simdutf;
-}
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("lsx", "LOONGARCH SX",
-                                internal::instruction_set::LSX) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char *input, size_t length, char *output,
-                   base64_options options) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-};
-
-} // namespace lsx
-} // namespace simdutf
-
-#endif // SIMDUTF_LSX_IMPLEMENTATION_H
-/* end file src/simdutf/lsx/implementation.h */
-
-/* begin file src/simdutf/lsx/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "lsx"
-// #define SIMDUTF_IMPLEMENTATION lsx
-/* end file src/simdutf/lsx/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/lsx/intrinsics.h */
-#ifndef SIMDUTF_LSX_INTRINSICS_H
-#define SIMDUTF_LSX_INTRINSICS_H
-
-
-// This should be the correct header whether
-// you use visual studio or other compilers.
-#include <lsxintrin.h>
-
-#endif //  SIMDUTF_LSX_INTRINSICS_H
-/* end file src/simdutf/lsx/intrinsics.h */
-/* begin file src/simdutf/lsx/bitmanipulation.h */
-#ifndef SIMDUTF_LSX_BITMANIPULATION_H
-#define SIMDUTF_LSX_BITMANIPULATION_H
-
-#include <limits>
-
-namespace simdutf {
-namespace lsx {
-namespace {
-
-simdutf_really_inline int count_ones(uint64_t input_num) {
-  return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
-}
-
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
-  return __builtin_ctzll(input_num);
-}
-#endif
-
-} // unnamed namespace
-} // namespace lsx
-} // namespace simdutf
-
-#endif // SIMDUTF_LSX_BITMANIPULATION_H
-/* end file src/simdutf/lsx/bitmanipulation.h */
-/* begin file src/simdutf/lsx/simd.h */
-#ifndef SIMDUTF_LSX_SIMD_H
-#define SIMDUTF_LSX_SIMD_H
-
-#include <type_traits>
-
-namespace simdutf {
-namespace lsx {
-namespace {
-namespace simd {
-
-template <typename T> struct simd8;
-
-//
-// Base class of simd8<uint8_t> and simd8<bool>, both of which use __m128i
-// internally.
-//
-template <typename T, typename Mask = simd8<bool>> struct base_u8 {
-  __m128i value;
-  static const int SIZE = sizeof(value);
-
-  // Conversion from/to SIMD register
-  simdutf_really_inline base_u8(const __m128i _value) : value(_value) {}
-  simdutf_really_inline operator const __m128i &() const { return this->value; }
-  simdutf_really_inline operator __m128i &() { return this->value; }
-  simdutf_really_inline T first() const {
-    return __lsx_vpickve2gr_bu(this->value, 0);
-  }
-  simdutf_really_inline T last() const {
-    return __lsx_vpickve2gr_bu(this->value, 15);
-  }
-
-  // Bit operations
-  simdutf_really_inline simd8<T> operator|(const simd8<T> other) const {
-    return __lsx_vor_v(this->value, other);
-  }
-  simdutf_really_inline simd8<T> operator&(const simd8<T> other) const {
-    return __lsx_vand_v(this->value, other);
-  }
-  simdutf_really_inline simd8<T> operator^(const simd8<T> other) const {
-    return __lsx_vxor_v(this->value, other);
-  }
-  simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const {
-    return __lsx_vandn_v(this->value, other);
-  }
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-  simdutf_really_inline simd8<T> &operator|=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd8<T> &operator&=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd8<T> &operator^=(const simd8<T> other) {
-    auto this_cast = static_cast<simd8<T> *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-
-  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return __lsx_vseq_b(lhs, rhs);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
-    return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
-                       __lsx_vbsrl_v(prev_chunk.value, 16 - N));
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base_u8<bool> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return __lsx_vreplgr2vr_b(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8(const __m128i _value) : base_u8<bool>(_value) {}
-  // False constructor
-  simdutf_really_inline simd8() : simd8(__lsx_vldi(0)) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : simd8(splat(_value)) {}
-  simdutf_really_inline void store(uint8_t dst[16]) const {
-    return __lsx_vst(this->value, dst, 0);
-  }
-
-  simdutf_really_inline uint32_t to_bitmask() const {
-    return __lsx_vpickve2gr_wu(__lsx_vmsknz_b(*this), 0);
-  }
-
-  simdutf_really_inline bool any() const {
-    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) != 0;
-  }
-  simdutf_really_inline bool none() const {
-    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0;
-  }
-  simdutf_really_inline bool all() const {
-    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0xFFFF;
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base_u8<uint8_t> {
-  static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value) {
-    return __lsx_vreplgr2vr_b(_value);
-  }
-  static simdutf_really_inline simd8<uint8_t> zero() { return __lsx_vldi(0); }
-  static simdutf_really_inline simd8<uint8_t> load(const uint8_t *values) {
-    return __lsx_vld(values, 0);
-  }
-  simdutf_really_inline simd8(const __m128i _value)
-      : base_u8<uint8_t>(_value) {}
-  // Zero constructor
-  simdutf_really_inline simd8() : simd8(zero()) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t values[16]) : simd8(load(values)) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Member-by-member initialization
-
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
-      : simd8((__m128i)v16u8{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                             v12, v13, v14, v15}) {}
-
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15);
-  }
-
-  // Store to array
-  simdutf_really_inline void store(uint8_t dst[16]) const {
-    return __lsx_vst(this->value, dst, 0);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return __lsx_vsadd_bu(this->value, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return __lsx_vssub_bu(this->value, other);
-  }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<uint8_t>
-  operator+(const simd8<uint8_t> other) const {
-    return __lsx_vadd_b(this->value, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  operator-(const simd8<uint8_t> other) const {
-    return __lsx_vsub_b(this->value, other);
-  }
-  simdutf_really_inline simd8<uint8_t> &operator+=(const simd8<uint8_t> other) {
-    *this = *this + other;
-    return *this;
-  }
-  simdutf_really_inline simd8<uint8_t> &operator-=(const simd8<uint8_t> other) {
-    *this = *this - other;
-    return *this;
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return __lsx_vmax_bu(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return __lsx_vmin_bu(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return __lsx_vsle_bu(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return __lsx_vsle_bu(other, *this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return __lsx_vslt_bu(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return __lsx_vslt_bu(other, *this);
-  }
-  // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
-  // = nonzero. For ARM, returns all 1's.
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return simd8<uint8_t>(*this > other);
-  }
-  // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
-  // = nonzero. For ARM, returns all 1's.
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return simd8<uint8_t>(*this < other);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return __lsx_vslt_bu(__lsx_vldi(0), __lsx_vand_v(this->value, bits));
-  }
-  simdutf_really_inline bool is_ascii() const {
-    return __lsx_vpickve2gr_hu(__lsx_vmskgez_b(this->value), 0) == 0xFFFF;
-  }
-
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(this->value), 0) > 0;
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return (*this & bits).any_bits_set_anywhere();
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return __lsx_vsrli_b(this->value, N);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return __lsx_vslli_b(this->value, N);
-  }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return lookup_table.apply_lookup_16_to(*this);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-
-  template <typename T>
-  simdutf_really_inline simd8<uint8_t>
-  apply_lookup_16_to(const simd8<T> original) const {
-    __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
-    return __lsx_vshuf_b(__lsx_vldi(0), *this, simd8<uint8_t>(original_tmp));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> {
-  __m128i value;
-
-  static simdutf_really_inline simd8<int8_t> splat(int8_t _value) {
-    return __lsx_vreplgr2vr_b(_value);
-  }
-  static simdutf_really_inline simd8<int8_t> zero() { return __lsx_vldi(0); }
-  static simdutf_really_inline simd8<int8_t> load(const int8_t values[16]) {
-    return __lsx_vld(values, 0);
-  }
-
-  template <endianness big_endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
-    __m128i zero = __lsx_vldi(0);
-    if (match_system(big_endian)) {
-      __lsx_vst(__lsx_vilvl_b(zero, (__m128i)this->value),
-                reinterpret_cast<uint16_t *>(p), 0);
-      __lsx_vst(__lsx_vilvh_b(zero, (__m128i)this->value),
-                reinterpret_cast<uint16_t *>(p + 8), 0);
-    } else {
-      __lsx_vst(__lsx_vilvl_b((__m128i)this->value, zero),
-                reinterpret_cast<uint16_t *>(p), 0);
-      __lsx_vst(__lsx_vilvh_b((__m128i)this->value, zero),
-                reinterpret_cast<uint16_t *>(p + 8), 0);
-    }
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
-    __m128i zero = __lsx_vldi(0);
-    __m128i in16low = __lsx_vilvl_b(zero, (__m128i)this->value);
-    __m128i in16high = __lsx_vilvh_b(zero, (__m128i)this->value);
-    __m128i in32_0 = __lsx_vilvl_h(zero, in16low);
-    __m128i in32_1 = __lsx_vilvh_h(zero, in16low);
-    __m128i in32_2 = __lsx_vilvl_h(zero, in16high);
-    __m128i in32_3 = __lsx_vilvh_h(zero, in16high);
-    __lsx_vst(in32_0, reinterpret_cast<uint32_t *>(p), 0);
-    __lsx_vst(in32_1, reinterpret_cast<uint32_t *>(p + 4), 0);
-    __lsx_vst(in32_2, reinterpret_cast<uint32_t *>(p + 8), 0);
-    __lsx_vst(in32_3, reinterpret_cast<uint32_t *>(p + 12), 0);
-  }
-
-  // In places where the table can be reused, which is most uses in simdutf, it
-  // is worth it to do 4 table lookups, as there is no direct zero extension
-  // from u8 to u32.
-  simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t *p) const {
-    const simd8<uint8_t> tb1{0, 255, 255, 255, 1, 255, 255, 255,
-                             2, 255, 255, 255, 3, 255, 255, 255};
-    const simd8<uint8_t> tb2{4, 255, 255, 255, 5, 255, 255, 255,
-                             6, 255, 255, 255, 7, 255, 255, 255};
-    const simd8<uint8_t> tb3{8,  255, 255, 255, 9,  255, 255, 255,
-                             10, 255, 255, 255, 11, 255, 255, 255};
-    const simd8<uint8_t> tb4{12, 255, 255, 255, 13, 255, 255, 255,
-                             14, 255, 255, 255, 15, 255, 255, 255};
-
-    // encourage store pairing and interleaving
-    const auto shuf1 = this->apply_lookup_16_to(tb1);
-    const auto shuf2 = this->apply_lookup_16_to(tb2);
-    shuf1.store(reinterpret_cast<int8_t *>(p));
-    shuf2.store(reinterpret_cast<int8_t *>(p + 4));
-
-    const auto shuf3 = this->apply_lookup_16_to(tb3);
-    const auto shuf4 = this->apply_lookup_16_to(tb4);
-    shuf3.store(reinterpret_cast<int8_t *>(p + 8));
-    shuf4.store(reinterpret_cast<int8_t *>(p + 12));
-  }
-  // Conversion from/to SIMD register
-  simdutf_really_inline simd8(const __m128i _value) : value(_value) {}
-  simdutf_really_inline operator const __m128i &() const { return this->value; }
-
-  simdutf_really_inline operator const __m128i() const { return this->value; }
-
-  simdutf_really_inline operator __m128i &() { return this->value; }
-
-  // Zero constructor
-  simdutf_really_inline simd8() : simd8(zero()) {}
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
-  // Member-by-member initialization
-
-  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
-                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
-                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
-      : simd8((__m128i)v16i8{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                             v12, v13, v14, v15}) {}
-
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15);
-  }
-
-  // Store to array
-  simdutf_really_inline void store(int8_t dst[16]) const {
-    return __lsx_vst(value, dst, 0);
-  }
-
-  simdutf_really_inline operator simd8<uint8_t>() const {
-    return ((__m128i)this->value);
-  }
-
-  simdutf_really_inline simd8<int8_t>
-  operator|(const simd8<int8_t> other) const {
-    return __lsx_vor_v((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator&(const simd8<int8_t> other) const {
-    return __lsx_vand_v((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator^(const simd8<int8_t> other) const {
-    return __lsx_vxor_v((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  bit_andnot(const simd8<int8_t> other) const {
-    return __lsx_vandn_v((__m128i)other.value, (__m128i)value);
-  }
-
-  // Math
-  simdutf_really_inline simd8<int8_t>
-  operator+(const simd8<int8_t> other) const {
-    return __lsx_vadd_b((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t>
-  operator-(const simd8<int8_t> other) const {
-    return __lsx_vsub_b((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t> &operator+=(const simd8<int8_t> other) {
-    *this = *this + other;
-    return *this;
-  }
-  simdutf_really_inline simd8<int8_t> &operator-=(const simd8<int8_t> other) {
-    *this = *this - other;
-    return *this;
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return (__lsx_vpickve2gr_hu(__lsx_vmskgez_b((__m128i)this->value), 0) ==
-            0xffff);
-  }
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return __lsx_vmax_b((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return __lsx_vmin_b((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return __lsx_vslt_b((__m128i)other.value, (__m128i)value);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return __lsx_vslt_b((__m128i)value, (__m128i)other.value);
-  }
-  simdutf_really_inline simd8<bool>
-  operator==(const simd8<int8_t> other) const {
-    return __lsx_vseq_b((__m128i)value, (__m128i)other.value);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd8<int8_t>
-  prev(const simd8<int8_t> prev_chunk) const {
-    return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
-                       __lsx_vbsrl_v(prev_chunk.value, 16 - N));
-  }
-
-  // Perform a lookup assuming no value is larger than 16
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    return lookup_table.apply_lookup_16_to(*this);
-  }
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-
-  template <typename T>
-  simdutf_really_inline simd8<int8_t>
-  apply_lookup_16_to(const simd8<T> original) const {
-    __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
-    return __lsx_vshuf_b(__lsx_vldi(0), (__m128i)this->value,
-                         simd8<uint8_t>(original_tmp));
-  }
-};
-
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(
-      NUM_CHUNKS == 4,
-      "LoongArch kernel should use four registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
-                                 const simd8<T> chunk2, const simd8<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
-               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    this->chunks[2] |= other.chunks[2];
-    this->chunks[3] |= other.chunks[3];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
-
-  template <endianness endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 0);
-    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 1);
-    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 2);
-    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
-    this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
-    this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
-    this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[3]), 6);
-    mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[2]), 4));
-    mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[1]), 2));
-    mask = __lsx_vor_v(mask, __lsx_vmsknz_b(this->chunks[0]));
-    return __lsx_vpickve2gr_du(mask, 0);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                          this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                          this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-    return simd8x64<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
-               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
-               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                          this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
-                          this->chunks[2] > mask, this->chunks[3] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
-                          this->chunks[2] >= mask, this->chunks[3] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>(simd8<uint8_t>(this->chunks[0].value) >= mask,
-                          simd8<uint8_t>(this->chunks[1].value) >= mask,
-                          simd8<uint8_t>(this->chunks[2].value) >= mask,
-                          simd8<uint8_t>(this->chunks[3].value) >= mask)
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-/* begin file src/simdutf/lsx/simd16-inl.h */
-template <typename T> struct simd16;
-
-template <typename T, typename Mask = simd16<bool>> struct base_u16 {
-  __m128i value;
-  static const int SIZE = sizeof(value);
-
-  // Conversion from/to SIMD register
-  simdutf_really_inline base_u16() = default;
-  simdutf_really_inline base_u16(const __m128i _value) : value(_value) {}
-  // Bit operations
-  simdutf_really_inline simd16<T> operator|(const simd16<T> other) const {
-    return __lsx_vor_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<T> operator&(const simd16<T> other) const {
-    return __lsx_vand_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<T> operator^(const simd16<T> other) const {
-    return __lsx_vxor_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const {
-    return __lsx_vandn_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
-  simdutf_really_inline simd16<T> &operator|=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd16<T> &operator&=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline simd16<T> &operator^=(const simd16<T> other) {
-    auto this_cast = static_cast<simd16<T> *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-
-  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
-                                               const simd16<T> rhs) {
-    return __lsx_vseq_h(lhs.value, rhs.value);
-  }
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
-                       __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
-  }
-};
-
-template <typename T, typename Mask = simd16<bool>>
-struct base16 : base_u16<T> {
-  typedef uint16_t bitmask_t;
-  typedef uint32_t bitmask2_t;
-
-  simdutf_really_inline base16() : base_u16<T>() {}
-  simdutf_really_inline base16(const __m128i _value) : base_u16<T>(_value) {}
-  template <typename Pointer>
-  simdutf_really_inline base16(const Pointer *ptr)
-      : base16(__lsx_vld(ptr, 0)) {}
-
-  static const int SIZE = sizeof(base_u16<T>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
-                       __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd16<bool> : base16<bool> {
-  static simdutf_really_inline simd16<bool> splat(bool _value) {
-    return __lsx_vreplgr2vr_h(uint16_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd16() : base16() {}
-  simdutf_really_inline simd16(const __m128i _value) : base16<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
-};
-
-template <typename T> struct base16_numeric : base16<T> {
-  static simdutf_really_inline simd16<T> splat(T _value) {
-    return __lsx_vreplgr2vr_h(_value);
-  }
-  static simdutf_really_inline simd16<T> zero() { return __lsx_vldi(0); }
-  static simdutf_really_inline simd16<T> load(const T values[8]) {
-    return __lsx_vld(reinterpret_cast<const uint16_t *>(values), 0);
-  }
-
-  simdutf_really_inline base16_numeric() : base16<T>() {}
-  simdutf_really_inline base16_numeric(const __m128i _value)
-      : base16<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[8]) const {
-    return __lsx_vst(this->value, dst, 0);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
-    return __lsx_vadd_b(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
-    return __lsx_vsub_b(*this, other);
-  }
-  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
-    *this = *this + other;
-    return *static_cast<simd16<T> *>(this);
-  }
-  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
-    *this = *this - other;
-    return *static_cast<simd16<T> *>(this);
-  }
-};
-
-// Signed code unitstemplate<>
-template <> struct simd16<int16_t> : base16_numeric<int16_t> {
-  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
-  simdutf_really_inline simd16(const __m128i _value)
-      : base16_numeric<int16_t>(_value) {}
-  simdutf_really_inline simd16(simd16<bool> other)
-      : base16_numeric<int16_t>(other.value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
-  simdutf_really_inline operator simd16<uint16_t>() const;
-
-  // Order-sensitive comparisons
-  simdutf_really_inline simd16<int16_t>
-  max_val(const simd16<int16_t> other) const {
-    return __lsx_vmax_h(this->value, other.value);
-  }
-  simdutf_really_inline simd16<int16_t>
-  min_val(const simd16<int16_t> other) const {
-    return __lsx_vmin_h(this->value, other.value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<int16_t> other) const {
-    return __lsx_vsle_h(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<int16_t> other) const {
-    return __lsx_vslt_h(this->value, other.value);
-  }
-};
-
-// Unsigned code unitstemplate<>
-template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
-  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
-  simdutf_really_inline simd16(const __m128i _value)
-      : base16_numeric<uint16_t>((__m128i)_value) {}
-  simdutf_really_inline simd16(simd16<bool> other)
-      : base16_numeric<uint16_t>(other.value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
-
-  // Saturated math
-  simdutf_really_inline simd16<uint16_t>
-  saturating_add(const simd16<uint16_t> other) const {
-    return __lsx_vsadd_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  saturating_sub(const simd16<uint16_t> other) const {
-    return __lsx_vssub_hu(this->value, other.value);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd16<uint16_t>
-  max_val(const simd16<uint16_t> other) const {
-    return __lsx_vmax_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  min_val(const simd16<uint16_t> other) const {
-    return __lsx_vmin_hu(this->value, other.value);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  gt_bits(const simd16<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  lt_bits(const simd16<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<=(const simd16<uint16_t> other) const {
-    return __lsx_vsle_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>=(const simd16<uint16_t> other) const {
-    return __lsx_vsle_hu(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<uint16_t> other) const {
-    return __lsx_vslt_hu(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<uint16_t> other) const {
-    return __lsx_vslt_hu(this->value, other.value);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd16<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
-    return simd16<uint16_t>(__lsx_vsrli_h(this->value, N));
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
-    return simd16<uint16_t>(__lsx_vslli_h(this->value, N));
-  }
-
-  // logical operations
-  simdutf_really_inline simd16<uint16_t>
-  operator|(const simd16<uint16_t> other) const {
-    return __lsx_vor_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  operator&(const simd16<uint16_t> other) const {
-    return __lsx_vand_v(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  operator^(const simd16<uint16_t> other) const {
-    return __lsx_vxor_v(this->value, other.value);
-  }
-
-  // Pack with the unsigned saturation of two uint16_t code units into single
-  // uint8_t vector
-  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
-                                                   const simd16<uint16_t> &v1) {
-    return __lsx_vssrlni_bu_h(v1.value, v0.value, 0);
-  }
-
-  // Change the endianness
-  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
-    return __lsx_vshuf4i_b(this->value, 0b10110001);
-  }
-};
-
-simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
-  return this->value;
-}
-
-template <typename T> struct simd16x32 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
-  static_assert(
-      NUM_CHUNKS == 4,
-      "LOONGARCH kernel should use four registers per 64-byte block.");
-  simd16<T> chunks[NUM_CHUNKS];
-
-  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
-  simd16x32<T> &
-  operator=(const simd16<T> other) = delete; // no assignment allowed
-  simd16x32() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline
-  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
-            const simd16<T> chunk2, const simd16<T> chunk3)
-      : chunks{chunk0, chunk1, chunk2, chunk3} {}
-  simdutf_really_inline simd16x32(const T *ptr)
-      : chunks{simd16<T>::load(ptr),
-               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
-               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
-    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
-    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
-  }
-
-  simdutf_really_inline simd16<T> reduce_or() const {
-    return (this->chunks[0] | this->chunks[1]) |
-           (this->chunks[2] | this->chunks[3]);
-  }
-
-  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
-
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
-    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
-    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
-    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[3]).value), 6);
-    mask = __lsx_vor_v(
-        mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[2]).value), 4));
-    mask = __lsx_vor_v(
-        mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[1]).value), 2));
-    mask = __lsx_vor_v(mask, __lsx_vmsknz_b((this->chunks[0]).value));
-    return __lsx_vpickve2gr_du(mask, 0);
-  }
-
-  simdutf_really_inline void swap_bytes() {
-    this->chunks[0] = this->chunks[0].swap_bytes();
-    this->chunks[1] = this->chunks[1].swap_bytes();
-    this->chunks[2] = this->chunks[2].swap_bytes();
-    this->chunks[3] = this->chunks[3].swap_bytes();
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
-                           this->chunks[2] == mask, this->chunks[3] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
-                           this->chunks[2] <= mask, this->chunks[3] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-
-    return simd16x32<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
-               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
-               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-    return simd16x32<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
-               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
-               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
-                           this->chunks[2] < mask, this->chunks[3] < mask)
-        .to_bitmask();
-  }
-
-}; // struct simd16x32<T>
-
-template <>
-simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
-    const uint16_t low, const uint16_t high) const {
-  const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
-  const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
-  simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) |
-                                         (this->chunks[0] < mask_low)),
-                        simd16<uint16_t>((this->chunks[1] > mask_high) |
-                                         (this->chunks[1] < mask_low)),
-                        simd16<uint16_t>((this->chunks[2] > mask_high) |
-                                         (this->chunks[2] < mask_low)),
-                        simd16<uint16_t>((this->chunks[3] > mask_high) |
-                                         (this->chunks[3] < mask_low)));
-  return x.to_bitmask();
-}
-/* end file src/simdutf/lsx/simd16-inl.h */
-} // namespace simd
-} // unnamed namespace
-} // namespace lsx
-} // namespace simdutf
-
-#endif // SIMDUTF_LSX_SIMD_H
-/* end file src/simdutf/lsx/simd.h */
-
-/* begin file src/simdutf/lsx/end.h */
-/* end file src/simdutf/lsx/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_LSX
-
-#endif // SIMDUTF_LSX_H
-/* end file src/simdutf/lsx.h */
-/* begin file src/simdutf/lasx.h */
-#ifndef SIMDUTF_LASX_H
-#define SIMDUTF_LASX_H
-
-#ifdef SIMDUTF_FALLBACK_H
-  #error "lasx.h must be included before fallback.h"
-#endif
-
-
-#ifndef SIMDUTF_IMPLEMENTATION_LASX
-  #define SIMDUTF_IMPLEMENTATION_LASX (SIMDUTF_IS_LASX)
-#endif
-#if SIMDUTF_IMPLEMENTATION_LASX && SIMDUTF_IS_LASX
-  #define SIMDUTF_CAN_ALWAYS_RUN_LASX 1
-#else
-  #define SIMDUTF_CAN_ALWAYS_RUN_LASX 0
-#endif
-
-#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
-
-#if SIMDUTF_IMPLEMENTATION_LASX
-
-namespace simdutf {
-/**
- * Implementation for LoongArch ASX.
- */
-namespace lasx {} // namespace lasx
-} // namespace simdutf
-
-/* begin file src/simdutf/lasx/implementation.h */
-#ifndef SIMDUTF_LASX_IMPLEMENTATION_H
-#define SIMDUTF_LASX_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace lasx {
-
-namespace {
-using namespace simdutf;
-}
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("lasx", "LOONGARCH ASX",
-                                internal::instruction_set::LSX |
-                                    internal::instruction_set::LASX) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char *input, size_t length, char *output,
-                   base64_options options) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual result
-  base64_to_binary(const char16_t *input, size_t length, char *output,
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options =
-                       last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused virtual full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-};
-
-} // namespace lasx
-} // namespace simdutf
-
-#endif // SIMDUTF_LASX_IMPLEMENTATION_H
-/* end file src/simdutf/lasx/implementation.h */
-
-/* begin file src/simdutf/lasx/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "lasx"
-// #define SIMDUTF_IMPLEMENTATION lasx
-/* end file src/simdutf/lasx/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/lasx/intrinsics.h */
-#ifndef SIMDUTF_LASX_INTRINSICS_H
-#define SIMDUTF_LASX_INTRINSICS_H
-
-
-// This should be the correct header whether
-// you use visual studio or other compilers.
-#include <lsxintrin.h>
-#include <lasxintrin.h>
-
-#if defined(__loongarch_asx)
-  #ifdef __clang__
-    #define VREGS_PREFIX "$vr"
-    #define XREGS_PREFIX "$xr"
-  #else // GCC
-    #define VREGS_PREFIX "$f"
-    #define XREGS_PREFIX "$f"
-  #endif
-  #define __ALL_REGS                                                           \
-    "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,"  \
-    "27,28,29,30,31"
-// Convert __m128i to __m256i
-static inline __m256i ____m256i(__m128i in) {
-  __m256i out = __lasx_xvldi(0);
-  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
-                   " .ifc %[out], " XREGS_PREFIX "\\i    \n\t"
-                   "  .irp j," __ALL_REGS "\n\t"
-                   "   .ifc %[in], " VREGS_PREFIX "\\j  \n\t"
-                   "    xvpermi.q $xr\\i, $xr\\j, 0x0  \n\t"
-                   "   .endif                           \n\t"
-                   "  .endr                             \n\t"
-                   " .endif                             \n\t"
-                   ".endr                               \n\t"
-                   : [out] "+f"(out)
-                   : [in] "f"(in));
-  return out;
-}
-// Convert two __m128i to __m256i
-static inline __m256i lasx_set_q(__m128i inhi, __m128i inlo) {
-  __m256i out;
-  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
-                   " .ifc %[hi], " VREGS_PREFIX "\\i    \n\t"
-                   "  .irp j," __ALL_REGS "\n\t"
-                   "   .ifc %[lo], " VREGS_PREFIX "\\j  \n\t"
-                   "    xvpermi.q $xr\\i, $xr\\j, 0x20  \n\t"
-                   "   .endif                           \n\t"
-                   "  .endr                             \n\t"
-                   " .endif                             \n\t"
-                   ".endr                               \n\t"
-                   ".ifnc %[out], %[hi]                 \n\t"
-                   ".irp i," __ALL_REGS "\n\t"
-                   " .ifc %[out], " XREGS_PREFIX "\\i   \n\t"
-                   "  .irp j," __ALL_REGS "\n\t"
-                   "   .ifc %[hi], " VREGS_PREFIX "\\j  \n\t"
-                   "    xvori.b $xr\\i, $xr\\j, 0       \n\t"
-                   "   .endif                           \n\t"
-                   "  .endr                             \n\t"
-                   " .endif                             \n\t"
-                   ".endr                               \n\t"
-                   ".endif                              \n\t"
-                   : [out] "=f"(out), [hi] "+f"(inhi)
-                   : [lo] "f"(inlo));
-  return out;
-}
-// Convert __m256i low part to __m128i
-static inline __m128i lasx_extracti128_lo(__m256i in) {
-  __m128i out;
-  __asm__ volatile(".ifnc %[out], %[in]                 \n\t"
-                   ".irp i," __ALL_REGS "\n\t"
-                   " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
-                   "  .irp j," __ALL_REGS "\n\t"
-                   "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
-                   "    vori.b $vr\\i, $vr\\j, 0        \n\t"
-                   "   .endif                           \n\t"
-                   "  .endr                             \n\t"
-                   " .endif                             \n\t"
-                   ".endr                               \n\t"
-                   ".endif                              \n\t"
-                   : [out] "=f"(out)
-                   : [in] "f"(in));
-  return out;
-}
-// Convert __m256i high part to __m128i
-static inline __m128i lasx_extracti128_hi(__m256i in) {
-  __m128i out;
-  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
-                   " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
-                   "  .irp j," __ALL_REGS "\n\t"
-                   "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
-                   "    xvpermi.q $xr\\i, $xr\\j, 0x11  \n\t"
-                   "   .endif                           \n\t"
-                   "  .endr                             \n\t"
-                   " .endif                             \n\t"
-                   ".endr                               \n\t"
-                   : [out] "=f"(out)
-                   : [in] "f"(in));
-  return out;
-}
-#endif
-
-#endif //  SIMDUTF_LASX_INTRINSICS_H
-/* end file src/simdutf/lasx/intrinsics.h */
-/* begin file src/simdutf/lasx/bitmanipulation.h */
-#ifndef SIMDUTF_LASX_BITMANIPULATION_H
-#define SIMDUTF_LASX_BITMANIPULATION_H
-
-#include <limits>
-
-namespace simdutf {
-namespace lasx {
-namespace {
-
-simdutf_really_inline int count_ones(uint64_t input_num) {
-  return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
-}
-
-#if SIMDUTF_NEED_TRAILING_ZEROES
-simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
-  return __builtin_ctzll(input_num);
-}
-#endif
-
-} // unnamed namespace
-} // namespace lasx
-} // namespace simdutf
-
-#endif // SIMDUTF_LASX_BITMANIPULATION_H
-/* end file src/simdutf/lasx/bitmanipulation.h */
-/* begin file src/simdutf/lasx/simd.h */
-#ifndef SIMDUTF_LASX_SIMD_H
-#define SIMDUTF_LASX_SIMD_H
-
-#include <type_traits>
-
-namespace simdutf {
-namespace lasx {
-namespace {
-namespace simd {
-
-__attribute__((aligned(32))) static const uint8_t prev_shuf_table[32][32] = {
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
-    {0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
-     31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14},
-    {0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
-     30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},
-    {0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
-     29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
-    {0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
-     28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},
-    {0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
-     27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
-    {0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-     26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
-    {0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8,
-     25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7,
-     24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6,
-     23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5,
-     22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4,
-     21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3,
-     20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2,
-     19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1,
-     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1},
-    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-     17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0},
-    {15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
-     15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
-     14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
-     13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
-     12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
-     11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
-     10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
-     9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0},
-    {8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
-     8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0},
-    {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
-     7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0},
-    {6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
-     6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0},
-    {5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
-     5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0},
-    {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
-     4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0},
-    {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
-     3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0},
-    {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
-     2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0},
-    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
-     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0},
-    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
-};
-
-__attribute__((aligned(32))) static const uint8_t bitsel_mask_table[32][32] = {
-    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0},
-    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0}};
-
-// Forward-declared so they can be used by splat and friends.
-template <typename Child> struct base {
-  __m256i value;
-
-  // Zero constructor
-  simdutf_really_inline base() : value{__m256i()} {}
-
-  // Conversion from SIMD register
-  simdutf_really_inline base(const __m256i _value) : value(_value) {}
-  // Conversion to SIMD register
-  simdutf_really_inline operator const __m256i &() const { return this->value; }
-  simdutf_really_inline operator __m256i &() { return this->value; }
-  template <endianness big_endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    if (big_endian) {
-      __m256i zero = __lasx_xvldi(0);
-      __m256i in8 = __lasx_xvpermi_d(this->value, 0b11011000);
-      __m256i inlow = __lasx_xvilvl_b(in8, zero);
-      __m256i inhigh = __lasx_xvilvh_b(in8, zero);
-      __lasx_xvst(inlow, reinterpret_cast<uint16_t *>(ptr), 0);
-      __lasx_xvst(inhigh, reinterpret_cast<uint16_t *>(ptr), 32);
-    } else {
-      __m256i inlow = __lasx_vext2xv_hu_bu(this->value);
-      __m256i inhigh = __lasx_vext2xv_hu_bu(
-          __lasx_xvpermi_q(this->value, this->value, 0b00000001));
-      __lasx_xvst(inlow, reinterpret_cast<__m256i *>(ptr), 0);
-      __lasx_xvst(inhigh, reinterpret_cast<__m256i *>(ptr), 32);
-    }
-  }
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    __m256i in32_0 = __lasx_vext2xv_wu_bu(this->value);
-    __lasx_xvst(in32_0, reinterpret_cast<uint32_t *>(ptr), 0);
-
-    __m256i in8_1 = __lasx_xvpermi_d(this->value, 0b00000001);
-    __m256i in32_1 = __lasx_vext2xv_wu_bu(in8_1);
-    __lasx_xvst(in32_1, reinterpret_cast<uint32_t *>(ptr), 32);
-
-    __m256i in8_2 = __lasx_xvpermi_d(this->value, 0b00000010);
-    __m256i in32_2 = __lasx_vext2xv_wu_bu(in8_2);
-    __lasx_xvst(in32_2, reinterpret_cast<uint32_t *>(ptr), 64);
-
-    __m256i in8_3 = __lasx_xvpermi_d(this->value, 0b00000011);
-    __m256i in32_3 = __lasx_vext2xv_wu_bu(in8_3);
-    __lasx_xvst(in32_3, reinterpret_cast<uint32_t *>(ptr), 96);
-  }
-  // Bit operations
-  simdutf_really_inline Child operator|(const Child other) const {
-    return __lasx_xvor_v(this->value, other);
-  }
-  simdutf_really_inline Child operator&(const Child other) const {
-    return __lasx_xvand_v(this->value, other);
-  }
-  simdutf_really_inline Child operator^(const Child other) const {
-    return __lasx_xvxor_v(this->value, other);
-  }
-  simdutf_really_inline Child bit_andnot(const Child other) const {
-    return __lasx_xvandn_v(this->value, other);
-  }
-  simdutf_really_inline Child &operator|=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast | other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator&=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast & other;
-    return *this_cast;
-  }
-  simdutf_really_inline Child &operator^=(const Child other) {
-    auto this_cast = static_cast<Child *>(this);
-    *this_cast = *this_cast ^ other;
-    return *this_cast;
-  }
-};
-
-template <typename T> struct simd8;
-
-template <typename T, typename Mask = simd8<bool>>
-struct base8 : base<simd8<T>> {
-  typedef uint32_t bitmask_t;
-  typedef uint64_t bitmask2_t;
-
-  simdutf_really_inline base8() : base<simd8<T>>() {}
-  simdutf_really_inline base8(const __m256i _value) : base<simd8<T>>(_value) {}
-  simdutf_really_inline T first() const {
-    return __lasx_xvpickve2gr_wu(this->value, 0);
-  }
-  simdutf_really_inline T last() const {
-    return __lasx_xvpickve2gr_wu(this->value, 7);
-  }
-  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
-                                               const simd8<T> rhs) {
-    return __lasx_xvseq_b(lhs, rhs);
-  }
-
-  static const int SIZE = sizeof(base<T>::value);
-
-  template <int N = 1>
-  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
-    if (!N)
-      return this->value;
-
-    __m256i zero = __lasx_xvldi(0);
-    __m256i result, shuf;
-    if (N < 16) {
-      shuf = __lasx_xvld(prev_shuf_table[N], 0);
-
-      result = __lasx_xvshuf_b(
-          __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
-          shuf);
-      __m256i srl_prev = __lasx_xvbsrl_v(
-          __lasx_xvpermi_q(zero, prev_chunk.value, 0b00110001), (16 - N));
-      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
-      result = __lasx_xvbitsel_v(result, srl_prev, mask);
-
-      return result;
-    } else if (N == 16) {
-      return __lasx_xvpermi_q(this->value, prev_chunk.value, 0b00100001);
-    } /*else {
-      __m256i sll_value = __lasx_xvbsll_v(
-          __lasx_xvpermi_q(zero, this->value, 0b00000011), (N - 16) % 32);
-      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
-      shuf = __lasx_xvld(prev_shuf_table[N], 0);
-      result = __lasx_xvshuf_b(
-          __lasx_xvpermi_q(prev_chunk.value, prev_chunk.value, 0b00000001),
-          prev_chunk.value, shuf);
-      result = __lasx_xvbitsel_v(sll_value, result, mask);
-      return result;
-    }*/
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd8<bool> : base8<bool> {
-  static simdutf_really_inline simd8<bool> splat(bool _value) {
-    return __lasx_xvreplgr2vr_b(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd8() : base8() {}
-  simdutf_really_inline simd8(const __m256i _value) : base8<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
-
-  simdutf_really_inline uint32_t to_bitmask() const {
-    __m256i mask = __lasx_xvmsknz_b(this->value);
-    uint32_t mask0 = __lasx_xvpickve2gr_wu(mask, 0);
-    uint32_t mask1 = __lasx_xvpickve2gr_wu(mask, 4);
-    return (mask0 | (mask1 << 16));
-  }
-  simdutf_really_inline bool any() const {
-    if (__lasx_xbz_b(this->value))
-      return false;
-    return true;
-  }
-  simdutf_really_inline bool none() const {
-    if (__lasx_xbz_b(this->value))
-      return true;
-    return false;
-  }
-  simdutf_really_inline bool all() const {
-    if (__lasx_xbnz_b(this->value))
-      return true;
-    return false;
-  }
-  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base8_numeric : base8<T> {
-  static simdutf_really_inline simd8<T> splat(T _value) {
-    return __lasx_xvreplgr2vr_b(_value);
-  }
-  static simdutf_really_inline simd8<T> zero() { return __lasx_xvldi(0); }
-  static simdutf_really_inline simd8<T> load(const T values[32]) {
-    return __lasx_xvld(reinterpret_cast<const __m256i *>(values), 0);
-  }
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
-                                                  T v5, T v6, T v7, T v8, T v9,
-                                                  T v10, T v11, T v12, T v13,
-                                                  T v14, T v15) {
-    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
-                    v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
-                    v12, v13, v14, v15);
-  }
-
-  simdutf_really_inline base8_numeric() : base8<T>() {}
-  simdutf_really_inline base8_numeric(const __m256i _value)
-      : base8<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[32]) const {
-    return __lasx_xvst(this->value, reinterpret_cast<__m256i *>(dst), 0);
-  }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
-    return __lasx_xvadd_b(this->value, other);
-  }
-  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
-    return __lasx_xvsub_b(this->value, other);
-  }
-  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
-    *this = *this + other;
-    return *static_cast<simd8<T> *>(this);
-  }
-  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
-    *this = *this - other;
-    return *static_cast<simd8<T> *>(this);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
-
-  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
-  // for out of range values)
-  template <typename L>
-  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
-    __m256i origin = __lasx_xvand_v(this->value, __lasx_xvldi(0x1f));
-    return __lasx_xvshuf_b(__lasx_xvldi(0), lookup_table, origin);
-  }
-
-  template <typename L>
-  simdutf_really_inline simd8<L>
-  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
-            L replace5, L replace6, L replace7, L replace8, L replace9,
-            L replace10, L replace11, L replace12, L replace13, L replace14,
-            L replace15) const {
-    return lookup_16(simd8<L>::repeat_16(
-        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
-        replace7, replace8, replace9, replace10, replace11, replace12,
-        replace13, replace14, replace15));
-  }
-};
-
-// Signed bytes
-template <> struct simd8<int8_t> : base8_numeric<int8_t> {
-  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
-  simdutf_really_inline simd8(const __m256i _value)
-      : base8_numeric<int8_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const int8_t values[32]) : simd8(load(values)) {}
-  simdutf_really_inline operator simd8<uint8_t>() const;
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
-        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
-        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
-        int8_t v30, int8_t v31)
-      : simd8((__m256i)v32i8{v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
-                             v8,  v9,  v10, v11, v12, v13, v14, v15,
-                             v16, v17, v18, v19, v20, v21, v22, v23,
-                             v24, v25, v26, v27, v28, v29, v30, v31}) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<int8_t>
-  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
-            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
-            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
-    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                         v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                         v10, v11, v12, v13, v14, v15);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
-    if (__lasx_xbnz_v(ascii_mask))
-      return false;
-    return true;
-  }
-  // Order-sensitive comparisons
-  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
-    return __lasx_xvmax_b(this->value, other);
-  }
-  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
-    return __lasx_xvmin_b(this->value, other);
-  }
-  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
-    return __lasx_xvslt_b(other, this->value);
-  }
-  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
-    return __lasx_xvslt_b(this->value, other);
-  }
-};
-
-// Unsigned bytes
-template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
-  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
-  simdutf_really_inline simd8(const __m256i _value)
-      : base8_numeric<uint8_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd8(const uint8_t values[32]) : simd8(load(values)) {}
-  // Member-by-member initialization
-  simdutf_really_inline
-  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
-        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
-        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
-        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
-        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
-        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
-        uint8_t v31)
-      : simd8((__m256i)v32u8{v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
-                             v8,  v9,  v10, v11, v12, v13, v14, v15,
-                             v16, v17, v18, v19, v20, v21, v22, v23,
-                             v24, v25, v26, v27, v28, v29, v30, v31}) {}
-  // Repeat 16 values as many times as necessary (usually for lookup tables)
-  simdutf_really_inline static simd8<uint8_t>
-  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
-            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
-            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
-            uint8_t v15) {
-    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
-                          v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
-                          v10, v11, v12, v13, v14, v15);
-  }
-
-  // Saturated math
-  simdutf_really_inline simd8<uint8_t>
-  saturating_add(const simd8<uint8_t> other) const {
-    return __lasx_xvsadd_bu(this->value, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  saturating_sub(const simd8<uint8_t> other) const {
-    return __lasx_xvssub_bu(this->value, other);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd8<uint8_t>
-  max_val(const simd8<uint8_t> other) const {
-    return __lasx_xvmax_bu(*this, other);
-  }
-  simdutf_really_inline simd8<uint8_t>
-  min_val(const simd8<uint8_t> other) const {
-    return __lasx_xvmin_bu(*this, other);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  gt_bits(const simd8<uint8_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd8<uint8_t>
-  lt_bits(const simd8<uint8_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<=(const simd8<uint8_t> other) const {
-    return __lasx_xvsle_bu(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>=(const simd8<uint8_t> other) const {
-    return __lasx_xvsle_bu(other, *this);
-  }
-  simdutf_really_inline simd8<bool>
-  operator>(const simd8<uint8_t> other) const {
-    return __lasx_xvslt_bu(*this, other);
-  }
-  simdutf_really_inline simd8<bool>
-  operator<(const simd8<uint8_t> other) const {
-    return __lasx_xvslt_bu(other, *this);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd8<bool> bits_not_set() const {
-    return *this == uint8_t(0);
-  }
-  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-  simdutf_really_inline bool is_ascii() const {
-    __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
-    if (__lasx_xbnz_v(ascii_mask))
-      return false;
-    return true;
-  }
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    if (__lasx_xbnz_v(this->value))
-      return true;
-    return false;
-  }
-  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
-    return (*this & bits).any_bits_set_anywhere();
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
-    return __lasx_xvsrli_b(this->value, N);
-  }
-  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
-    return __lasx_xvslli_b(this->value, N);
-  }
-};
-simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
-  return this->value;
-}
-
-template <typename T> struct simd8x64 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
-  static_assert(NUM_CHUNKS == 2,
-                "LASX kernel should use two registers per 64-byte block.");
-  simd8<T> chunks[NUM_CHUNKS];
-
-  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
-  simd8x64<T> &
-  operator=(const simd8<T> other) = delete; // no assignment allowed
-  simd8x64() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
-      : chunks{chunk0, chunk1} {}
-  simdutf_really_inline simd8x64(const T *ptr)
-      : chunks{simd8<T>::load(ptr),
-               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r_hi = this->chunks[1].to_bitmask();
-    return r_lo | (r_hi << 32);
-  }
-
-  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
-    this->chunks[0] |= other.chunks[0];
-    this->chunks[1] |= other.chunks[1];
-    return *this;
-  }
-
-  simdutf_really_inline simd8<T> reduce_or() const {
-    return this->chunks[0] | this->chunks[1];
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  template <endianness endian>
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 0);
-    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
-                                                          sizeof(simd8<T>) * 1);
-  }
-
-  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
-    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
-  }
-
-  simdutf_really_inline simd8x64<T> bit_or(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
-    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
-                          this->chunks[1] == other.chunks[1])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-
-    return simd8x64<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd8<T> mask_low = simd8<T>::splat(low);
-    const simd8<T> mask_high = simd8<T>::splat(high);
-    return simd8x64<bool>(
-               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
-               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t gt(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq(const T m) const {
-    const simd8<T> mask = simd8<T>::splat(m);
-    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
-    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
-    return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
-                          (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
-        .to_bitmask();
-  }
-}; // struct simd8x64<T>
-
-/* begin file src/simdutf/lasx/simd16-inl.h */
-template <typename T> struct simd16;
-
-template <typename T, typename Mask = simd16<bool>>
-struct base16 : base<simd16<T>> {
-  using bitmask_type = uint32_t;
-
-  simdutf_really_inline base16() : base<simd16<T>>() {}
-  simdutf_really_inline base16(const __m256i _value)
-      : base<simd16<T>>(_value) {}
-  template <typename Pointer>
-  simdutf_really_inline base16(const Pointer *ptr)
-      : base16(__lasx_xvld(reinterpret_cast<const __m256i *>(ptr), 0)) {}
-  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
-                                               const simd16<T> rhs) {
-    return __lasx_xvseq_h(lhs.value, rhs.value);
-  }
-
-  /// the size of vector in bytes
-  static const int SIZE = sizeof(base<simd16<T>>::value);
-
-  /// the number of elements of type T a vector can hold
-  static const int ELEMENTS = SIZE / sizeof(T);
-
-  template <int N = 1>
-  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
-    if (!N)
-      return this->value;
-
-    __m256i zero = __lasx_xvldi(0);
-    __m256i result, shuf;
-    if (N < 8) {
-      shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);
-
-      result = __lasx_xvshuf_b(
-          __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
-          shuf);
-      __m256i srl_prev = __lasx_xvbsrl_v(
-          __lasx_xvpermi_q(zero, prev_chunk, 0b00110001), (16 - N * 2));
-      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
-      result = __lasx_xvbitsel_v(result, srl_prev, mask);
-
-      return result;
-    } else if (N == 8) {
-      return __lasx_xvpermi_q(this->value, prev_chunk, 0b00100001);
-    } else {
-      __m256i sll_value = __lasx_xvbsll_v(
-          __lasx_xvpermi_q(zero, this->value, 0b00000011), (N * 2 - 16));
-      __m256i mask = __lasx_xvld(bitsel_mask_table[N * 2], 0);
-      shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);
-      result =
-          __lasx_xvshuf_b(__lasx_xvpermi_q(prev_chunk, prev_chunk, 0b00000001),
-                          prev_chunk, shuf);
-      result = __lasx_xvbitsel_v(sll_value, result, mask);
-      return result;
-    }
-  }
-};
-
-// SIMD byte mask type (returned by things like eq and gt)
-template <> struct simd16<bool> : base16<bool> {
-  static simdutf_really_inline simd16<bool> splat(bool _value) {
-    return __lasx_xvreplgr2vr_h(uint8_t(-(!!_value)));
-  }
-
-  simdutf_really_inline simd16() : base16() {}
-  simdutf_really_inline simd16(const __m256i _value) : base16<bool>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
-
-  simdutf_really_inline bitmask_type to_bitmask() const {
-    __m256i mask = __lasx_xvmsknz_b(this->value);
-    bitmask_type mask0 = __lasx_xvpickve2gr_wu(mask, 0);
-    bitmask_type mask1 = __lasx_xvpickve2gr_wu(mask, 4);
-    return (mask0 | (mask1 << 16));
-  }
-  simdutf_really_inline bool any() const {
-    if (__lasx_xbz_v(this->value))
-      return false;
-    return true;
-  }
-  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
-};
-
-template <typename T> struct base16_numeric : base16<T> {
-  static simdutf_really_inline simd16<T> splat(T _value) {
-    return __lasx_xvreplgr2vr_h((uint16_t)_value);
-  }
-  static simdutf_really_inline simd16<T> zero() { return __lasx_xvldi(0); }
-  static simdutf_really_inline simd16<T> load(const T values[8]) {
-    return __lasx_xvld(reinterpret_cast<const __m256i *>(values), 0);
-  }
-
-  simdutf_really_inline base16_numeric() : base16<T>() {}
-  simdutf_really_inline base16_numeric(const __m256i _value)
-      : base16<T>(_value) {}
-
-  // Store to array
-  simdutf_really_inline void store(T dst[8]) const {
-    return __lasx_xvst(this->value, reinterpret_cast<__m256i *>(dst), 0);
-  }
-
-  // Override to distinguish from bool version
-  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }
-
-  // Addition/subtraction are the same for signed and unsigned
-  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
-    return __lasx_xvadd_h(*this, other);
-  }
-  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
-    return __lasx_xvsub_h(*this, other);
-  }
-  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
-    *this = *this + other;
-    return *static_cast<simd16<T> *>(this);
-  }
-  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
-    *this = *this - other;
-    return *static_cast<simd16<T> *>(this);
-  }
-};
-
-// Signed code units
-template <> struct simd16<int16_t> : base16_numeric<int16_t> {
-  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
-  simdutf_really_inline simd16(const __m256i _value)
-      : base16_numeric<int16_t>(_value) {}
-  // Splat constructor
-  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
-  // Order-sensitive comparisons
-  simdutf_really_inline simd16<int16_t>
-  max_val(const simd16<int16_t> other) const {
-    return __lasx_xvmax_h(*this, other);
-  }
-  simdutf_really_inline simd16<int16_t>
-  min_val(const simd16<int16_t> other) const {
-    return __lasx_xvmin_h(*this, other);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<int16_t> other) const {
-    return __lasx_xvsle_h(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<int16_t> other) const {
-    return __lasx_xvslt_h(this->value, other.value);
-  }
-};
-
-// Unsigned code units
-template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
-  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
-  simdutf_really_inline simd16(const __m256i _value)
-      : base16_numeric<uint16_t>(_value) {}
-
-  // Splat constructor
-  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
-  // Array constructor
-  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
-  simdutf_really_inline simd16(const char16_t *values)
-      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
-
-  // Saturated math
-  simdutf_really_inline simd16<uint16_t>
-  saturating_add(const simd16<uint16_t> other) const {
-    return __lasx_xvsadd_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  saturating_sub(const simd16<uint16_t> other) const {
-    return __lasx_xvssub_hu(this->value, other.value);
-  }
-
-  // Order-specific operations
-  simdutf_really_inline simd16<uint16_t>
-  max_val(const simd16<uint16_t> other) const {
-    return __lasx_xvmax_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<uint16_t>
-  min_val(const simd16<uint16_t> other) const {
-    return __lasx_xvmin_hu(this->value, other.value);
-  }
-  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  gt_bits(const simd16<uint16_t> other) const {
-    return this->saturating_sub(other);
-  }
-  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
-  simdutf_really_inline simd16<uint16_t>
-  lt_bits(const simd16<uint16_t> other) const {
-    return other.saturating_sub(*this);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<=(const simd16<uint16_t> other) const {
-    return __lasx_xvsle_hu(this->value, other.value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>=(const simd16<uint16_t> other) const {
-    return __lasx_xvsle_hu(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator>(const simd16<uint16_t> other) const {
-    return __lasx_xvslt_hu(other.value, this->value);
-  }
-  simdutf_really_inline simd16<bool>
-  operator<(const simd16<uint16_t> other) const {
-    return __lasx_xvslt_hu(this->value, other.value);
-  }
-
-  // Bit-specific operations
-  simdutf_really_inline simd16<bool> bits_not_set() const {
-    return *this == uint16_t(0);
-  }
-  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
-    return (*this & bits).bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set() const {
-    return ~this->bits_not_set();
-  }
-  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
-    return ~this->bits_not_set(bits);
-  }
-
-  simdutf_really_inline bool any_bits_set_anywhere() const {
-    if (__lasx_xbnz_v(this->value))
-      return true;
-    return false;
-  }
-  simdutf_really_inline bool
-  any_bits_set_anywhere(simd16<uint16_t> bits) const {
-    return (*this & bits).any_bits_set_anywhere();
-  }
-
-  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
-    return simd16<uint16_t>(__lasx_xvsrli_h(this->value, N));
-  }
-  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
-    return simd16<uint16_t>(__lasx_xvslli_h(this->value, N));
-  }
-
-  // Change the endianness
-  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
-    return __lasx_xvshuf4i_b(this->value, 0b10110001);
-  }
-
-  // Pack with the unsigned saturation of two uint16_t code units into single
-  // uint8_t vector
-  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
-                                                   const simd16<uint16_t> &v1) {
-    return __lasx_xvpermi_d(__lasx_xvssrlni_bu_h(v1.value, v0.value, 0),
-                            0b11011000);
-  }
-};
-
-template <typename T> struct simd16x32 {
-  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
-  static_assert(NUM_CHUNKS == 2,
-                "LASX kernel should use two registers per 64-byte block.");
-  simd16<T> chunks[NUM_CHUNKS];
-
-  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
-  simd16x32<T> &
-  operator=(const simd16<T> other) = delete; // no assignment allowed
-  simd16x32() = delete;                      // no default constructor allowed
-
-  simdutf_really_inline simd16x32(const simd16<T> chunk0,
-                                  const simd16<T> chunk1)
-      : chunks{chunk0, chunk1} {}
-  simdutf_really_inline simd16x32(const T *ptr)
-      : chunks{simd16<T>::load(ptr),
-               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T))} {}
-
-  simdutf_really_inline void store(T *ptr) const {
-    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
-    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
-  }
-
-  simdutf_really_inline uint64_t to_bitmask() const {
-    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
-    uint64_t r_hi = this->chunks[1].to_bitmask();
-    return r_lo | (r_hi << 32);
-  }
-
-  simdutf_really_inline simd16<T> reduce_or() const {
-    return this->chunks[0] | this->chunks[1];
-  }
-
-  simdutf_really_inline bool is_ascii() const {
-    return this->reduce_or().is_ascii();
-  }
-
-  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
-    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
-    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
-  }
-
-  simdutf_really_inline simd16x32<T> bit_or(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
-  }
-
-  simdutf_really_inline void swap_bytes() {
-    this->chunks[0] = this->chunks[0].swap_bytes();
-    this->chunks[1] = this->chunks[1].swap_bytes();
-  }
-
-  simdutf_really_inline uint64_t eq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
-    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
-                           this->chunks[1] == other.chunks[1])
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t lteq(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
-        .to_bitmask();
-  }
-
-  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(low);
-    const simd16<T> mask_high = simd16<T>::splat(high);
-
-    return simd16x32<bool>(
-               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
-               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
-    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
-    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
-    return simd16x32<bool>(
-               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
-               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
-        .to_bitmask();
-  }
-  simdutf_really_inline uint64_t lt(const T m) const {
-    const simd16<T> mask = simd16<T>::splat(m);
-    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
-        .to_bitmask();
-  }
-}; // struct simd16x32<T>
-/* end file src/simdutf/lasx/simd16-inl.h */
-} // namespace simd
-} // unnamed namespace
-} // namespace lasx
-} // namespace simdutf
-
-#endif // SIMDUTF_LASX_SIMD_H
-/* end file src/simdutf/lasx/simd.h */
-
-/* begin file src/simdutf/lasx/end.h */
-/* end file src/simdutf/lasx/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_LASX
-
-#endif // SIMDUTF_LASX_H
-/* end file src/simdutf/lasx.h */
-/* begin file src/simdutf/fallback.h */
-#ifndef SIMDUTF_FALLBACK_H
-#define SIMDUTF_FALLBACK_H
-
-
-// Note that fallback.h is always imported last.
-
-// Default Fallback to on unless a builtin implementation has already been
-// selected.
-#ifndef SIMDUTF_IMPLEMENTATION_FALLBACK
-  #if SIMDUTF_CAN_ALWAYS_RUN_ARM64 || SIMDUTF_CAN_ALWAYS_RUN_ICELAKE ||        \
-      SIMDUTF_CAN_ALWAYS_RUN_HASWELL || SIMDUTF_CAN_ALWAYS_RUN_WESTMERE ||     \
-      SIMDUTF_CAN_ALWAYS_RUN_PPC64 || SIMDUTF_CAN_ALWAYS_RUN_RVV ||            \
-      SIMDUTF_CAN_ALWAYS_RUN_LSX || SIMDUTF_CAN_ALWAYS_RUN_LASX
-    #define SIMDUTF_IMPLEMENTATION_FALLBACK 0
-  #else
-    #define SIMDUTF_IMPLEMENTATION_FALLBACK 1
-  #endif
-#endif
-
-#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
-
-#if SIMDUTF_IMPLEMENTATION_FALLBACK
-
-namespace simdutf {
-/**
- * Fallback implementation (runs on any machine).
- */
-namespace fallback {} // namespace fallback
-} // namespace simdutf
-
-/* begin file src/simdutf/fallback/implementation.h */
-#ifndef SIMDUTF_FALLBACK_IMPLEMENTATION_H
-#define SIMDUTF_FALLBACK_IMPLEMENTATION_H
-
-
-namespace simdutf {
-namespace fallback {
-
-namespace {
-using namespace simdutf;
-}
-
-class implementation final : public simdutf::implementation {
-public:
-  simdutf_really_inline implementation()
-      : simdutf::implementation("fallback", "Generic fallback implementation",
-                                0) {}
-  simdutf_warn_unused int detect_encodings(const char *input,
-                                           size_t length) const noexcept final;
-  simdutf_warn_unused bool validate_utf8(const char *buf,
-                                         size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_ascii(const char *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result
-  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                            size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                          size_t len) const noexcept final;
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *buf, size_t len, char *utf8_output) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len, char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
-                                  char *latin1_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final;
-  simdutf_warn_unused result
-  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
-                                      char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
-                                char *latin1_output) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
-                           char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
-                                 char16_t *utf16_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
-                           char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  simdutf_warn_unused size_t
-  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
-                                 char32_t *utf32_buffer) const noexcept final;
-  void change_endianness_utf16(const char16_t *buf, size_t length,
-                               char16_t *output) const noexcept final;
-  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
-                                           size_t length) const noexcept;
-  simdutf_warn_unused size_t count_utf8(const char *buf,
-                                        size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t length) const noexcept;
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept;
-  simdutf_warn_unused result base64_to_binary(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options) const noexcept;
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept;
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_options =
-          last_chunk_handling_options::loose) const noexcept;
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept;
-};
-} // namespace fallback
-} // namespace simdutf
-
-#endif // SIMDUTF_FALLBACK_IMPLEMENTATION_H
-/* end file src/simdutf/fallback/implementation.h */
-
-/* begin file src/simdutf/fallback/begin.h */
-// redefining SIMDUTF_IMPLEMENTATION to "fallback"
-// #define SIMDUTF_IMPLEMENTATION fallback
-/* end file src/simdutf/fallback/begin.h */
-
-  // Declarations
-/* begin file src/simdutf/fallback/bitmanipulation.h */
-#ifndef SIMDUTF_FALLBACK_BITMANIPULATION_H
-#define SIMDUTF_FALLBACK_BITMANIPULATION_H
-
-#include <limits>
-
-namespace simdutf {
-namespace fallback {
-namespace {} // unnamed namespace
-} // namespace fallback
-} // namespace simdutf
-
-#endif // SIMDUTF_FALLBACK_BITMANIPULATION_H
-/* end file src/simdutf/fallback/bitmanipulation.h */
-
-/* begin file src/simdutf/fallback/end.h */
-/* end file src/simdutf/fallback/end.h */
-
-#endif // SIMDUTF_IMPLEMENTATION_FALLBACK
-#endif // SIMDUTF_FALLBACK_H
-/* end file src/simdutf/fallback.h */
-
-/* begin file src/scalar/utf8.h */
-#ifndef SIMDUTF_UTF8_H
-#define SIMDUTF_UTF8_H
-
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8 {
-#if SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_RVV
-// only used by the fallback kernel.
-// credit: based on code from Google Fuchsia (Apache Licensed)
-inline simdutf_warn_unused bool validate(const char *buf, size_t len) noexcept {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  uint64_t pos = 0;
-  uint32_t code_point = 0;
-  while (pos < len) {
-    // check of the next 16 bytes are ascii.
-    uint64_t next_pos = pos + 16;
-    if (next_pos <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      std::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        pos = next_pos;
-        continue;
-      }
-    }
-    unsigned char byte = data[pos];
-
-    while (byte < 0b10000000) {
-      if (++pos == len) {
-        return true;
-      }
-      byte = data[pos];
-    }
-
-    if ((byte & 0b11100000) == 0b11000000) {
-      next_pos = pos + 2;
-      if (next_pos > len) {
-        return false;
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      // range check
-      code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if ((code_point < 0x80) || (0x7ff < code_point)) {
-        return false;
-      }
-    } else if ((byte & 0b11110000) == 0b11100000) {
-      next_pos = pos + 3;
-      if (next_pos > len) {
-        return false;
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      // range check
-      code_point = (byte & 0b00001111) << 12 |
-                   (data[pos + 1] & 0b00111111) << 6 |
-                   (data[pos + 2] & 0b00111111);
-      if ((code_point < 0x800) || (0xffff < code_point) ||
-          (0xd7ff < code_point && code_point < 0xe000)) {
-        return false;
-      }
-    } else if ((byte & 0b11111000) == 0b11110000) { // 0b11110000
-      next_pos = pos + 4;
-      if (next_pos > len) {
-        return false;
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return false;
-      }
-      // range check
-      code_point =
-          (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 |
-          (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff || 0x10ffff < code_point) {
-        return false;
-      }
-    } else {
-      // we may have a continuation
-      return false;
-    }
-    pos = next_pos;
-  }
-  return true;
-}
-#endif
-
-inline simdutf_warn_unused result validate_with_errors(const char *buf,
-                                                       size_t len) noexcept {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  uint32_t code_point = 0;
-  while (pos < len) {
-    // check of the next 16 bytes are ascii.
-    size_t next_pos = pos + 16;
-    if (next_pos <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      std::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        pos = next_pos;
-        continue;
-      }
-    }
-    unsigned char byte = data[pos];
-
-    while (byte < 0b10000000) {
-      if (++pos == len) {
-        return result(error_code::SUCCESS, len);
-      }
-      byte = data[pos];
-    }
-
-    if ((byte & 0b11100000) == 0b11000000) {
-      next_pos = pos + 2;
-      if (next_pos > len) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if ((code_point < 0x80) || (0x7ff < code_point)) {
-        return result(error_code::OVERLONG, pos);
-      }
-    } else if ((byte & 0b11110000) == 0b11100000) {
-      next_pos = pos + 3;
-      if (next_pos > len) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      code_point = (byte & 0b00001111) << 12 |
-                   (data[pos + 1] & 0b00111111) << 6 |
-                   (data[pos + 2] & 0b00111111);
-      if ((code_point < 0x800) || (0xffff < code_point)) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0xd7ff < code_point && code_point < 0xe000) {
-        return result(error_code::SURROGATE, pos);
-      }
-    } else if ((byte & 0b11111000) == 0b11110000) { // 0b11110000
-      next_pos = pos + 4;
-      if (next_pos > len) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      code_point =
-          (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 |
-          (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0x10ffff < code_point) {
-        return result(error_code::TOO_LARGE, pos);
-      }
-    } else {
-      // we either have too many continuation bytes or an invalid leading byte
-      if ((byte & 0b11000000) == 0b10000000) {
-        return result(error_code::TOO_LONG, pos);
-      } else {
-        return result(error_code::HEADER_BITS, pos);
-      }
-    }
-    pos = next_pos;
-  }
-  return result(error_code::SUCCESS, len);
-}
-
-// Finds the previous leading byte starting backward from buf and validates with
-// errors from there Used to pinpoint the location of an error when an invalid
-// chunk is detected We assume that the stream starts with a leading byte, and
-// to check that it is the case, we ask that you pass a pointer to the start of
-// the stream (start).
-inline simdutf_warn_unused result rewind_and_validate_with_errors(
-    const char *start, const char *buf, size_t len) noexcept {
-  // First check that we start with a leading byte
-  if ((*start & 0b11000000) == 0b10000000) {
-    return result(error_code::TOO_LONG, 0);
-  }
-  size_t extra_len{0};
-  // A leading byte cannot be further than 4 bytes away
-  for (int i = 0; i < 5; i++) {
-    unsigned char byte = *buf;
-    if ((byte & 0b11000000) != 0b10000000) {
-      break;
-    } else {
-      buf--;
-      extra_len++;
-    }
-  }
-
-  result res = validate_with_errors(buf, len + extra_len);
-  res.count -= extra_len;
-  return res;
-}
-
-inline size_t count_code_points(const char *buf, size_t len) {
-  const int8_t *p = reinterpret_cast<const int8_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    // -65 is 0b10111111, anything larger in two-complement's should start a new
-    // code point.
-    if (p[i] > -65) {
-      counter++;
-    }
-  }
-  return counter;
-}
-
-inline size_t utf16_length_from_utf8(const char *buf, size_t len) {
-  const int8_t *p = reinterpret_cast<const int8_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    if (p[i] > -65) {
-      counter++;
-    }
-    if (uint8_t(p[i]) >= 240) {
-      counter++;
-    }
-  }
-  return counter;
-}
-
-simdutf_warn_unused inline size_t trim_partial_utf8(const char *input,
-                                                    size_t length) {
-  if (length < 3) {
-    switch (length) {
-    case 2:
-      if (uint8_t(input[length - 1]) >= 0xc0) {
-        return length - 1;
-      } // 2-, 3- and 4-byte characters with only 1 byte left
-      if (uint8_t(input[length - 2]) >= 0xe0) {
-        return length - 2;
-      } // 3- and 4-byte characters with only 2 bytes left
-      return length;
-    case 1:
-      if (uint8_t(input[length - 1]) >= 0xc0) {
-        return length - 1;
-      } // 2-, 3- and 4-byte characters with only 1 byte left
-      return length;
-    case 0:
-      return length;
-    }
-  }
-  if (uint8_t(input[length - 1]) >= 0xc0) {
-    return length - 1;
-  } // 2-, 3- and 4-byte characters with only 1 byte left
-  if (uint8_t(input[length - 2]) >= 0xe0) {
-    return length - 2;
-  } // 3- and 4-byte characters with only 1 byte left
-  if (uint8_t(input[length - 3]) >= 0xf0) {
-    return length - 3;
-  } // 4-byte characters with only 3 bytes left
-  return length;
-}
-
-} // namespace utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/utf8.h */
-/* begin file src/scalar/utf16.h */
-#ifndef SIMDUTF_UTF16_H
-#define SIMDUTF_UTF16_H
-
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16 {
-
-inline simdutf_warn_unused uint16_t swap_bytes(const uint16_t word) {
-  return uint16_t((word >> 8) | (word << 8));
-}
-
-template <endianness big_endian>
-inline simdutf_warn_unused bool validate(const char16_t *buf,
-                                         size_t len) noexcept {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  uint64_t pos = 0;
-  while (pos < len) {
-    uint16_t word =
-        !match_system(big_endian) ? swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xF800) == 0xD800) {
-      if (pos + 1 >= len) {
-        return false;
-      }
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return false;
-      }
-      uint16_t next_word =
-          !match_system(big_endian) ? swap_bytes(data[pos + 1]) : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return false;
-      }
-      pos += 2;
-    } else {
-      pos++;
-    }
-  }
-  return true;
-}
-
-template <endianness big_endian>
-inline simdutf_warn_unused result validate_with_errors(const char16_t *buf,
-                                                       size_t len) noexcept {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  while (pos < len) {
-    uint16_t word =
-        !match_system(big_endian) ? swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xF800) == 0xD800) {
-      if (pos + 1 >= len) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint16_t next_word =
-          !match_system(big_endian) ? swap_bytes(data[pos + 1]) : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      pos += 2;
-    } else {
-      pos++;
-    }
-  }
-  return result(error_code::SUCCESS, pos);
-}
-
-template <endianness big_endian>
-inline size_t count_code_points(const char16_t *buf, size_t len) {
-  // We are not BOM aware.
-  const uint16_t *p = reinterpret_cast<const uint16_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    uint16_t word = !match_system(big_endian) ? swap_bytes(p[i]) : p[i];
-    counter += ((word & 0xFC00) != 0xDC00);
-  }
-  return counter;
-}
-
-template <endianness big_endian>
-inline size_t utf8_length_from_utf16(const char16_t *buf, size_t len) {
-  // We are not BOM aware.
-  const uint16_t *p = reinterpret_cast<const uint16_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    uint16_t word = !match_system(big_endian) ? swap_bytes(p[i]) : p[i];
-    counter++; // ASCII
-    counter += static_cast<size_t>(
-        word >
-        0x7F); // non-ASCII is at least 2 bytes, surrogates are 2*2 == 4 bytes
-    counter += static_cast<size_t>((word > 0x7FF && word <= 0xD7FF) ||
-                                   (word >= 0xE000)); // three-byte
-  }
-  return counter;
-}
-
-template <endianness big_endian>
-inline size_t utf32_length_from_utf16(const char16_t *buf, size_t len) {
-  // We are not BOM aware.
-  const uint16_t *p = reinterpret_cast<const uint16_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    uint16_t word = !match_system(big_endian) ? swap_bytes(p[i]) : p[i];
-    counter += ((word & 0xFC00) != 0xDC00);
-  }
-  return counter;
-}
-
-inline size_t latin1_length_from_utf16(size_t len) { return len; }
-
-simdutf_really_inline void change_endianness_utf16(const char16_t *in,
-                                                   size_t size, char16_t *out) {
-  const uint16_t *input = reinterpret_cast<const uint16_t *>(in);
-  uint16_t *output = reinterpret_cast<uint16_t *>(out);
-  for (size_t i = 0; i < size; i++) {
-    *output++ = uint16_t(input[i] >> 8 | input[i] << 8);
-  }
-}
-
-template <endianness big_endian>
-simdutf_warn_unused inline size_t trim_partial_utf16(const char16_t *input,
-                                                     size_t length) {
-  if (length <= 1) {
-    return length;
-  }
-  uint16_t last_word = uint16_t(input[length - 1]);
-  last_word = !match_system(big_endian) ? swap_bytes(last_word) : last_word;
-  length -= ((last_word & 0xFC00) == 0xD800);
-  return length;
-}
-
-} // namespace utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/utf16.h */
-/* begin file src/scalar/utf32.h */
-#ifndef SIMDUTF_UTF32_H
-#define SIMDUTF_UTF32_H
-
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32 {
-
-inline simdutf_warn_unused bool validate(const char32_t *buf,
-                                         size_t len) noexcept {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  uint64_t pos = 0;
-  for (; pos < len; pos++) {
-    uint32_t word = data[pos];
-    if (word > 0x10FFFF || (word >= 0xD800 && word <= 0xDFFF)) {
-      return false;
-    }
-  }
-  return true;
-}
-
-inline simdutf_warn_unused result validate_with_errors(const char32_t *buf,
-                                                       size_t len) noexcept {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  for (; pos < len; pos++) {
-    uint32_t word = data[pos];
-    if (word > 0x10FFFF) {
-      return result(error_code::TOO_LARGE, pos);
-    }
-    if (word >= 0xD800 && word <= 0xDFFF) {
-      return result(error_code::SURROGATE, pos);
-    }
-  }
-  return result(error_code::SUCCESS, pos);
-}
-
-inline size_t utf8_length_from_utf32(const char32_t *buf, size_t len) {
-  // We are not BOM aware.
-  const uint32_t *p = reinterpret_cast<const uint32_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    // credit: @ttsugriy  for the vectorizable approach
-    counter++;                                     // ASCII
-    counter += static_cast<size_t>(p[i] > 0x7F);   // two-byte
-    counter += static_cast<size_t>(p[i] > 0x7FF);  // three-byte
-    counter += static_cast<size_t>(p[i] > 0xFFFF); // four-bytes
-  }
-  return counter;
-}
-
-inline size_t utf16_length_from_utf32(const char32_t *buf, size_t len) {
-  // We are not BOM aware.
-  const uint32_t *p = reinterpret_cast<const uint32_t *>(buf);
-  size_t counter{0};
-  for (size_t i = 0; i < len; i++) {
-    counter++;                                     // non-surrogate word
-    counter += static_cast<size_t>(p[i] > 0xFFFF); // surrogate pair
-  }
-  return counter;
-}
-
-inline size_t latin1_length_from_utf32(size_t len) {
-  // We are not BOM aware.
-  return len; // a utf32 codepoint will always represent 1 latin1 character
-}
-
-inline simdutf_warn_unused uint32_t swap_bytes(const uint32_t word) {
-  return ((word >> 24) & 0xff) |      // move byte 3 to byte 0
-         ((word << 8) & 0xff0000) |   // move byte 1 to byte 2
-         ((word >> 8) & 0xff00) |     // move byte 2 to byte 1
-         ((word << 24) & 0xff000000); // byte 0 to byte 3
-}
-
-} // namespace utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/utf32.h */
-/* begin file src/scalar/base64.h */
-#ifndef SIMDUTF_BASE64_H
-#define SIMDUTF_BASE64_H
-
-#include <cstddef>
-#include <cstdint>
-#include <cstring>
-#include <iostream>
-
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace base64 {
-
-// This function is not expected to be fast. Do not use in long loops.
-template <class char_type> bool is_ascii_white_space(char_type c) {
-  return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f';
-}
-
-template <class char_type> bool is_ascii_white_space_or_padding(char_type c) {
-  return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' ||
-         c == '=';
-}
-
-template <class char_type> bool is_eight_byte(char_type c) {
-  if (sizeof(char_type) == 1) {
-    return true;
-  }
-  return uint8_t(c) == c;
-}
-
-// Returns true upon success. The destination buffer must be large enough.
-// This functions assumes that the padding (=) has been removed.
-template <class char_type>
-full_result
-base64_tail_decode(char *dst, const char_type *src, size_t length,
-                   size_t padded_characters, // number of padding characters
-                                             // '=', typically 0, 1, 2.
-                   base64_options options,
-                   last_chunk_handling_options last_chunk_options) {
-  // This looks like 5 branches, but we expect the compiler to resolve this to a
-  // single branch:
-  const uint8_t *to_base64 = (options & base64_url)
-                                 ? tables::base64::to_base64_url_value
-                                 : tables::base64::to_base64_value;
-  const uint32_t *d0 = (options & base64_url)
-                           ? tables::base64::base64_url::d0
-                           : tables::base64::base64_default::d0;
-  const uint32_t *d1 = (options & base64_url)
-                           ? tables::base64::base64_url::d1
-                           : tables::base64::base64_default::d1;
-  const uint32_t *d2 = (options & base64_url)
-                           ? tables::base64::base64_url::d2
-                           : tables::base64::base64_default::d2;
-  const uint32_t *d3 = (options & base64_url)
-                           ? tables::base64::base64_url::d3
-                           : tables::base64::base64_default::d3;
-
-  const char_type *srcend = src + length;
-  const char_type *srcinit = src;
-  const char *dstinit = dst;
-
-  uint32_t x;
-  size_t idx;
-  uint8_t buffer[4];
-  while (true) {
-    while (src + 4 <= srcend && is_eight_byte(src[0]) &&
-           is_eight_byte(src[1]) && is_eight_byte(src[2]) &&
-           is_eight_byte(src[3]) &&
-           (x = d0[uint8_t(src[0])] | d1[uint8_t(src[1])] |
-                d2[uint8_t(src[2])] | d3[uint8_t(src[3])]) < 0x01FFFFFF) {
-      if (match_system(endianness::BIG)) {
-        x = scalar::utf32::swap_bytes(x);
-      }
-      std::memcpy(dst, &x, 3); // optimization opportunity: copy 4 bytes
-      dst += 3;
-      src += 4;
-    }
-    idx = 0;
-    // we need at least four characters.
-    while (idx < 4 && src < srcend) {
-      char_type c = *src;
-      uint8_t code = to_base64[uint8_t(c)];
-      buffer[idx] = uint8_t(code);
-      if (is_eight_byte(c) && code <= 63) {
-        idx++;
-      } else if (code > 64 || !scalar::base64::is_eight_byte(c)) {
-        return {INVALID_BASE64_CHARACTER, size_t(src - srcinit),
-                size_t(dst - dstinit)};
-      } else {
-        // We have a space or a newline. We ignore it.
-      }
-      src++;
-    }
-    if (idx != 4) {
-      if (last_chunk_options == last_chunk_handling_options::strict &&
-          (idx != 1) && ((idx + padded_characters) & 3) != 0) {
-        // The partial chunk was at src - idx
-        return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
-                size_t(dst - dstinit)};
-      } else if (last_chunk_options ==
-                     last_chunk_handling_options::stop_before_partial &&
-                 (idx != 1) && ((idx + padded_characters) & 3) != 0) {
-        // Rewind src to before partial chunk
-        src -= idx;
-        return {SUCCESS, size_t(src - srcinit), size_t(dst - dstinit)};
-      } else {
-        if (idx == 2) {
-          uint32_t triple =
-              (uint32_t(buffer[0]) << 3 * 6) + (uint32_t(buffer[1]) << 2 * 6);
-          if ((last_chunk_options == last_chunk_handling_options::strict) &&
-              (triple & 0xffff)) {
-            return {BASE64_EXTRA_BITS, size_t(src - srcinit),
-                    size_t(dst - dstinit)};
-          }
-          if (match_system(endianness::BIG)) {
-            triple <<= 8;
-            std::memcpy(dst, &triple, 1);
-          } else {
-            triple = scalar::utf32::swap_bytes(triple);
-            triple >>= 8;
-            std::memcpy(dst, &triple, 1);
-          }
-          dst += 1;
-        } else if (idx == 3) {
-          uint32_t triple = (uint32_t(buffer[0]) << 3 * 6) +
-                            (uint32_t(buffer[1]) << 2 * 6) +
-                            (uint32_t(buffer[2]) << 1 * 6);
-          if ((last_chunk_options == last_chunk_handling_options::strict) &&
-              (triple & 0xff)) {
-            return {BASE64_EXTRA_BITS, size_t(src - srcinit),
-                    size_t(dst - dstinit)};
-          }
-          if (match_system(endianness::BIG)) {
-            triple <<= 8;
-            std::memcpy(dst, &triple, 2);
-          } else {
-            triple = scalar::utf32::swap_bytes(triple);
-            triple >>= 8;
-            std::memcpy(dst, &triple, 2);
-          }
-          dst += 2;
-        } else if (idx == 1) {
-          return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
-                  size_t(dst - dstinit)};
-        }
-        return {SUCCESS, size_t(src - srcinit), size_t(dst - dstinit)};
-      }
-    }
-
-    uint32_t triple =
-        (uint32_t(buffer[0]) << 3 * 6) + (uint32_t(buffer[1]) << 2 * 6) +
-        (uint32_t(buffer[2]) << 1 * 6) + (uint32_t(buffer[3]) << 0 * 6);
-    if (match_system(endianness::BIG)) {
-      triple <<= 8;
-      std::memcpy(dst, &triple, 3);
-    } else {
-      triple = scalar::utf32::swap_bytes(triple);
-      triple >>= 8;
-      std::memcpy(dst, &triple, 3);
-    }
-    dst += 3;
-  }
-}
-
-// like base64_tail_decode, but it will not write past the end of the output
-// buffer. The outlen paramter is modified to reflect the number of bytes
-// written. This functions assumes that the padding (=) has been removed.
-template <class char_type>
-result base64_tail_decode_safe(
-    char *dst, size_t &outlen, const char_type *&srcr, size_t length,
-    size_t padded_characters, // number of padding characters '=', typically 0,
-                              // 1, 2.
-    base64_options options, last_chunk_handling_options last_chunk_options) {
-  const char_type *src = srcr;
-  if (length == 0) {
-    outlen = 0;
-    return {SUCCESS, 0};
-  }
-  // This looks like 5 branches, but we expect the compiler to resolve this to a
-  // single branch:
-  const uint8_t *to_base64 = (options & base64_url)
-                                 ? tables::base64::to_base64_url_value
-                                 : tables::base64::to_base64_value;
-  const uint32_t *d0 = (options & base64_url)
-                           ? tables::base64::base64_url::d0
-                           : tables::base64::base64_default::d0;
-  const uint32_t *d1 = (options & base64_url)
-                           ? tables::base64::base64_url::d1
-                           : tables::base64::base64_default::d1;
-  const uint32_t *d2 = (options & base64_url)
-                           ? tables::base64::base64_url::d2
-                           : tables::base64::base64_default::d2;
-  const uint32_t *d3 = (options & base64_url)
-                           ? tables::base64::base64_url::d3
-                           : tables::base64::base64_default::d3;
-
-  const char_type *srcend = src + length;
-  const char_type *srcinit = src;
-  const char *dstinit = dst;
-  const char *dstend = dst + outlen;
-
-  uint32_t x;
-  size_t idx;
-  uint8_t buffer[4];
-  while (true) {
-    while (src + 4 <= srcend && is_eight_byte(src[0]) &&
-           is_eight_byte(src[1]) && is_eight_byte(src[2]) &&
-           is_eight_byte(src[3]) &&
-           (x = d0[uint8_t(src[0])] | d1[uint8_t(src[1])] |
-                d2[uint8_t(src[2])] | d3[uint8_t(src[3])]) < 0x01FFFFFF) {
-      if (dstend - dst < 3) {
-        outlen = size_t(dst - dstinit);
-        srcr = src;
-        return {OUTPUT_BUFFER_TOO_SMALL, size_t(src - srcinit)};
-      }
-      if (match_system(endianness::BIG)) {
-        x = scalar::utf32::swap_bytes(x);
-      }
-      std::memcpy(dst, &x, 3); // optimization opportunity: copy 4 bytes
-      dst += 3;
-      src += 4;
-    }
-    idx = 0;
-    const char_type *srccur = src;
-    // We need at least four characters.
-    while (idx < 4 && src < srcend) {
-      char_type c = *src;
-      uint8_t code = to_base64[uint8_t(c)];
-
-      buffer[idx] = uint8_t(code);
-      if (is_eight_byte(c) && code <= 63) {
-        idx++;
-      } else if (code > 64 || !scalar::base64::is_eight_byte(c)) {
-        outlen = size_t(dst - dstinit);
-        srcr = src;
-        return {INVALID_BASE64_CHARACTER, size_t(src - srcinit)};
-      } else {
-        // We have a space or a newline. We ignore it.
-      }
-      src++;
-    }
-    if (idx != 4) {
-      if (last_chunk_options == last_chunk_handling_options::strict &&
-          ((idx + padded_characters) & 3) != 0) {
-        outlen = size_t(dst - dstinit);
-        srcr = src;
-        return {BASE64_INPUT_REMAINDER, size_t(src - srcinit)};
-      } else if (last_chunk_options ==
-                     last_chunk_handling_options::stop_before_partial &&
-                 ((idx + padded_characters) & 3) != 0) {
-        // Rewind src to before partial chunk
-        srcr = srccur;
-        outlen = size_t(dst - dstinit);
-        return {SUCCESS, size_t(dst - dstinit)};
-      } else { // loose mode
-        if (idx == 0) {
-          // No data left; return success
-          outlen = size_t(dst - dstinit);
-          srcr = src;
-          return {SUCCESS, size_t(dst - dstinit)};
-        } else if (idx == 1) {
-          // Error: Incomplete chunk of length 1 is invalid in loose mode
-          outlen = size_t(dst - dstinit);
-          srcr = src;
-          return {BASE64_INPUT_REMAINDER, size_t(src - srcinit)};
-        } else if (idx == 2 || idx == 3) {
-          // Check if there's enough space in the destination buffer
-          size_t required_space = (idx == 2) ? 1 : 2;
-          if (size_t(dstend - dst) < required_space) {
-            outlen = size_t(dst - dstinit);
-            srcr = src;
-            return {OUTPUT_BUFFER_TOO_SMALL, size_t(srccur - srcinit)};
-          }
-          uint32_t triple = 0;
-          if (idx == 2) {
-            triple = (uint32_t(buffer[0]) << 18) + (uint32_t(buffer[1]) << 12);
-            if ((last_chunk_options == last_chunk_handling_options::strict) &&
-                (triple & 0xffff)) {
-              srcr = src;
-              return {BASE64_EXTRA_BITS, size_t(src - srcinit)};
-            }
-            // Extract the first byte
-            triple >>= 16;
-            dst[0] = static_cast<char>(triple & 0xFF);
-            dst += 1;
-          } else if (idx == 3) {
-            triple = (uint32_t(buffer[0]) << 18) + (uint32_t(buffer[1]) << 12) +
-                     (uint32_t(buffer[2]) << 6);
-            if ((last_chunk_options == last_chunk_handling_options::strict) &&
-                (triple & 0xff)) {
-              srcr = src;
-              return {BASE64_EXTRA_BITS, size_t(src - srcinit)};
-            }
-            // Extract the first two bytes
-            triple >>= 8;
-            dst[0] = static_cast<char>((triple >> 8) & 0xFF);
-            dst[1] = static_cast<char>(triple & 0xFF);
-            dst += 2;
-          }
-          outlen = size_t(dst - dstinit);
-          srcr = src;
-          return {SUCCESS, size_t(dst - dstinit)};
-        }
-      }
-    }
-
-    if (dstend - dst < 3) {
-      outlen = size_t(dst - dstinit);
-      srcr = src;
-      return {OUTPUT_BUFFER_TOO_SMALL, size_t(srccur - srcinit)};
-    }
-    uint32_t triple = (uint32_t(buffer[0]) << 18) +
-                      (uint32_t(buffer[1]) << 12) + (uint32_t(buffer[2]) << 6) +
-                      (uint32_t(buffer[3]));
-    if (match_system(endianness::BIG)) {
-      triple <<= 8;
-      std::memcpy(dst, &triple, 3);
-    } else {
-      triple = scalar::utf32::swap_bytes(triple);
-      triple >>= 8;
-      std::memcpy(dst, &triple, 3);
-    }
-    dst += 3;
-  }
-}
-
-// Returns the number of bytes written. The destination buffer must be large
-// enough. It will add padding (=) if needed.
-size_t tail_encode_base64(char *dst, const char *src, size_t srclen,
-                          base64_options options) {
-  // By default, we use padding if we are not using the URL variant.
-  // This is check with ((options & base64_url) == 0) which returns true if we
-  // are not using the URL variant. However, we also allow 'inversion' of the
-  // convention with the base64_reverse_padding option. If the
-  // base64_reverse_padding option is set, we use padding if we are using the
-  // URL variant, and we omit it if we are not using the URL variant. This is
-  // checked with
-  // ((options & base64_reverse_padding) == base64_reverse_padding).
-  bool use_padding =
-      ((options & base64_url) == 0) ^
-      ((options & base64_reverse_padding) == base64_reverse_padding);
-  // This looks like 3 branches, but we expect the compiler to resolve this to
-  // a single branch:
-  const char *e0 = (options & base64_url) ? tables::base64::base64_url::e0
-                                          : tables::base64::base64_default::e0;
-  const char *e1 = (options & base64_url) ? tables::base64::base64_url::e1
-                                          : tables::base64::base64_default::e1;
-  const char *e2 = (options & base64_url) ? tables::base64::base64_url::e2
-                                          : tables::base64::base64_default::e2;
-  char *out = dst;
-  size_t i = 0;
-  uint8_t t1, t2, t3;
-  for (; i + 2 < srclen; i += 3) {
-    t1 = uint8_t(src[i]);
-    t2 = uint8_t(src[i + 1]);
-    t3 = uint8_t(src[i + 2]);
-    *out++ = e0[t1];
-    *out++ = e1[((t1 & 0x03) << 4) | ((t2 >> 4) & 0x0F)];
-    *out++ = e1[((t2 & 0x0F) << 2) | ((t3 >> 6) & 0x03)];
-    *out++ = e2[t3];
-  }
-  switch (srclen - i) {
-  case 0:
-    break;
-  case 1:
-    t1 = uint8_t(src[i]);
-    *out++ = e0[t1];
-    *out++ = e1[(t1 & 0x03) << 4];
-    if (use_padding) {
-      *out++ = '=';
-      *out++ = '=';
-    }
-    break;
-  default: /* case 2 */
-    t1 = uint8_t(src[i]);
-    t2 = uint8_t(src[i + 1]);
-    *out++ = e0[t1];
-    *out++ = e1[((t1 & 0x03) << 4) | ((t2 >> 4) & 0x0F)];
-    *out++ = e2[(t2 & 0x0F) << 2];
-    if (use_padding) {
-      *out++ = '=';
-    }
-  }
-  return (size_t)(out - dst);
-}
-
-template <class char_type>
-simdutf_warn_unused size_t maximal_binary_length_from_base64(
-    const char_type *input, size_t length) noexcept {
-  // We follow https://infra.spec.whatwg.org/#forgiving-base64-decode
-  size_t padding = 0;
-  if (length > 0) {
-    if (input[length - 1] == '=') {
-      padding++;
-      if (length > 1 && input[length - 2] == '=') {
-        padding++;
-      }
-    }
-  }
-  size_t actual_length = length - padding;
-  if (actual_length % 4 <= 1) {
-    return actual_length / 4 * 3;
-  }
-  // if we have a valid input, then the remainder must be 2 or 3 adding one or
-  // two extra bytes.
-  return actual_length / 4 * 3 + (actual_length % 4) - 1;
-}
-
-simdutf_warn_unused size_t
-base64_length_from_binary(size_t length, base64_options options) noexcept {
-  // By default, we use padding if we are not using the URL variant.
-  // This is check with ((options & base64_url) == 0) which returns true if we
-  // are not using the URL variant. However, we also allow 'inversion' of the
-  // convention with the base64_reverse_padding option. If the
-  // base64_reverse_padding option is set, we use padding if we are using the
-  // URL variant, and we omit it if we are not using the URL variant. This is
-  // checked with
-  // ((options & base64_reverse_padding) == base64_reverse_padding).
-  bool use_padding =
-      ((options & base64_url) == 0) ^
-      ((options & base64_reverse_padding) == base64_reverse_padding);
-  if (!use_padding) {
-    return length / 3 * 4 + ((length % 3) ? (length % 3) + 1 : 0);
-  }
-  return (length + 2) / 3 *
-         4; // We use padding to make the length a multiple of 4.
-}
-
-} // namespace base64
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/base64.h */
-/* begin file src/scalar/latin1_to_utf8/latin1_to_utf8.h */
-#ifndef SIMDUTF_LATIN1_TO_UTF8_H
-#define SIMDUTF_LATIN1_TO_UTF8_H
-
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace latin1_to_utf8 {
-
-inline size_t convert(const char *buf, size_t len, char *utf8_output) {
-  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
-  size_t pos = 0;
-  size_t utf8_pos = 0;
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 |
-                 v2}; // We are only interested in these bits: 1000 1000 1000
-                      // 1000, so it makes sense to concatenate everything
-      if ((v & 0x8080808080808080) ==
-          0) { // if NONE of these are set, e.g. all of them are zero, then
-               // everything is ASCII
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          utf8_output[utf8_pos++] = char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-
-    unsigned char byte = data[pos];
-    if ((byte & 0x80) == 0) { // if ASCII
-      // will generate one UTF-8 bytes
-      utf8_output[utf8_pos++] = char(byte);
-      pos++;
-    } else {
-      // will generate two UTF-8 bytes
-      utf8_output[utf8_pos++] = char((byte >> 6) | 0b11000000);
-      utf8_output[utf8_pos++] = char((byte & 0b111111) | 0b10000000);
-      pos++;
-    }
-  }
-  return utf8_pos;
-}
-
-inline size_t convert_safe(const char *buf, size_t len, char *utf8_output,
-                           size_t utf8_len) {
-  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
-  size_t pos = 0;
-  size_t skip_pos = 0;
-  size_t utf8_pos = 0;
-  while (pos < len && utf8_pos < utf8_len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos >= skip_pos && pos + 16 <= len &&
-        utf8_pos + 16 <= utf8_len) { // if it is safe to read 16 more bytes,
-                                     // check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 |
-                 v2}; // We are only interested in these bits: 1000 1000 1000
-                      // 1000, so it makes sense to concatenate everything
-      if ((v & 0x8080808080808080) ==
-          0) { // if NONE of these are set, e.g. all of them are zero, then
-               // everything is ASCII
-        ::memcpy(utf8_output + utf8_pos, buf + pos, 16);
-        utf8_pos += 16;
-        pos += 16;
-      } else {
-        // At least one of the next 16 bytes are not ASCII, we will process them
-        // one by one
-        skip_pos = pos + 16;
-      }
-    } else {
-      const auto byte = data[pos];
-      if ((byte & 0x80) == 0) { // if ASCII
-        // will generate one UTF-8 bytes
-        utf8_output[utf8_pos++] = char(byte);
-        pos++;
-      } else if (utf8_pos + 2 <= utf8_len) {
-        // will generate two UTF-8 bytes
-        utf8_output[utf8_pos++] = char((byte >> 6) | 0b11000000);
-        utf8_output[utf8_pos++] = char((byte & 0b111111) | 0b10000000);
-        pos++;
-      } else {
-        break;
-      }
-    }
-  }
-  return utf8_pos;
-}
-
-} // namespace latin1_to_utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/latin1_to_utf8/latin1_to_utf8.h */
-
-namespace simdutf {
-bool implementation::supported_by_runtime_system() const {
-  uint32_t required_instruction_sets = this->required_instruction_sets();
-  uint32_t supported_instruction_sets =
-      internal::detect_supported_architectures();
-  return ((supported_instruction_sets & required_instruction_sets) ==
-          required_instruction_sets);
-}
-
-simdutf_warn_unused encoding_type implementation::autodetect_encoding(
-    const char *input, size_t length) const noexcept {
-  // If there is a BOM, then we trust it.
-  auto bom_encoding = simdutf::BOM::check_bom(input, length);
-  if (bom_encoding != encoding_type::unspecified) {
-    return bom_encoding;
-  }
-  // UTF8 is common, it includes ASCII, and is commonly represented
-  // without a BOM, so if it fits, go with that. Note that it is still
-  // possible to get it wrong, we are only 'guessing'. If some has UTF-16
-  // data without a BOM, it could pass as UTF-8.
-  //
-  // An interesting twist might be to check for UTF-16 ASCII first (every
-  // other byte is zero).
-  if (validate_utf8(input, length)) {
-    return encoding_type::UTF8;
-  }
-  // The next most common encoding that might appear without BOM is probably
-  // UTF-16LE, so try that next.
-  if ((length % 2) == 0) {
-    // important: we need to divide by two
-    if (validate_utf16le(reinterpret_cast<const char16_t *>(input),
-                         length / 2)) {
-      return encoding_type::UTF16_LE;
-    }
-  }
-  if ((length % 4) == 0) {
-    if (validate_utf32(reinterpret_cast<const char32_t *>(input), length / 4)) {
-      return encoding_type::UTF32_LE;
-    }
-  }
-  return encoding_type::unspecified;
-}
-
-namespace internal {
-// When there is a single implementation, we should not pay a price
-// for dispatching to the best implementation. We should just use the
-// one we have. This is a compile-time check.
-#define SIMDUTF_SINGLE_IMPLEMENTATION                                          \
-  (SIMDUTF_IMPLEMENTATION_ICELAKE + SIMDUTF_IMPLEMENTATION_HASWELL +           \
-       SIMDUTF_IMPLEMENTATION_WESTMERE + SIMDUTF_IMPLEMENTATION_ARM64 +        \
-       SIMDUTF_IMPLEMENTATION_PPC64 + SIMDUTF_IMPLEMENTATION_LSX +             \
-       SIMDUTF_IMPLEMENTATION_LASX + SIMDUTF_IMPLEMENTATION_FALLBACK ==        \
-   1)
-
-// Static array of known implementations. We are hoping these get baked into the
-// executable without requiring a static initializer.
-
-#if SIMDUTF_IMPLEMENTATION_ICELAKE
-static const icelake::implementation *get_icelake_singleton() {
-  static const icelake::implementation icelake_singleton{};
-  return &icelake_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_HASWELL
-static const haswell::implementation *get_haswell_singleton() {
-  static const haswell::implementation haswell_singleton{};
-  return &haswell_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_WESTMERE
-static const westmere::implementation *get_westmere_singleton() {
-  static const westmere::implementation westmere_singleton{};
-  return &westmere_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_ARM64
-static const arm64::implementation *get_arm64_singleton() {
-  static const arm64::implementation arm64_singleton{};
-  return &arm64_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_PPC64
-static const ppc64::implementation *get_ppc64_singleton() {
-  static const ppc64::implementation ppc64_singleton{};
-  return &ppc64_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_RVV
-static const rvv::implementation *get_rvv_singleton() {
-  static const rvv::implementation rvv_singleton{};
-  return &rvv_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_LSX
-static const lsx::implementation *get_lsx_singleton() {
-  static const lsx::implementation lsx_singleton{};
-  return &lsx_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_LASX
-static const lasx::implementation *get_lasx_singleton() {
-  static const lasx::implementation lasx_singleton{};
-  return &lasx_singleton;
-}
-#endif
-#if SIMDUTF_IMPLEMENTATION_FALLBACK
-static const fallback::implementation *get_fallback_singleton() {
-  static const fallback::implementation fallback_singleton{};
-  return &fallback_singleton;
-}
-#endif
-
-#if SIMDUTF_SINGLE_IMPLEMENTATION
-static const implementation *get_single_implementation() {
-  return
-  #if SIMDUTF_IMPLEMENTATION_ICELAKE
-      get_icelake_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_HASWELL
-  get_haswell_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_WESTMERE
-  get_westmere_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_ARM64
-  get_arm64_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_PPC64
-  get_ppc64_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_LSX
-  get_lsx_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_LASX
-  get_lasx_singleton();
-  #endif
-  #if SIMDUTF_IMPLEMENTATION_FALLBACK
-  get_fallback_singleton();
-  #endif
-}
-#endif
-
-/**
- * @private Detects best supported implementation on first use, and sets it
- */
-class detect_best_supported_implementation_on_first_use final
-    : public implementation {
-public:
-  std::string name() const noexcept final { return set_best()->name(); }
-  std::string description() const noexcept final {
-    return set_best()->description();
-  }
-  uint32_t required_instruction_sets() const noexcept final {
-    return set_best()->required_instruction_sets();
-  }
-
-  simdutf_warn_unused int
-  detect_encodings(const char *input, size_t length) const noexcept override {
-    return set_best()->detect_encodings(input, length);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf8(const char *buf, size_t len) const noexcept final override {
-    return set_best()->validate_utf8(buf, len);
-  }
-
-  simdutf_warn_unused result validate_utf8_with_errors(
-      const char *buf, size_t len) const noexcept final override {
-    return set_best()->validate_utf8_with_errors(buf, len);
-  }
-
-  simdutf_warn_unused bool
-  validate_ascii(const char *buf, size_t len) const noexcept final override {
-    return set_best()->validate_ascii(buf, len);
-  }
-
-  simdutf_warn_unused result validate_ascii_with_errors(
-      const char *buf, size_t len) const noexcept final override {
-    return set_best()->validate_ascii_with_errors(buf, len);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf16le(const char16_t *buf,
-                   size_t len) const noexcept final override {
-    return set_best()->validate_utf16le(buf, len);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf16be(const char16_t *buf,
-                   size_t len) const noexcept final override {
-    return set_best()->validate_utf16be(buf, len);
-  }
-
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *buf, size_t len) const noexcept final override {
-    return set_best()->validate_utf16le_with_errors(buf, len);
-  }
-
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *buf, size_t len) const noexcept final override {
-    return set_best()->validate_utf16be_with_errors(buf, len);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf32(const char32_t *buf,
-                 size_t len) const noexcept final override {
-    return set_best()->validate_utf32(buf, len);
-  }
-
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *buf, size_t len) const noexcept final override {
-    return set_best()->validate_utf32_with_errors(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  convert_latin1_to_utf8(const char *buf, size_t len,
-                         char *utf8_output) const noexcept final override {
-    return set_best()->convert_latin1_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_latin1_to_utf16le(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_latin1_to_utf16be(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *buf, size_t len,
-      char32_t *latin1_output) const noexcept final override {
-    return set_best()->convert_latin1_to_utf32(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf8_to_latin1(const char *buf, size_t len,
-                         char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf8_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf8_to_latin1_with_errors(buf, len,
-                                                          latin1_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_valid_utf8_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf16le(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf16be(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf16le_with_errors(buf, len,
-                                                           utf16_output);
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf16be_with_errors(buf, len,
-                                                           utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_valid_utf8_to_utf16le(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_valid_utf8_to_utf16be(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf8_to_utf32(const char *buf, size_t len,
-                        char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf32(buf, len, utf32_output);
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf8_to_utf32_with_errors(buf, len,
-                                                         utf32_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_valid_utf8_to_utf32(buf, len, utf32_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
-                            char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_latin1_with_errors(buf, len,
-                                                             latin1_output);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_latin1_with_errors(buf, len,
-                                                             latin1_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
-      const char16_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_valid_utf16le_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
-      const char16_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_valid_utf16be_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf16le_to_utf8(const char16_t *buf, size_t len,
-                          char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf16be_to_utf8(const char16_t *buf, size_t len,
-                          char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *buf, size_t len,
-      char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_utf8_with_errors(buf, len,
-                                                           utf8_output);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *buf, size_t len,
-      char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_utf8_with_errors(buf, len,
-                                                           utf8_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *buf, size_t len,
-      char *utf8_output) const noexcept final override {
-    return set_best()->convert_valid_utf16le_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *buf, size_t len,
-      char *utf8_output) const noexcept final override {
-    return set_best()->convert_valid_utf16be_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf32_to_latin1(const char32_t *buf, size_t len,
-                          char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf32_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
-      const char32_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf32_to_latin1_with_errors(buf, len,
-                                                           latin1_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
-      const char32_t *buf, size_t len,
-      char *latin1_output) const noexcept final override {
-    return set_best()->convert_utf32_to_latin1(buf, len, latin1_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_utf32_to_utf8(const char32_t *buf, size_t len,
-                        char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *buf, size_t len,
-      char *utf8_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf8_with_errors(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t
-  convert_valid_utf32_to_utf8(const char32_t *buf, size_t len,
-                              char *utf8_output) const noexcept final override {
-    return set_best()->convert_valid_utf32_to_utf8(buf, len, utf8_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_utf16le(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf16le(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_utf16be(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf16be(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf16le_with_errors(buf, len,
-                                                            utf16_output);
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_utf32_to_utf16be_with_errors(buf, len,
-                                                            utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_valid_utf32_to_utf16le(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
-      const char32_t *buf, size_t len,
-      char16_t *utf16_output) const noexcept final override {
-    return set_best()->convert_valid_utf32_to_utf16be(buf, len, utf16_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf16le_to_utf32(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_utf32(buf, len, utf32_output);
-  }
-
-  simdutf_warn_unused size_t convert_utf16be_to_utf32(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_utf32(buf, len, utf32_output);
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf16le_to_utf32_with_errors(buf, len,
-                                                            utf32_output);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_utf16be_to_utf32_with_errors(buf, len,
-                                                            utf32_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_valid_utf16le_to_utf32(buf, len, utf32_output);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
-      const char16_t *buf, size_t len,
-      char32_t *utf32_output) const noexcept final override {
-    return set_best()->convert_valid_utf16be_to_utf32(buf, len, utf32_output);
-  }
-
-  void change_endianness_utf16(const char16_t *buf, size_t len,
-                               char16_t *output) const noexcept final override {
-    set_best()->change_endianness_utf16(buf, len, output);
-  }
-
-  simdutf_warn_unused size_t
-  count_utf16le(const char16_t *buf, size_t len) const noexcept final override {
-    return set_best()->count_utf16le(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  count_utf16be(const char16_t *buf, size_t len) const noexcept final override {
-    return set_best()->count_utf16be(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  count_utf8(const char *buf, size_t len) const noexcept final override {
-    return set_best()->count_utf8(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *buf, size_t len) const noexcept override {
-    return set_best()->latin1_length_from_utf8(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t len) const noexcept override {
-    return set_best()->latin1_length_from_utf16(len);
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t len) const noexcept override {
-    return set_best()->latin1_length_from_utf32(len);
-  }
-
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *buf, size_t len) const noexcept override {
-    return set_best()->utf8_length_from_latin1(buf, len);
-  }
-
-  simdutf_warn_unused size_t utf8_length_from_utf16le(
-      const char16_t *buf, size_t len) const noexcept override {
-    return set_best()->utf8_length_from_utf16le(buf, len);
-  }
-
-  simdutf_warn_unused size_t utf8_length_from_utf16be(
-      const char16_t *buf, size_t len) const noexcept override {
-    return set_best()->utf8_length_from_utf16be(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t len) const noexcept override {
-    return set_best()->utf16_length_from_latin1(len);
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t len) const noexcept override {
-    return set_best()->utf32_length_from_latin1(len);
-  }
-
-  simdutf_warn_unused size_t utf32_length_from_utf16le(
-      const char16_t *buf, size_t len) const noexcept override {
-    return set_best()->utf32_length_from_utf16le(buf, len);
-  }
-
-  simdutf_warn_unused size_t utf32_length_from_utf16be(
-      const char16_t *buf, size_t len) const noexcept override {
-    return set_best()->utf32_length_from_utf16be(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *buf, size_t len) const noexcept override {
-    return set_best()->utf16_length_from_utf8(buf, len);
-  }
-
-  simdutf_warn_unused size_t utf8_length_from_utf32(
-      const char32_t *buf, size_t len) const noexcept override {
-    return set_best()->utf8_length_from_utf32(buf, len);
-  }
-
-  simdutf_warn_unused size_t utf16_length_from_utf32(
-      const char32_t *buf, size_t len) const noexcept override {
-    return set_best()->utf16_length_from_utf32(buf, len);
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *buf, size_t len) const noexcept override {
-    return set_best()->utf32_length_from_utf8(buf, len);
-  }
-
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *input, size_t length) const noexcept override {
-    return set_best()->maximal_binary_length_from_base64(input, length);
-  }
-
-  simdutf_warn_unused result base64_to_binary(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_handling_options =
-          last_chunk_handling_options::loose) const noexcept override {
-    return set_best()->base64_to_binary(input, length, output, options,
-                                        last_chunk_handling_options);
-  }
-
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *input, size_t length, char *output, base64_options options,
-      last_chunk_handling_options last_chunk_handling_options =
-          last_chunk_handling_options::loose) const noexcept override {
-    return set_best()->base64_to_binary_details(input, length, output, options,
-                                                last_chunk_handling_options);
-  }
-
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *input, size_t length) const noexcept override {
-    return set_best()->maximal_binary_length_from_base64(input, length);
-  }
-
-  simdutf_warn_unused result base64_to_binary(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_handling_options =
-          last_chunk_handling_options::loose) const noexcept override {
-    return set_best()->base64_to_binary(input, length, output, options,
-                                        last_chunk_handling_options);
-  }
-
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *input, size_t length, char *output,
-      base64_options options,
-      last_chunk_handling_options last_chunk_handling_options =
-          last_chunk_handling_options::loose) const noexcept override {
-    return set_best()->base64_to_binary_details(input, length, output, options,
-                                                last_chunk_handling_options);
-  }
-
-  simdutf_warn_unused size_t base64_length_from_binary(
-      size_t length, base64_options options) const noexcept override {
-    return set_best()->base64_length_from_binary(length, options);
-  }
-
-  size_t binary_to_base64(const char *input, size_t length, char *output,
-                          base64_options options) const noexcept override {
-    return set_best()->binary_to_base64(input, length, output, options);
-  }
-
-  simdutf_really_inline
-  detect_best_supported_implementation_on_first_use() noexcept
-      : implementation("best_supported_detector",
-                       "Detects the best supported implementation and sets it",
-                       0) {}
-
-private:
-  const implementation *set_best() const noexcept;
-};
-
-static_assert(std::is_trivially_destructible<
-                  detect_best_supported_implementation_on_first_use>::value,
-              "detect_best_supported_implementation_on_first_use should be "
-              "trivially destructible");
-
-static const std::initializer_list<const implementation *> &
-get_available_implementation_pointers() {
-  static const std::initializer_list<const implementation *>
-      available_implementation_pointers{
-#if SIMDUTF_IMPLEMENTATION_ICELAKE
-          get_icelake_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_HASWELL
-          get_haswell_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_WESTMERE
-          get_westmere_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_ARM64
-          get_arm64_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_PPC64
-          get_ppc64_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_RVV
-          get_rvv_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_LSX
-          get_lsx_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_LASX
-          get_lasx_singleton(),
-#endif
-#if SIMDUTF_IMPLEMENTATION_FALLBACK
-          get_fallback_singleton(),
-#endif
-      }; // available_implementation_pointers
-  return available_implementation_pointers;
-}
-
-// So we can return UNSUPPORTED_ARCHITECTURE from the parser when there is no
-// support
-class unsupported_implementation final : public implementation {
-public:
-  simdutf_warn_unused int detect_encodings(const char *,
-                                           size_t) const noexcept override {
-    return encoding_type::unspecified;
-  }
-
-  simdutf_warn_unused bool validate_utf8(const char *,
-                                         size_t) const noexcept final override {
-    return false; // Just refuse to validate. Given that we have a fallback
-                  // implementation
-    // it seems unlikely that unsupported_implementation will ever be used. If
-    // it is used, then it will flag all strings as invalid. The alternative is
-    // to return an error_code from which the user has to figure out whether the
-    // string is valid UTF-8... which seems like a lot of work just to handle
-    // the very unlikely case that we have an unsupported implementation. And,
-    // when it does happen (that we have an unsupported implementation), what
-    // are the chances that the programmer has a fallback? Given that *we*
-    // provide the fallback, it implies that the programmer would need a
-    // fallback for our fallback.
-  }
-
-  simdutf_warn_unused result validate_utf8_with_errors(
-      const char *, size_t) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused bool
-  validate_ascii(const char *, size_t) const noexcept final override {
-    return false;
-  }
-
-  simdutf_warn_unused result validate_ascii_with_errors(
-      const char *, size_t) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf16le(const char16_t *, size_t) const noexcept final override {
-    return false;
-  }
-
-  simdutf_warn_unused bool
-  validate_utf16be(const char16_t *, size_t) const noexcept final override {
-    return false;
-  }
-
-  simdutf_warn_unused result validate_utf16le_with_errors(
-      const char16_t *, size_t) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result validate_utf16be_with_errors(
-      const char16_t *, size_t) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused bool
-  validate_utf32(const char32_t *, size_t) const noexcept final override {
-    return false;
-  }
-
-  simdutf_warn_unused result validate_utf32_with_errors(
-      const char32_t *, size_t) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf8(
-      const char *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf16le(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf16be(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_latin1_to_utf32(
-      const char *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_latin1(
-      const char *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-      const char *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-      const char *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_utf16le(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_utf16be(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-      const char *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf8_to_utf32(
-      const char *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-      const char *, size_t, char32_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-      const char *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16le_to_latin1(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16be_to_latin1(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16le_to_utf8(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16be_to_utf8(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-      const char16_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_latin1(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_utf8(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-      const char32_t *, size_t, char *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_utf16le(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf32_to_utf16be(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
-      const char32_t *, size_t, char16_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16le_to_utf32(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_utf16be_to_utf32(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
-      const char16_t *, size_t, char32_t *) const noexcept final override {
-    return 0;
-  }
-
-  void change_endianness_utf16(const char16_t *, size_t,
-                               char16_t *) const noexcept final override {}
-
-  simdutf_warn_unused size_t
-  count_utf16le(const char16_t *, size_t) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  count_utf16be(const char16_t *, size_t) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t count_utf8(const char *,
-                                        size_t) const noexcept final override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf8(const char *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf16(size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  latin1_length_from_utf32(size_t) const noexcept override {
-    return 0;
-  }
-  simdutf_warn_unused size_t
-  utf8_length_from_latin1(const char *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16le(const char16_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf8_length_from_utf16be(const char16_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_utf16le(const char16_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_utf16be(const char16_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_latin1(size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf16_length_from_utf8(const char *, size_t) const noexcept override {
-    return 0;
-  }
-  simdutf_warn_unused size_t
-  utf16_length_from_latin1(size_t) const noexcept override {
-    return 0;
-  }
-  simdutf_warn_unused size_t
-  utf8_length_from_utf32(const char32_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf16_length_from_utf32(const char32_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t
-  utf32_length_from_utf8(const char *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused result
-  base64_to_binary(const char *, size_t, char *, base64_options,
-                   last_chunk_handling_options) const noexcept override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char *, size_t, char *, base64_options,
-      last_chunk_handling_options) const noexcept override {
-    return full_result(error_code::OTHER, 0, 0);
-  }
-
-  simdutf_warn_unused size_t maximal_binary_length_from_base64(
-      const char16_t *, size_t) const noexcept override {
-    return 0;
-  }
-
-  simdutf_warn_unused result
-  base64_to_binary(const char16_t *, size_t, char *, base64_options,
-                   last_chunk_handling_options) const noexcept override {
-    return result(error_code::OTHER, 0);
-  }
-
-  simdutf_warn_unused full_result base64_to_binary_details(
-      const char16_t *, size_t, char *, base64_options,
-      last_chunk_handling_options) const noexcept override {
-    return full_result(error_code::OTHER, 0, 0);
-  }
-
-  simdutf_warn_unused size_t
-  base64_length_from_binary(size_t, base64_options) const noexcept override {
-    return 0;
-  }
-
-  size_t binary_to_base64(const char *, size_t, char *,
-                          base64_options) const noexcept override {
-    return 0;
-  }
-
-  unsupported_implementation()
-      : implementation("unsupported",
-                       "Unsupported CPU (no detected SIMD instructions)", 0) {}
-};
-
-const unsupported_implementation *get_unsupported_singleton() {
-  static const unsupported_implementation unsupported_singleton{};
-  return &unsupported_singleton;
-}
-static_assert(std::is_trivially_destructible<unsupported_implementation>::value,
-              "unsupported_singleton should be trivially destructible");
-
-size_t available_implementation_list::size() const noexcept {
-  return internal::get_available_implementation_pointers().size();
-}
-const implementation *const *
-available_implementation_list::begin() const noexcept {
-  return internal::get_available_implementation_pointers().begin();
-}
-const implementation *const *
-available_implementation_list::end() const noexcept {
-  return internal::get_available_implementation_pointers().end();
-}
-const implementation *
-available_implementation_list::detect_best_supported() const noexcept {
-  // They are prelisted in priority order, so we just go down the list
-  uint32_t supported_instruction_sets =
-      internal::detect_supported_architectures();
-  for (const implementation *impl :
-       internal::get_available_implementation_pointers()) {
-    uint32_t required_instruction_sets = impl->required_instruction_sets();
-    if ((supported_instruction_sets & required_instruction_sets) ==
-        required_instruction_sets) {
-      return impl;
-    }
-  }
-  return get_unsupported_singleton(); // this should never happen?
-}
-
-const implementation *
-detect_best_supported_implementation_on_first_use::set_best() const noexcept {
-  SIMDUTF_PUSH_DISABLE_WARNINGS
-  SIMDUTF_DISABLE_DEPRECATED_WARNING // Disable CRT_SECURE warning on MSVC:
-                                     // manually verified this is safe
-      char *force_implementation_name = getenv("SIMDUTF_FORCE_IMPLEMENTATION");
-  SIMDUTF_POP_DISABLE_WARNINGS
-
-  if (force_implementation_name) {
-    auto force_implementation =
-        get_available_implementations()[force_implementation_name];
-    if (force_implementation) {
-      return get_active_implementation() = force_implementation;
-    } else {
-      // Note: abort() and stderr usage within the library is forbidden.
-      return get_active_implementation() = get_unsupported_singleton();
-    }
-  }
-  return get_active_implementation() =
-             get_available_implementations().detect_best_supported();
-}
-
-} // namespace internal
-
-/**
- * The list of available implementations compiled into simdutf.
- */
-SIMDUTF_DLLIMPORTEXPORT const internal::available_implementation_list &
-get_available_implementations() {
-  static const internal::available_implementation_list
-      available_implementations{};
-  return available_implementations;
-}
-
-/**
- * The active implementation.
- */
-SIMDUTF_DLLIMPORTEXPORT internal::atomic_ptr<const implementation> &
-get_active_implementation() {
-#if SIMDUTF_SINGLE_IMPLEMENTATION
-  // skip runtime detection
-  static internal::atomic_ptr<const implementation> active_implementation{
-      internal::get_single_implementation()};
-  return active_implementation;
-#else
-  static const internal::detect_best_supported_implementation_on_first_use
-      detect_best_supported_implementation_on_first_use_singleton;
-  static internal::atomic_ptr<const implementation> active_implementation{
-      &detect_best_supported_implementation_on_first_use_singleton};
-  return active_implementation;
-#endif
-}
-
-#if SIMDUTF_SINGLE_IMPLEMENTATION
-const implementation *get_default_implementation() {
-  return internal::get_single_implementation();
-}
-#else
-internal::atomic_ptr<const implementation> &get_default_implementation() {
-  return get_active_implementation();
-}
-#endif
-#define SIMDUTF_GET_CURRENT_IMPLEMENTION
-
-simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept {
-  return get_default_implementation()->validate_utf8(buf, len);
-}
-simdutf_warn_unused result validate_utf8_with_errors(const char *buf,
-                                                     size_t len) noexcept {
-  return get_default_implementation()->validate_utf8_with_errors(buf, len);
-}
-simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept {
-  return get_default_implementation()->validate_ascii(buf, len);
-}
-simdutf_warn_unused result validate_ascii_with_errors(const char *buf,
-                                                      size_t len) noexcept {
-  return get_default_implementation()->validate_ascii_with_errors(buf, len);
-}
-simdutf_warn_unused size_t convert_utf8_to_utf16(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf8_to_utf16be(input, length, utf16_output);
-#else
-  return convert_utf8_to_utf16le(input, length, utf16_output);
-#endif
-}
-simdutf_warn_unused size_t convert_latin1_to_utf8(const char *buf, size_t len,
-                                                  char *utf8_output) noexcept {
-  return get_default_implementation()->convert_latin1_to_utf8(buf, len,
-                                                              utf8_output);
-}
-simdutf_warn_unused size_t convert_latin1_to_utf16le(
-    const char *buf, size_t len, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_latin1_to_utf16le(buf, len,
-                                                                 utf16_output);
-}
-simdutf_warn_unused size_t convert_latin1_to_utf16be(
-    const char *buf, size_t len, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_latin1_to_utf16be(buf, len,
-                                                                 utf16_output);
-}
-simdutf_warn_unused size_t convert_latin1_to_utf32(
-    const char *buf, size_t len, char32_t *latin1_output) noexcept {
-  return get_default_implementation()->convert_latin1_to_utf32(buf, len,
-                                                               latin1_output);
-}
-simdutf_warn_unused size_t convert_utf8_to_latin1(
-    const char *buf, size_t len, char *latin1_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_latin1(buf, len,
-                                                              latin1_output);
-}
-simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
-    const char *buf, size_t len, char *latin1_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_latin1_with_errors(
-      buf, len, latin1_output);
-}
-simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
-    const char *buf, size_t len, char *latin1_output) noexcept {
-  return get_default_implementation()->convert_valid_utf8_to_latin1(
-      buf, len, latin1_output);
-}
-simdutf_warn_unused size_t convert_utf8_to_utf16le(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf16le(input, length,
-                                                               utf16_output);
-}
-simdutf_warn_unused size_t convert_utf8_to_utf16be(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf16be(input, length,
-                                                               utf16_output);
-}
-simdutf_warn_unused result convert_utf8_to_utf16_with_errors(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf8_to_utf16be_with_errors(input, length, utf16_output);
-#else
-  return convert_utf8_to_utf16le_with_errors(input, length, utf16_output);
-#endif
-}
-simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf16le_with_errors(
-      input, length, utf16_output);
-}
-simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
-    const char *input, size_t length, char16_t *utf16_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf16be_with_errors(
-      input, length, utf16_output);
-}
-simdutf_warn_unused size_t convert_utf8_to_utf32(
-    const char *input, size_t length, char32_t *utf32_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf32(input, length,
-                                                             utf32_output);
-}
-simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
-    const char *input, size_t length, char32_t *utf32_output) noexcept {
-  return get_default_implementation()->convert_utf8_to_utf32_with_errors(
-      input, length, utf32_output);
-}
-simdutf_warn_unused bool validate_utf16(const char16_t *buf,
-                                        size_t len) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return validate_utf16be(buf, len);
-#else
-  return validate_utf16le(buf, len);
-#endif
-}
-simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
-                                          size_t len) noexcept {
-  return get_default_implementation()->validate_utf16le(buf, len);
-}
-simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
-                                          size_t len) noexcept {
-  return get_default_implementation()->validate_utf16be(buf, len);
-}
-simdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf,
-                                                      size_t len) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return validate_utf16be_with_errors(buf, len);
-#else
-  return validate_utf16le_with_errors(buf, len);
-#endif
-}
-simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf,
-                                                        size_t len) noexcept {
-  return get_default_implementation()->validate_utf16le_with_errors(buf, len);
-}
-simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf,
-                                                        size_t len) noexcept {
-  return get_default_implementation()->validate_utf16be_with_errors(buf, len);
-}
-simdutf_warn_unused bool validate_utf32(const char32_t *buf,
-                                        size_t len) noexcept {
-  return get_default_implementation()->validate_utf32(buf, len);
-}
-simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf,
-                                                      size_t len) noexcept {
-  return get_default_implementation()->validate_utf32_with_errors(buf, len);
-}
-simdutf_warn_unused size_t convert_valid_utf8_to_utf16(
-    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_valid_utf8_to_utf16be(input, length, utf16_buffer);
-#else
-  return convert_valid_utf8_to_utf16le(input, length, utf16_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
-    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf8_to_utf16le(
-      input, length, utf16_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
-    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf8_to_utf16be(
-      input, length, utf16_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
-    const char *input, size_t length, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf8_to_utf32(
-      input, length, utf32_buffer);
-}
-simdutf_warn_unused size_t convert_utf16_to_utf8(const char16_t *buf,
-                                                 size_t len,
-                                                 char *utf8_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_utf8(buf, len, utf8_buffer);
-#else
-  return convert_utf16le_to_utf8(buf, len, utf8_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_utf16_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_latin1(buf, len, latin1_buffer);
-#else
-  return convert_utf16le_to_latin1(buf, len, latin1_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_latin1_to_utf16(
-    const char *buf, size_t len, char16_t *utf16_output) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_latin1_to_utf16be(buf, len, utf16_output);
-#else
-  return convert_latin1_to_utf16le(buf, len, utf16_output);
-#endif
-}
-simdutf_warn_unused size_t convert_utf16be_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_latin1(buf, len,
-                                                                 latin1_buffer);
-}
-simdutf_warn_unused size_t convert_utf16le_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_latin1(buf, len,
-                                                                 latin1_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16be_to_latin1(
-      buf, len, latin1_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16le_to_latin1(
-      buf, len, latin1_buffer);
-}
-simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_latin1_with_errors(
-      buf, len, latin1_buffer);
-}
-simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_latin1_with_errors(
-      buf, len, latin1_buffer);
-}
-simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t *buf,
-                                                   size_t len,
-                                                   char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_utf8(buf, len,
-                                                               utf8_buffer);
-}
-simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t *buf,
-                                                   size_t len,
-                                                   char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_utf8(buf, len,
-                                                               utf8_buffer);
-}
-simdutf_warn_unused result convert_utf16_to_utf8_with_errors(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_utf8_with_errors(buf, len, utf8_buffer);
-#else
-  return convert_utf16le_to_utf8_with_errors(buf, len, utf8_buffer);
-#endif
-}
-simdutf_warn_unused result convert_utf16_to_latin1_with_errors(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_latin1_with_errors(buf, len, latin1_buffer);
-#else
-  return convert_utf16le_to_latin1_with_errors(buf, len, latin1_buffer);
-#endif
-}
-simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_utf8_with_errors(
-      buf, len, utf8_buffer);
-}
-simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_utf8_with_errors(
-      buf, len, utf8_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16_to_utf8(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_valid_utf16be_to_utf8(buf, len, utf8_buffer);
-#else
-  return convert_valid_utf16le_to_utf8(buf, len, utf8_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_valid_utf16_to_latin1(
-    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_valid_utf16be_to_latin1(buf, len, latin1_buffer);
-#else
-  return convert_valid_utf16le_to_latin1(buf, len, latin1_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16le_to_utf8(
-      buf, len, utf8_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
-    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16be_to_utf8(
-      buf, len, utf8_buffer);
-}
-simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t *buf,
-                                                 size_t len,
-                                                 char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf8(buf, len,
-                                                             utf8_buffer);
-}
-simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
-    const char32_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf8_with_errors(
-      buf, len, utf8_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
-    const char32_t *buf, size_t len, char *utf8_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf32_to_utf8(buf, len,
-                                                                   utf8_buffer);
-}
-simdutf_warn_unused size_t convert_utf32_to_utf16(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf32_to_utf16be(buf, len, utf16_buffer);
-#else
-  return convert_utf32_to_utf16le(buf, len, utf16_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_utf32_to_latin1(
-    const char32_t *input, size_t length, char *latin1_output) noexcept {
-  return get_default_implementation()->convert_utf32_to_latin1(input, length,
-                                                               latin1_output);
-}
-simdutf_warn_unused size_t convert_utf32_to_utf16le(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf16le(buf, len,
-                                                                utf16_buffer);
-}
-simdutf_warn_unused size_t convert_utf32_to_utf16be(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf16be(buf, len,
-                                                                utf16_buffer);
-}
-simdutf_warn_unused result convert_utf32_to_utf16_with_errors(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf32_to_utf16be_with_errors(buf, len, utf16_buffer);
-#else
-  return convert_utf32_to_utf16le_with_errors(buf, len, utf16_buffer);
-#endif
-}
-simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf16le_with_errors(
-      buf, len, utf16_buffer);
-}
-simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_utf32_to_utf16be_with_errors(
-      buf, len, utf16_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf32_to_utf16(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_valid_utf32_to_utf16be(buf, len, utf16_buffer);
-#else
-  return convert_valid_utf32_to_utf16le(buf, len, utf16_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf32_to_utf16le(
-      buf, len, utf16_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
-    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf32_to_utf16be(
-      buf, len, utf16_buffer);
-}
-simdutf_warn_unused size_t convert_utf16_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_utf32(buf, len, utf32_buffer);
-#else
-  return convert_utf16le_to_utf32(buf, len, utf32_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_utf16le_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_utf32(buf, len,
-                                                                utf32_buffer);
-}
-simdutf_warn_unused size_t convert_utf16be_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_utf32(buf, len,
-                                                                utf32_buffer);
-}
-simdutf_warn_unused result convert_utf16_to_utf32_with_errors(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_utf16be_to_utf32_with_errors(buf, len, utf32_buffer);
-#else
-  return convert_utf16le_to_utf32_with_errors(buf, len, utf32_buffer);
-#endif
-}
-simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_utf16le_to_utf32_with_errors(
-      buf, len, utf32_buffer);
-}
-simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_utf16be_to_utf32_with_errors(
-      buf, len, utf32_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return convert_valid_utf16be_to_utf32(buf, len, utf32_buffer);
-#else
-  return convert_valid_utf16le_to_utf32(buf, len, utf32_buffer);
-#endif
-}
-simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16le_to_utf32(
-      buf, len, utf32_buffer);
-}
-simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
-    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
-  return get_default_implementation()->convert_valid_utf16be_to_utf32(
-      buf, len, utf32_buffer);
-}
-void change_endianness_utf16(const char16_t *input, size_t length,
-                             char16_t *output) noexcept {
-  get_default_implementation()->change_endianness_utf16(input, length, output);
-}
-simdutf_warn_unused size_t count_utf16(const char16_t *input,
-                                       size_t length) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return count_utf16be(input, length);
-#else
-  return count_utf16le(input, length);
-#endif
-}
-simdutf_warn_unused size_t count_utf16le(const char16_t *input,
-                                         size_t length) noexcept {
-  return get_default_implementation()->count_utf16le(input, length);
-}
-simdutf_warn_unused size_t count_utf16be(const char16_t *input,
-                                         size_t length) noexcept {
-  return get_default_implementation()->count_utf16be(input, length);
-}
-simdutf_warn_unused size_t count_utf8(const char *input,
-                                      size_t length) noexcept {
-  return get_default_implementation()->count_utf8(input, length);
-}
-simdutf_warn_unused size_t latin1_length_from_utf8(const char *buf,
-                                                   size_t len) noexcept {
-  return get_default_implementation()->latin1_length_from_utf8(buf, len);
-}
-simdutf_warn_unused size_t latin1_length_from_utf16(size_t len) noexcept {
-  return get_default_implementation()->latin1_length_from_utf16(len);
-}
-simdutf_warn_unused size_t latin1_length_from_utf32(size_t len) noexcept {
-  return get_default_implementation()->latin1_length_from_utf32(len);
-}
-simdutf_warn_unused size_t utf8_length_from_latin1(const char *buf,
-                                                   size_t len) noexcept {
-  return get_default_implementation()->utf8_length_from_latin1(buf, len);
-}
-simdutf_warn_unused size_t utf8_length_from_utf16(const char16_t *input,
-                                                  size_t length) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return utf8_length_from_utf16be(input, length);
-#else
-  return utf8_length_from_utf16le(input, length);
-#endif
-}
-simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t *input,
-                                                    size_t length) noexcept {
-  return get_default_implementation()->utf8_length_from_utf16le(input, length);
-}
-simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t *input,
-                                                    size_t length) noexcept {
-  return get_default_implementation()->utf8_length_from_utf16be(input, length);
-}
-simdutf_warn_unused size_t utf32_length_from_utf16(const char16_t *input,
-                                                   size_t length) noexcept {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return utf32_length_from_utf16be(input, length);
-#else
-  return utf32_length_from_utf16le(input, length);
-#endif
-}
-simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t *input,
-                                                     size_t length) noexcept {
-  return get_default_implementation()->utf32_length_from_utf16le(input, length);
-}
-simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t *input,
-                                                     size_t length) noexcept {
-  return get_default_implementation()->utf32_length_from_utf16be(input, length);
-}
-simdutf_warn_unused size_t utf16_length_from_utf8(const char *input,
-                                                  size_t length) noexcept {
-  return get_default_implementation()->utf16_length_from_utf8(input, length);
-}
-simdutf_warn_unused size_t utf16_length_from_latin1(size_t length) noexcept {
-  return get_default_implementation()->utf16_length_from_latin1(length);
-}
-simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t *input,
-                                                  size_t length) noexcept {
-  return get_default_implementation()->utf8_length_from_utf32(input, length);
-}
-simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t *input,
-                                                   size_t length) noexcept {
-  return get_default_implementation()->utf16_length_from_utf32(input, length);
-}
-simdutf_warn_unused size_t utf32_length_from_utf8(const char *input,
-                                                  size_t length) noexcept {
-  return get_default_implementation()->utf32_length_from_utf8(input, length);
-}
-
-simdutf_warn_unused size_t
-maximal_binary_length_from_base64(const char *input, size_t length) noexcept {
-  return get_default_implementation()->maximal_binary_length_from_base64(
-      input, length);
-}
-
-simdutf_warn_unused result base64_to_binary(
-    const char *input, size_t length, char *output, base64_options options,
-    last_chunk_handling_options last_chunk_handling_options) noexcept {
-  return get_default_implementation()->base64_to_binary(
-      input, length, output, options, last_chunk_handling_options);
-}
-
-simdutf_warn_unused size_t maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) noexcept {
-  return get_default_implementation()->maximal_binary_length_from_base64(
-      input, length);
-}
-
-simdutf_warn_unused result base64_to_binary(
-    const char16_t *input, size_t length, char *output, base64_options options,
-    last_chunk_handling_options last_chunk_handling_options) noexcept {
-  return get_default_implementation()->base64_to_binary(
-      input, length, output, options, last_chunk_handling_options);
-}
-
-template <typename chartype>
-simdutf_warn_unused result base64_to_binary_safe_impl(
-    const chartype *input, size_t length, char *output, size_t &outlen,
-    base64_options options,
-    last_chunk_handling_options last_chunk_handling_options) noexcept {
-  static_assert(std::is_same<chartype, char>::value ||
-                    std::is_same<chartype, char16_t>::value,
-                "Only char and char16_t are supported.");
-  // The implementation could be nicer, but we expect that most times, the user
-  // will provide us with a buffer that is large enough.
-  size_t max_length = maximal_binary_length_from_base64(input, length);
-  if (outlen >= max_length) {
-    // fast path
-    full_result r = get_default_implementation()->base64_to_binary_details(
-        input, length, output, options, last_chunk_handling_options);
-    if (r.error != error_code::INVALID_BASE64_CHARACTER &&
-        r.error != error_code::BASE64_EXTRA_BITS) {
-      outlen = r.output_count;
-      if (last_chunk_handling_options == stop_before_partial) {
-        if ((r.output_count % 3) != 0) {
-          bool empty_trail = true;
-          for (size_t i = r.input_count; i < length; i++) {
-            if (!scalar::base64::is_ascii_white_space_or_padding(input[i])) {
-              empty_trail = false;
-              break;
-            }
-          }
-          if (empty_trail) {
-            r.input_count = length;
-          }
-        }
-        return {r.error, r.input_count};
-      }
-      return {r.error, length};
-    }
-    return r;
-  }
-  // The output buffer is maybe too small. We will decode a truncated version of
-  // the input.
-  size_t outlen3 = outlen / 3 * 3; // round down to multiple of 3
-  size_t safe_input = base64_length_from_binary(outlen3, options);
-  full_result r = get_default_implementation()->base64_to_binary_details(
-      input, safe_input, output, options, loose);
-  if (r.error == error_code::INVALID_BASE64_CHARACTER) {
-    return r;
-  }
-  size_t offset =
-      (r.error == error_code::BASE64_INPUT_REMAINDER)
-          ? 1
-          : ((r.output_count % 3) == 0 ? 0 : (r.output_count % 3) + 1);
-  size_t output_index = r.output_count - (r.output_count % 3);
-  size_t input_index = safe_input;
-  // offset is a value that is no larger than 3. We backtrack
-  // by up to offset characters + an undetermined number of
-  // white space characters. It is expected that the next loop
-  // runs at most 3 times + the number of white space characters
-  // in between them, so we are not worried about performance.
-  while (offset > 0 && input_index > 0) {
-    chartype c = input[--input_index];
-    if (scalar::base64::is_ascii_white_space(c)) {
-      // skipping
-    } else {
-      offset--;
-    }
-  }
-  size_t remaining_out = outlen - output_index;
-  const chartype *tail_input = input + input_index;
-  size_t tail_length = length - input_index;
-  while (tail_length > 0 &&
-         scalar::base64::is_ascii_white_space(tail_input[tail_length - 1])) {
-    tail_length--;
-  }
-  size_t padding_characts = 0;
-  if (tail_length > 0 && tail_input[tail_length - 1] == '=') {
-    tail_length--;
-    padding_characts++;
-    while (tail_length > 0 &&
-           scalar::base64::is_ascii_white_space(tail_input[tail_length - 1])) {
-      tail_length--;
-    }
-    if (tail_length > 0 && tail_input[tail_length - 1] == '=') {
-      tail_length--;
-      padding_characts++;
-    }
-  }
-  // this will advance tail_input and tail_length
-  result rr = scalar::base64::base64_tail_decode_safe(
-      output + output_index, remaining_out, tail_input, tail_length,
-      padding_characts, options, last_chunk_handling_options);
-  outlen = output_index + remaining_out;
-  if (last_chunk_handling_options != stop_before_partial &&
-      rr.error == error_code::SUCCESS && padding_characts > 0) {
-    // additional checks
-    if ((outlen % 3 == 0) || ((outlen % 3) + 1 + padding_characts != 4)) {
-      rr.error = error_code::INVALID_BASE64_CHARACTER;
-    }
-  }
-  if (rr.error == error_code::SUCCESS &&
-      last_chunk_handling_options == stop_before_partial) {
-    if (tail_input > input + input_index) {
-      rr.count = tail_input - input;
-    } else if (r.input_count > 0) {
-      rr.count = r.input_count + rr.count;
-    }
-    return rr;
-  }
-  rr.count += input_index;
-  return rr;
-}
-
-simdutf_warn_unused size_t convert_latin1_to_utf8_safe(
-    const char *buf, size_t len, char *utf8_output, size_t utf8_len) noexcept {
-  const auto start{utf8_output};
-
-  while (true) {
-    // convert_latin1_to_utf8 will never write more than input length * 2
-    auto read_len = std::min(len, utf8_len >> 1);
-    if (read_len <= 16) {
-      break;
-    }
-
-    const auto write_len =
-        simdutf::convert_latin1_to_utf8(buf, read_len, utf8_output);
-
-    utf8_output += write_len;
-    utf8_len -= write_len;
-    buf += read_len;
-    len -= read_len;
-  }
-
-  utf8_output +=
-      scalar::latin1_to_utf8::convert_safe(buf, len, utf8_output, utf8_len);
-
-  return utf8_output - start;
-}
-
-simdutf_warn_unused result base64_to_binary_safe(
-    const char *input, size_t length, char *output, size_t &outlen,
-    base64_options options,
-    last_chunk_handling_options last_chunk_handling_options) noexcept {
-  return base64_to_binary_safe_impl<char>(input, length, output, outlen,
-                                          options, last_chunk_handling_options);
-}
-simdutf_warn_unused result base64_to_binary_safe(
-    const char16_t *input, size_t length, char *output, size_t &outlen,
-    base64_options options,
-    last_chunk_handling_options last_chunk_handling_options) noexcept {
-  return base64_to_binary_safe_impl<char16_t>(
-      input, length, output, outlen, options, last_chunk_handling_options);
-}
-
-simdutf_warn_unused size_t
-base64_length_from_binary(size_t length, base64_options options) noexcept {
-  return get_default_implementation()->base64_length_from_binary(length,
-                                                                 options);
-}
-
-size_t binary_to_base64(const char *input, size_t length, char *output,
-                        base64_options options) noexcept {
-  return get_default_implementation()->binary_to_base64(input, length, output,
-                                                        options);
-}
-
-simdutf_warn_unused simdutf::encoding_type
-autodetect_encoding(const char *buf, size_t length) noexcept {
-  return get_default_implementation()->autodetect_encoding(buf, length);
-}
-simdutf_warn_unused int detect_encodings(const char *buf,
-                                         size_t length) noexcept {
-  return get_default_implementation()->detect_encodings(buf, length);
-}
-const implementation *builtin_implementation() {
-  static const implementation *builtin_impl =
-      get_available_implementations()[SIMDUTF_STRINGIFY(
-          SIMDUTF_BUILTIN_IMPLEMENTATION)];
-  return builtin_impl;
-}
-
-simdutf_warn_unused size_t trim_partial_utf8(const char *input, size_t length) {
-  return scalar::utf8::trim_partial_utf8(input, length);
-}
-
-simdutf_warn_unused size_t trim_partial_utf16be(const char16_t *input,
-                                                size_t length) {
-  return scalar::utf16::trim_partial_utf16<BIG>(input, length);
-}
-
-simdutf_warn_unused size_t trim_partial_utf16le(const char16_t *input,
-                                                size_t length) {
-  return scalar::utf16::trim_partial_utf16<LITTLE>(input, length);
-}
-
-simdutf_warn_unused size_t trim_partial_utf16(const char16_t *input,
-                                              size_t length) {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return trim_partial_utf16be(input, length);
-#else
-  return trim_partial_utf16le(input, length);
-#endif
-}
-
-} // namespace simdutf
-/* end file src/implementation.cpp */
-/* begin file src/encoding_types.cpp */
-
-namespace simdutf {
-bool match_system(endianness e) {
-#if SIMDUTF_IS_BIG_ENDIAN
-  return e == endianness::BIG;
-#else
-  return e == endianness::LITTLE;
-#endif
-}
-
-std::string to_string(encoding_type bom) {
-  switch (bom) {
-  case UTF16_LE:
-    return "UTF16 little-endian";
-  case UTF16_BE:
-    return "UTF16 big-endian";
-  case UTF32_LE:
-    return "UTF32 little-endian";
-  case UTF32_BE:
-    return "UTF32 big-endian";
-  case UTF8:
-    return "UTF8";
-  case unspecified:
-    return "unknown";
-  default:
-    return "error";
-  }
-}
-
-namespace BOM {
-// Note that BOM for UTF8 is discouraged.
-encoding_type check_bom(const uint8_t *byte, size_t length) {
-  if (length >= 2 && byte[0] == 0xff and byte[1] == 0xfe) {
-    if (length >= 4 && byte[2] == 0x00 and byte[3] == 0x0) {
-      return encoding_type::UTF32_LE;
-    } else {
-      return encoding_type::UTF16_LE;
-    }
-  } else if (length >= 2 && byte[0] == 0xfe and byte[1] == 0xff) {
-    return encoding_type::UTF16_BE;
-  } else if (length >= 4 && byte[0] == 0x00 and byte[1] == 0x00 and
-             byte[2] == 0xfe and byte[3] == 0xff) {
-    return encoding_type::UTF32_BE;
-  } else if (length >= 4 && byte[0] == 0xef and byte[1] == 0xbb and
-             byte[2] == 0xbf) {
-    return encoding_type::UTF8;
-  }
-  return encoding_type::unspecified;
-}
-
-encoding_type check_bom(const char *byte, size_t length) {
-  return check_bom(reinterpret_cast<const uint8_t *>(byte), length);
-}
-
-size_t bom_byte_size(encoding_type bom) {
-  switch (bom) {
-  case UTF16_LE:
-    return 2;
-  case UTF16_BE:
-    return 2;
-  case UTF32_LE:
-    return 4;
-  case UTF32_BE:
-    return 4;
-  case UTF8:
-    return 3;
-  case unspecified:
-    return 0;
-  default:
-    return 0;
-  }
-}
-
-} // namespace BOM
-} // namespace simdutf
-/* end file src/encoding_types.cpp */
-/* begin file src/error.cpp */
-namespace simdutf {
-// deliberately empty
-}
-/* end file src/error.cpp */
-// The large tables should be included once and they
-// should not depend on a kernel.
-/* begin file src/tables/utf8_to_utf16_tables.h */
-#ifndef SIMDUTF_UTF8_TO_UTF16_TABLES_H
-#define SIMDUTF_UTF8_TO_UTF16_TABLES_H
-#include <cstdint>
-
-namespace simdutf {
-namespace {
-namespace tables {
-namespace utf8_to_utf16 {
-/**
- * utf8bigindex uses about 8 kB
- * shufutf8 uses about 3344 B
- *
- * So we use a bit over 11 kB. It would be
- * easy to save about 4 kB by only
- * storing the index in utf8bigindex, and
- * deriving the consumed bytes otherwise.
- * However, this may come at a significant (10% to 20%)
- * performance penalty.
- */
+namespace tables {
+namespace utf8_to_utf16 {
+/**
+ * utf8bigindex uses about 8 kB
+ * shufutf8 uses about 3344 B
+ *
+ * So we use a bit over 11 kB. It would be
+ * easy to save about 4 kB by only
+ * storing the index in utf8bigindex, and
+ * deriving the consumed bytes otherwise.
+ * However, this may come at a significant (10% to 20%)
+ * performance penalty.
+ */
 
 const uint8_t shufutf8[209][16] = {
     {0, 255, 1, 255, 2, 255, 3, 255, 4, 255, 5, 255, 0, 0, 0, 0},
@@ -13360,3006 +1602,15783 @@ const uint8_t utf8bigindex[4096][2] = {
     {193, 6},  {82, 6},   {48, 8},   {8, 7},    {118, 6},  {16, 7},   {32, 7},
     {0, 6}};
 } // namespace utf8_to_utf16
-} // namespace tables
+} // namespace tables
+} // unnamed namespace
+} // namespace simdutf
+
+#endif // SIMDUTF_UTF8_TO_UTF16_TABLES_H
+/* end file src/tables/utf8_to_utf16_tables.h */
+/* begin file src/tables/utf16_to_utf8_tables.h */
+// file generated by scripts/sse_convert_utf16_to_utf8.py
+#ifndef SIMDUTF_UTF16_TO_UTF8_TABLES_H
+#define SIMDUTF_UTF16_TO_UTF8_TABLES_H
+
+namespace simdutf {
+namespace {
+namespace tables {
+namespace utf16_to_utf8 {
+
+// 1 byte for length, 16 bytes for mask
+const uint8_t pack_1_2_utf8_bytes[256][17] = {
+    {16, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14},
+    {15, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
+    {15, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80},
+    {14, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {15, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
+    {14, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {14, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80},
+    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {15, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
+    {14, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {14, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80},
+    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {15, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
+    {14, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {14, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80},
+    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
+    {13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
+    {13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
+    {12, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {12, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
+    {11, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {11, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {11, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 1, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 1, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80}};
+
+// 1 byte for length, 16 bytes for mask
+const uint8_t pack_1_2_3_utf8_bytes[256][17] = {
+    {12, 2, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80},
+    {9, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {11, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {10, 0, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 2, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {11, 2, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {10, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {10, 2, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 0, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 2, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 2, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {8, 2, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {11, 2, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {10, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {10, 2, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 0, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 2, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {10, 2, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 0, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 2, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 2, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 2, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 2, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {8, 2, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 2, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {3, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {1, 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {5, 2, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 0, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 2, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {3, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {2, 0, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {8, 2, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 2, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 0, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {7, 2, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 0, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 2, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {3, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 0, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 2, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {3, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {2, 0, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 2, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {3, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 2, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 0, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {11, 2, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {10, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {9, 0, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {10, 2, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 0, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 2, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 2, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {4, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {3, 0, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {7, 2, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 2, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {10, 2, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 0, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 2, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 2, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 2, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 2, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {8, 2, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {10, 2, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {7, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {9, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {8, 0, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 2, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {9, 2, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {8, 2, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 0, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 2, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80, 0x80},
+    {3, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {2, 0, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 2, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {3, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 2, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 0, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {9, 2, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
+    {6, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {7, 0, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 2, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {8, 2, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 2, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {6, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {5, 0, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {8, 2, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {7, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {6, 0, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 2, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {2, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {4, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {3, 0, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {7, 2, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {4, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {5, 0, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {6, 2, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80},
+    {3, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80, 0x80},
+    {5, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80},
+    {4, 0, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+     0x80, 0x80}};
+
+} // namespace utf16_to_utf8
+} // namespace tables
+} // unnamed namespace
+} // namespace simdutf
+
+#endif // SIMDUTF_UTF16_TO_UTF8_TABLES_H
+/* end file src/tables/utf16_to_utf8_tables.h */
+// End of tables.
+
+// Implementations: they need to be setup before including
+// scalar/* code, as the scalar code is sometimes enabled
+// only for peculiar build targets.
+
+// The best choice should always come first!
+/* begin file src/simdutf/arm64.h */
+#ifndef SIMDUTF_ARM64_H
+#define SIMDUTF_ARM64_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "arm64.h must be included before fallback.h"
+#endif
+
+
+#ifndef SIMDUTF_IMPLEMENTATION_ARM64
+  #define SIMDUTF_IMPLEMENTATION_ARM64 (SIMDUTF_IS_ARM64)
+#endif
+#if SIMDUTF_IMPLEMENTATION_ARM64 && SIMDUTF_IS_ARM64
+  #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 0
+#endif
+
+
+#if SIMDUTF_IMPLEMENTATION_ARM64
+
+namespace simdutf {
+/**
+ * Implementation for NEON (ARMv8).
+ */
+namespace arm64 {} // namespace arm64
+} // namespace simdutf
+
+/* begin file src/simdutf/arm64/implementation.h */
+#ifndef SIMDUTF_ARM64_IMPLEMENTATION_H
+#define SIMDUTF_ARM64_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace arm64 {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("arm64", "ARM NEON",
+                                internal::instruction_set::NEON) {}
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace arm64
+} // namespace simdutf
+
+#endif // SIMDUTF_ARM64_IMPLEMENTATION_H
+/* end file src/simdutf/arm64/implementation.h */
+
+/* begin file src/simdutf/arm64/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "arm64"
+// #define SIMDUTF_IMPLEMENTATION arm64
+/* end file src/simdutf/arm64/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/arm64/intrinsics.h */
+#ifndef SIMDUTF_ARM64_INTRINSICS_H
+#define SIMDUTF_ARM64_INTRINSICS_H
+
+
+// This should be the correct header whether
+// you use visual studio or other compilers.
+#include <arm_neon.h>
+
+#endif //  SIMDUTF_ARM64_INTRINSICS_H
+/* end file src/simdutf/arm64/intrinsics.h */
+/* begin file src/simdutf/arm64/bitmanipulation.h */
+#ifndef SIMDUTF_ARM64_BITMANIPULATION_H
+#define SIMDUTF_ARM64_BITMANIPULATION_H
+
+namespace simdutf {
+namespace arm64 {
+namespace {
+
+/* result might be undefined when input_num is zero */
+simdutf_really_inline int count_ones(uint64_t input_num) {
+  return vaddv_u8(vcnt_u8(vcreate_u8(input_num)));
+}
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
+  #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+  unsigned long ret;
+  // Search the mask data from least significant bit (LSB)
+  // to the most significant bit (MSB) for a set bit (1).
+  _BitScanForward64(&ret, input_num);
+  return (int)ret;
+  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
+  return __builtin_ctzll(input_num);
+  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+}
+#endif
+
+} // unnamed namespace
+} // namespace arm64
+} // namespace simdutf
+
+#endif // SIMDUTF_ARM64_BITMANIPULATION_H
+/* end file src/simdutf/arm64/bitmanipulation.h */
+/* begin file src/simdutf/arm64/simd.h */
+#ifndef SIMDUTF_ARM64_SIMD_H
+#define SIMDUTF_ARM64_SIMD_H
+
+#include <type_traits>
+
+namespace simdutf {
+namespace arm64 {
+namespace {
+namespace simd {
+
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+namespace {
+  // Start of private section with Visual Studio workaround
+
+  #ifndef simdutf_make_uint8x16_t
+    #define simdutf_make_uint8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10,   \
+                                    x11, x12, x13, x14, x15, x16)              \
+      ([=]() {                                                                 \
+        uint8_t array[16] = {x1, x2,  x3,  x4,  x5,  x6,  x7,  x8,             \
+                             x9, x10, x11, x12, x13, x14, x15, x16};           \
+        return vld1q_u8(array);                                                \
+      }())
+  #endif
+  #ifndef simdutf_make_int8x16_t
+    #define simdutf_make_int8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10,    \
+                                   x11, x12, x13, x14, x15, x16)               \
+      ([=]() {                                                                 \
+        int8_t array[16] = {x1, x2,  x3,  x4,  x5,  x6,  x7,  x8,              \
+                            x9, x10, x11, x12, x13, x14, x15, x16};            \
+        return vld1q_s8(array);                                                \
+      }())
+  #endif
+
+  #ifndef simdutf_make_uint8x8_t
+    #define simdutf_make_uint8x8_t(x1, x2, x3, x4, x5, x6, x7, x8)             \
+      ([=]() {                                                                 \
+        uint8_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                   \
+        return vld1_u8(array);                                                 \
+      }())
+  #endif
+  #ifndef simdutf_make_int8x8_t
+    #define simdutf_make_int8x8_t(x1, x2, x3, x4, x5, x6, x7, x8)              \
+      ([=]() {                                                                 \
+        int8_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                    \
+        return vld1_s8(array);                                                 \
+      }())
+  #endif
+  #ifndef simdutf_make_uint16x8_t
+    #define simdutf_make_uint16x8_t(x1, x2, x3, x4, x5, x6, x7, x8)            \
+      ([=]() {                                                                 \
+        uint16_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                  \
+        return vld1q_u16(array);                                               \
+      }())
+  #endif
+  #ifndef simdutf_make_int16x8_t
+    #define simdutf_make_int16x8_t(x1, x2, x3, x4, x5, x6, x7, x8)             \
+      ([=]() {                                                                 \
+        int16_t array[8] = {x1, x2, x3, x4, x5, x6, x7, x8};                   \
+        return vld1q_s16(array);                                               \
+      }())
+  #endif
+
+// End of private section with Visual Studio workaround
+} // namespace
+#endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+
+template <typename T> struct simd8;
+
+//
+// Base class of simd8<uint8_t> and simd8<bool>, both of which use uint8x16_t
+// internally.
+//
+template <typename T, typename Mask = simd8<bool>> struct base_u8 {
+  uint8x16_t value;
+  static const int SIZE = sizeof(value);
+
+  // Conversion from/to SIMD register
+  simdutf_really_inline base_u8(const uint8x16_t _value) : value(_value) {}
+  simdutf_really_inline operator const uint8x16_t &() const {
+    return this->value;
+  }
+  simdutf_really_inline operator uint8x16_t &() { return this->value; }
+  simdutf_really_inline T first() const { return vgetq_lane_u8(*this, 0); }
+  simdutf_really_inline T last() const { return vgetq_lane_u8(*this, 15); }
+
+  // Bit operations
+  simdutf_really_inline simd8<T> operator|(const simd8<T> other) const {
+    return vorrq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<T> operator&(const simd8<T> other) const {
+    return vandq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<T> operator^(const simd8<T> other) const {
+    return veorq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const {
+    return vbicq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+  simdutf_really_inline simd8<T> &operator|=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd8<T> &operator&=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd8<T> &operator^=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+
+  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return vceqq_u8(lhs, rhs);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
+    return vextq_u8(prev_chunk, *this, 16 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base_u8<bool> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return vmovq_n_u8(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8(const uint8x16_t _value)
+      : base_u8<bool>(_value) {}
+  // False constructor
+  simdutf_really_inline simd8() : simd8(vdupq_n_u8(0)) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : simd8(splat(_value)) {}
+  simdutf_really_inline void store(uint8_t dst[16]) const {
+    return vst1q_u8(dst, *this);
+  }
+
+  // We return uint32_t instead of uint16_t because that seems to be more
+  // efficient for most purposes (cutting it down to uint16_t costs performance
+  // in some compilers).
+  simdutf_really_inline uint32_t to_bitmask() const {
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+    const uint8x16_t bit_mask =
+        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
+#else
+    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
+#endif
+    auto minput = *this & bit_mask;
+    uint8x16_t tmp = vpaddq_u8(minput, minput);
+    tmp = vpaddq_u8(tmp, tmp);
+    tmp = vpaddq_u8(tmp, tmp);
+    return vgetq_lane_u16(vreinterpretq_u16_u8(tmp), 0);
+  }
+
+  // Returns 4-bit out of each byte, alternating between the high 4 bits and low
+  // bits result it is 64 bit. This method is expected to be faster than none()
+  // and is equivalent when the vector register is the result of a comparison,
+  // with byte values 0xff and 0x00.
+  simdutf_really_inline uint64_t to_bitmask64() const {
+    return vget_lane_u64(
+        vreinterpret_u64_u8(vshrn_n_u16(vreinterpretq_u16_u8(*this), 4)), 0);
+  }
+
+  simdutf_really_inline bool any() const {
+    return vmaxvq_u32(vreinterpretq_u32_u8(*this)) != 0;
+  }
+  simdutf_really_inline bool none() const {
+    return vmaxvq_u32(vreinterpretq_u32_u8(*this)) == 0;
+  }
+  simdutf_really_inline bool all() const {
+    return vminvq_u32(vreinterpretq_u32_u8(*this)) == 0xFFFFF;
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base_u8<uint8_t> {
+  static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value) {
+    return vmovq_n_u8(_value);
+  }
+  static simdutf_really_inline simd8<uint8_t> zero() { return vdupq_n_u8(0); }
+  static simdutf_really_inline simd8<uint8_t> load(const uint8_t *values) {
+    return vld1q_u8(values);
+  }
+  simdutf_really_inline simd8(const uint8x16_t _value)
+      : base_u8<uint8_t>(_value) {}
+  // Zero constructor
+  simdutf_really_inline simd8() : simd8(zero()) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t values[16]) : simd8(load(values)) {}
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Member-by-member initialization
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
+      : simd8(simdutf_make_uint8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                                      v10, v11, v12, v13, v14, v15)) {}
+#else
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
+      : simd8(uint8x16_t{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15}) {}
+#endif
+
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15);
+  }
+
+  // Store to array
+  simdutf_really_inline void store(uint8_t dst[16]) const {
+    return vst1q_u8(dst, *this);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return vqaddq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return vqsubq_u8(*this, other);
+  }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<uint8_t>
+  operator+(const simd8<uint8_t> other) const {
+    return vaddq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  operator-(const simd8<uint8_t> other) const {
+    return vsubq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t> &operator+=(const simd8<uint8_t> other) {
+    *this = *this + other;
+    return *this;
+  }
+  simdutf_really_inline simd8<uint8_t> &operator-=(const simd8<uint8_t> other) {
+    *this = *this - other;
+    return *this;
+  }
+
+  // Order-specific operations
+  simdutf_really_inline uint8_t max_val() const { return vmaxvq_u8(*this); }
+  simdutf_really_inline uint8_t min_val() const { return vminvq_u8(*this); }
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return vmaxq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return vminq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return vcleq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return vcgeq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return vcltq_u8(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return vcgtq_u8(*this, other);
+  }
+  // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
+  // = nonzero. For ARM, returns all 1's.
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return simd8<uint8_t>(*this > other);
+  }
+  // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
+  // = nonzero. For ARM, returns all 1's.
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return simd8<uint8_t>(*this < other);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return vtstq_u8(*this, bits);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    return this->max_val() < 0b10000000u;
+  }
+
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return this->max_val() != 0;
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return (*this & bits).any_bits_set_anywhere();
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return vshrq_n_u8(*this, N);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return vshlq_n_u8(*this, N);
+  }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return lookup_table.apply_lookup_16_to(*this);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+
+  template <typename T>
+  simdutf_really_inline simd8<uint8_t>
+  apply_lookup_16_to(const simd8<T> original) const {
+    return vqtbl1q_u8(*this, simd8<uint8_t>(original));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> {
+  int8x16_t value;
+
+  static simdutf_really_inline simd8<int8_t> splat(int8_t _value) {
+    return vmovq_n_s8(_value);
+  }
+  static simdutf_really_inline simd8<int8_t> zero() { return vdupq_n_s8(0); }
+  static simdutf_really_inline simd8<int8_t> load(const int8_t values[16]) {
+    return vld1q_s8(values);
+  }
+
+  // Use ST2 instead of UXTL+UXTL2 to interleave zeroes. UXTL is actually a
+  // USHLL #0, and shifting in NEON is actually quite slow.
+  //
+  // While this needs the registers to be in a specific order, bigger cores can
+  // interleave these with no overhead, and it still performs decently on little
+  // cores.
+  //    movi  v1.3d, #0
+  //      mov   v0.16b, value[0]
+  //    st2   {v0.16b, v1.16b}, [ptr], #32
+  //      mov   v0.16b, value[1]
+  //    st2   {v0.16b, v1.16b}, [ptr], #32
+  //    ...
+  template <endianness big_endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
+    int8x16x2_t pair = match_system(big_endian)
+                           ? int8x16x2_t{{this->value, vmovq_n_s8(0)}}
+                           : int8x16x2_t{{vmovq_n_s8(0), this->value}};
+    vst2q_s8(reinterpret_cast<int8_t *>(p), pair);
+  }
+
+  // currently unused
+  // Technically this could be done with ST4 like in store_ascii_as_utf16, but
+  // it is very much not worth it, as explicitly mentioned in the ARM Cortex-X1
+  // Core Software Optimization Guide:
+  //   4.18 Complex ASIMD instructions
+  //     The bandwidth of [ST4 with element size less than 64b] is limited by
+  //     decode constraints and it is advisable to avoid them when high
+  //     performing code is desired.
+  // Instead, it is better to use ZIP1+ZIP2 and two ST2.
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
+    const uint16x8_t low =
+        vreinterpretq_u16_s8(vzip1q_s8(this->value, vmovq_n_s8(0)));
+    const uint16x8_t high =
+        vreinterpretq_u16_s8(vzip2q_s8(this->value, vmovq_n_s8(0)));
+    const uint16x8x2_t low_pair{{low, vmovq_n_u16(0)}};
+    vst2q_u16(reinterpret_cast<uint16_t *>(p), low_pair);
+    const uint16x8x2_t high_pair{{high, vmovq_n_u16(0)}};
+    vst2q_u16(reinterpret_cast<uint16_t *>(p + 8), high_pair);
+  }
+
+  // In places where the table can be reused, which is most uses in simdutf, it
+  // is worth it to do 4 table lookups, as there is no direct zero extension
+  // from u8 to u32.
+  simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t *p) const {
+    const simd8<uint8_t> tb1{0, 255, 255, 255, 1, 255, 255, 255,
+                             2, 255, 255, 255, 3, 255, 255, 255};
+    const simd8<uint8_t> tb2{4, 255, 255, 255, 5, 255, 255, 255,
+                             6, 255, 255, 255, 7, 255, 255, 255};
+    const simd8<uint8_t> tb3{8,  255, 255, 255, 9,  255, 255, 255,
+                             10, 255, 255, 255, 11, 255, 255, 255};
+    const simd8<uint8_t> tb4{12, 255, 255, 255, 13, 255, 255, 255,
+                             14, 255, 255, 255, 15, 255, 255, 255};
+
+    // encourage store pairing and interleaving
+    const auto shuf1 = this->apply_lookup_16_to(tb1);
+    const auto shuf2 = this->apply_lookup_16_to(tb2);
+    shuf1.store(reinterpret_cast<int8_t *>(p));
+    shuf2.store(reinterpret_cast<int8_t *>(p + 4));
+
+    const auto shuf3 = this->apply_lookup_16_to(tb3);
+    const auto shuf4 = this->apply_lookup_16_to(tb4);
+    shuf3.store(reinterpret_cast<int8_t *>(p + 8));
+    shuf4.store(reinterpret_cast<int8_t *>(p + 12));
+  }
+  // Conversion from/to SIMD register
+  simdutf_really_inline simd8(const int8x16_t _value) : value{_value} {}
+  simdutf_really_inline operator const int8x16_t &() const {
+    return this->value;
+  }
+#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
+  simdutf_really_inline operator const uint8x16_t() const {
+    return vreinterpretq_u8_s8(this->value);
+  }
+#endif
+  simdutf_really_inline operator int8x16_t &() { return this->value; }
+
+  // Zero constructor
+  simdutf_really_inline simd8() : simd8(zero()) {}
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
+                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
+                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
+      : simd8(simdutf_make_int8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                                     v10, v11, v12, v13, v14, v15)) {}
+#else
+  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
+                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
+                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
+      : simd8(int8x16_t{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                        v13, v14, v15}) {}
+#endif
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15);
+  }
+
+  // Store to array
+  simdutf_really_inline void store(int8_t dst[16]) const {
+    return vst1q_s8(dst, value);
+  }
+  // Explicit conversion to/from unsigned
+  //
+  // Under Visual Studio/ARM64 uint8x16_t and int8x16_t are apparently the same
+  // type. In theory, we could check this occurrence with std::same_as and
+  // std::enabled_if but it is C++14 and relatively ugly and hard to read.
+#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
+  simdutf_really_inline explicit simd8(const uint8x16_t other)
+      : simd8(vreinterpretq_s8_u8(other)) {}
+#endif
+  simdutf_really_inline operator simd8<uint8_t>() const {
+    return vreinterpretq_u8_s8(this->value);
+  }
+
+  simdutf_really_inline simd8<int8_t>
+  operator|(const simd8<int8_t> other) const {
+    return vorrq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator&(const simd8<int8_t> other) const {
+    return vandq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator^(const simd8<int8_t> other) const {
+    return veorq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  bit_andnot(const simd8<int8_t> other) const {
+    return vbicq_s8(value, other.value);
+  }
+
+  // Math
+  simdutf_really_inline simd8<int8_t>
+  operator+(const simd8<int8_t> other) const {
+    return vaddq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator-(const simd8<int8_t> other) const {
+    return vsubq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t> &operator+=(const simd8<int8_t> other) {
+    *this = *this + other;
+    return *this;
+  }
+  simdutf_really_inline simd8<int8_t> &operator-=(const simd8<int8_t> other) {
+    *this = *this - other;
+    return *this;
+  }
+
+  simdutf_really_inline int8_t max_val() const { return vmaxvq_s8(value); }
+  simdutf_really_inline int8_t min_val() const { return vminvq_s8(value); }
+  simdutf_really_inline bool is_ascii() const { return this->min_val() >= 0; }
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return vmaxq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return vminq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return vcgtq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return vcltq_s8(value, other.value);
+  }
+  simdutf_really_inline simd8<bool>
+  operator==(const simd8<int8_t> other) const {
+    return vceqq_s8(value, other.value);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd8<int8_t>
+  prev(const simd8<int8_t> prev_chunk) const {
+    return vextq_s8(prev_chunk, *this, 16 - N);
+  }
+
+  // Perform a lookup assuming no value is larger than 16
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return lookup_table.apply_lookup_16_to(*this);
+  }
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+
+  template <typename T>
+  simdutf_really_inline simd8<int8_t>
+  apply_lookup_16_to(const simd8<T> original) const {
+    return vqtbl1q_s8(*this, simd8<uint8_t>(original));
+  }
+};
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(NUM_CHUNKS == 4,
+                "ARM kernel should use four registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
+                                 const simd8<T> chunk2, const simd8<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    this->chunks[2] |= other.chunks[2];
+    this->chunks[3] |= other.chunks[3];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
+
+  template <endianness endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 0);
+    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 1);
+    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 2);
+    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
+    this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
+    this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
+    this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+    const uint8x16_t bit_mask =
+        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
+#else
+    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
+#endif
+    // Add each of the elements next to each other, successively, to stuff each
+    // 8 byte mask into one.
+    uint8x16_t sum0 =
+        vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[0]), bit_mask),
+                  vandq_u8(uint8x16_t(this->chunks[1]), bit_mask));
+    uint8x16_t sum1 =
+        vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[2]), bit_mask),
+                  vandq_u8(uint8x16_t(this->chunks[3]), bit_mask));
+    sum0 = vpaddq_u8(sum0, sum1);
+    sum0 = vpaddq_u8(sum0, sum0);
+    return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                          this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                          this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+    return simd8x64<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
+               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
+               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                          this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
+                          this->chunks[2] > mask, this->chunks[3] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
+                          this->chunks[2] >= mask, this->chunks[3] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>(simd8<uint8_t>(uint8x16_t(this->chunks[0])) >= mask,
+                          simd8<uint8_t>(uint8x16_t(this->chunks[1])) >= mask,
+                          simd8<uint8_t>(uint8x16_t(this->chunks[2])) >= mask,
+                          simd8<uint8_t>(uint8x16_t(this->chunks[3])) >= mask)
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+/* begin file src/simdutf/arm64/simd16-inl.h */
+template <typename T> struct simd16;
+
+template <typename T, typename Mask = simd16<bool>> struct base_u16 {
+  uint16x8_t value;
+  static const int SIZE = sizeof(value);
+
+  // Conversion from/to SIMD register
+  simdutf_really_inline base_u16() = default;
+  simdutf_really_inline base_u16(const uint16x8_t _value) : value(_value) {}
+  simdutf_really_inline operator const uint16x8_t &() const {
+    return this->value;
+  }
+  simdutf_really_inline operator uint16x8_t &() { return this->value; }
+  // Bit operations
+  simdutf_really_inline simd16<T> operator|(const simd16<T> other) const {
+    return vorrq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator&(const simd16<T> other) const {
+    return vandq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator^(const simd16<T> other) const {
+    return veorq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const {
+    return vbicq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
+  simdutf_really_inline simd16<T> &operator|=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd16<T> &operator&=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd16<T> &operator^=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+
+  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
+                                               const simd16<T> rhs) {
+    return vceqq_u16(lhs, rhs);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return vextq_u18(prev_chunk, *this, 8 - N);
+  }
+};
+
+template <typename T, typename Mask = simd16<bool>>
+struct base16 : base_u16<T> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  simdutf_really_inline base16() : base_u16<T>() {}
+  simdutf_really_inline base16(const uint16x8_t _value) : base_u16<T>(_value) {}
+  template <typename Pointer>
+  simdutf_really_inline base16(const Pointer *ptr) : base16(vld1q_u16(ptr)) {}
+
+  static const int SIZE = sizeof(base_u16<T>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return vextq_u18(prev_chunk, *this, 8 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd16<bool> : base16<bool> {
+  static simdutf_really_inline simd16<bool> splat(bool _value) {
+    return vmovq_n_u16(uint16_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd16() : base16() {}
+  simdutf_really_inline simd16(const uint16x8_t _value)
+      : base16<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
+};
+
+template <typename T> struct base16_numeric : base16<T> {
+  static simdutf_really_inline simd16<T> splat(T _value) {
+    return vmovq_n_u16(_value);
+  }
+  static simdutf_really_inline simd16<T> zero() { return vdupq_n_u16(0); }
+  static simdutf_really_inline simd16<T> load(const T values[8]) {
+    return vld1q_u16(reinterpret_cast<const uint16_t *>(values));
+  }
+
+  simdutf_really_inline base16_numeric() : base16<T>() {}
+  simdutf_really_inline base16_numeric(const uint16x8_t _value)
+      : base16<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[8]) const {
+    return vst1q_u16(dst, *this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
+    return vaddq_u8(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
+    return vsubq_u8(*this, other);
+  }
+  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
+    *this = *this + other;
+    return *static_cast<simd16<T> *>(this);
+  }
+  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
+    *this = *this - other;
+    return *static_cast<simd16<T> *>(this);
+  }
+};
+
+// Signed code units
+template <> struct simd16<int16_t> : base16_numeric<int16_t> {
+  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
+#ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
+  simdutf_really_inline simd16(const uint16x8_t _value)
+      : base16_numeric<int16_t>(_value) {}
+#endif
+  simdutf_really_inline simd16(const int16x8_t _value)
+      : base16_numeric<int16_t>(vreinterpretq_u16_s16(_value)) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
+  simdutf_really_inline operator simd16<uint16_t>() const;
+  simdutf_really_inline operator const uint16x8_t &() const {
+    return this->value;
+  }
+  simdutf_really_inline operator const int16x8_t() const {
+    return vreinterpretq_s16_u16(this->value);
+  }
+
+  simdutf_really_inline int16_t max_val() const {
+    return vmaxvq_s16(vreinterpretq_s16_u16(this->value));
+  }
+  simdutf_really_inline int16_t min_val() const {
+    return vminvq_s16(vreinterpretq_s16_u16(this->value));
+  }
+  // Order-sensitive comparisons
+  simdutf_really_inline simd16<int16_t>
+  max_val(const simd16<int16_t> other) const {
+    return vmaxq_s16(vreinterpretq_s16_u16(this->value),
+                     vreinterpretq_s16_u16(other.value));
+  }
+  simdutf_really_inline simd16<int16_t>
+  min_val(const simd16<int16_t> other) const {
+    return vmaxq_s16(vreinterpretq_s16_u16(this->value),
+                     vreinterpretq_s16_u16(other.value));
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<int16_t> other) const {
+    return vcgtq_s16(vreinterpretq_s16_u16(this->value),
+                     vreinterpretq_s16_u16(other.value));
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<int16_t> other) const {
+    return vcltq_s16(vreinterpretq_s16_u16(this->value),
+                     vreinterpretq_s16_u16(other.value));
+  }
+};
+
+// Unsigned code units
+template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
+  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
+  simdutf_really_inline simd16(const uint16x8_t _value)
+      : base16_numeric<uint16_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
+
+  simdutf_really_inline int16_t max_val() const { return vmaxvq_u16(*this); }
+  simdutf_really_inline int16_t min_val() const { return vminvq_u16(*this); }
+  // Saturated math
+  simdutf_really_inline simd16<uint16_t>
+  saturating_add(const simd16<uint16_t> other) const {
+    return vqaddq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  saturating_sub(const simd16<uint16_t> other) const {
+    return vqsubq_u16(*this, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd16<uint16_t>
+  max_val(const simd16<uint16_t> other) const {
+    return vmaxq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  min_val(const simd16<uint16_t> other) const {
+    return vminq_u16(*this, other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  gt_bits(const simd16<uint16_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  lt_bits(const simd16<uint16_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<=(const simd16<uint16_t> other) const {
+    return vcleq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>=(const simd16<uint16_t> other) const {
+    return vcgeq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<uint16_t> other) const {
+    return vcgtq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<uint16_t> other) const {
+    return vcltq_u16(*this, other);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd16<bool> bits_not_set() const {
+    return *this == uint16_t(0);
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
+    return simd16<uint16_t>(vshrq_n_u16(*this, N));
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
+    return simd16<uint16_t>(vshlq_n_u16(*this, N));
+  }
+
+  // logical operations
+  simdutf_really_inline simd16<uint16_t>
+  operator|(const simd16<uint16_t> other) const {
+    return vorrq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  operator&(const simd16<uint16_t> other) const {
+    return vandq_u16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  operator^(const simd16<uint16_t> other) const {
+    return veorq_u16(*this, other);
+  }
+
+  // Pack with the unsigned saturation of two uint16_t code units into single
+  // uint8_t vector
+  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
+                                                   const simd16<uint16_t> &v1) {
+    return vqmovn_high_u16(vqmovn_u16(v0), v1);
+  }
+
+  // Change the endianness
+  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
+    return vreinterpretq_u16_u8(vrev16q_u8(vreinterpretq_u8_u16(*this)));
+  }
+};
+simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd16x32 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
+  static_assert(NUM_CHUNKS == 4,
+                "ARM kernel should use four registers per 64-byte block.");
+  simd16<T> chunks[NUM_CHUNKS];
+
+  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
+  simd16x32<T> &
+  operator=(const simd16<T> other) = delete; // no assignment allowed
+  simd16x32() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline
+  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
+            const simd16<T> chunk2, const simd16<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd16x32(const T *ptr)
+      : chunks{simd16<T>::load(ptr),
+               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd16<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
+
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
+    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
+    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
+    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+    const uint8x16_t bit_mask =
+        simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
+#else
+    const uint8x16_t bit_mask = {0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
+                                 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
+#endif
+    // Add each of the elements next to each other, successively, to stuff each
+    // 8 byte mask into one.
+    uint8x16_t sum0 = vpaddq_u8(
+        vreinterpretq_u8_u16(this->chunks[0] & vreinterpretq_u16_u8(bit_mask)),
+        vreinterpretq_u8_u16(this->chunks[1] & vreinterpretq_u16_u8(bit_mask)));
+    uint8x16_t sum1 = vpaddq_u8(
+        vreinterpretq_u8_u16(this->chunks[2] & vreinterpretq_u16_u8(bit_mask)),
+        vreinterpretq_u8_u16(this->chunks[3] & vreinterpretq_u16_u8(bit_mask)));
+    sum0 = vpaddq_u8(sum0, sum1);
+    sum0 = vpaddq_u8(sum0, sum0);
+    return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
+  }
+
+  simdutf_really_inline void swap_bytes() {
+    this->chunks[0] = this->chunks[0].swap_bytes();
+    this->chunks[1] = this->chunks[1].swap_bytes();
+    this->chunks[2] = this->chunks[2].swap_bytes();
+    this->chunks[3] = this->chunks[3].swap_bytes();
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                           this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                           this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+
+    return simd16x32<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+    return simd16x32<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
+               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
+               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                           this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+
+}; // struct simd16x32<T>
+template <>
+simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
+    const uint16_t low, const uint16_t high) const {
+  const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
+  const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
+  simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) |
+                                         (this->chunks[0] < mask_low)),
+                        simd16<uint16_t>((this->chunks[1] > mask_high) |
+                                         (this->chunks[1] < mask_low)),
+                        simd16<uint16_t>((this->chunks[2] > mask_high) |
+                                         (this->chunks[2] < mask_low)),
+                        simd16<uint16_t>((this->chunks[3] > mask_high) |
+                                         (this->chunks[3] < mask_low)));
+  return x.to_bitmask();
+}
+/* end file src/simdutf/arm64/simd16-inl.h */
+} // namespace simd
+} // unnamed namespace
+} // namespace arm64
+} // namespace simdutf
+
+#endif // SIMDUTF_ARM64_SIMD_H
+/* end file src/simdutf/arm64/simd.h */
+
+/* begin file src/simdutf/arm64/end.h */
+/* end file src/simdutf/arm64/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_ARM64
+
+#endif // SIMDUTF_ARM64_H
+/* end file src/simdutf/arm64.h */
+/* begin file src/simdutf/icelake.h */
+#ifndef SIMDUTF_ICELAKE_H
+#define SIMDUTF_ICELAKE_H
+
+
+#ifdef __has_include
+  // How do we detect that a compiler supports vbmi2?
+  // For sure if the following header is found, we are ok?
+  #if __has_include(<avx512vbmi2intrin.h>)
+    #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
+  #endif
+#endif
+
+#ifdef _MSC_VER
+  #if _MSC_VER >= 1930
+    // Visual Studio 2022 and up support VBMI2 under x64 even if the header
+    // avx512vbmi2intrin.h is not found.
+    // Visual Studio 2019 technically supports VBMI2, but the implementation
+    // might be unreliable. Search for visualstudio2019icelakeissue in our
+    // tests.
+    #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
+  #endif
+#endif
+
+// We allow icelake on x64 as long as the compiler is known to support VBMI2.
+#ifndef SIMDUTF_IMPLEMENTATION_ICELAKE
+  #define SIMDUTF_IMPLEMENTATION_ICELAKE                                       \
+    ((SIMDUTF_IS_X86_64) && (SIMDUTF_COMPILER_SUPPORTS_VBMI2))
+#endif
+
+// To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
+// https://github.com/simdutf/simdutf/issues/1247
+#if ((SIMDUTF_IMPLEMENTATION_ICELAKE) && (SIMDUTF_IS_X86_64) && (__AVX2__) &&  \
+     (SIMDUTF_HAS_AVX512F && SIMDUTF_HAS_AVX512DQ && SIMDUTF_HAS_AVX512VL &&   \
+      SIMDUTF_HAS_AVX512VBMI2) &&                                              \
+     (!SIMDUTF_IS_32BITS))
+  #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 0
+#endif
+
+#if SIMDUTF_IMPLEMENTATION_ICELAKE
+  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
+    #define SIMDUTF_TARGET_ICELAKE
+  #else
+    #define SIMDUTF_TARGET_ICELAKE                                             \
+      SIMDUTF_TARGET_REGION(                                                   \
+          "avx512f,avx512dq,avx512cd,avx512bw,avx512vbmi,avx512vbmi2,"         \
+          "avx512vl,avx2,bmi,bmi2,pclmul,lzcnt,popcnt,avx512vpopcntdq")
+  #endif
+
+namespace simdutf {
+namespace icelake {} // namespace icelake
+} // namespace simdutf
+
+  //
+  // These two need to be included outside SIMDUTF_TARGET_REGION
+  //
+/* begin file src/simdutf/icelake/intrinsics.h */
+#ifndef SIMDUTF_ICELAKE_INTRINSICS_H
+#define SIMDUTF_ICELAKE_INTRINSICS_H
+
+
+#ifdef SIMDUTF_VISUAL_STUDIO
+  // under clang within visual studio, this will include <x86intrin.h>
+  #include <intrin.h> // visual studio or clang
+  #include <immintrin.h>
+#else
+
+  #if SIMDUTF_GCC11ORMORE
+// We should not get warnings while including <x86intrin.h> yet we do
+// under some versions of GCC.
+// If the x86intrin.h header has uninitialized values that are problematic,
+// it is a GCC issue, we want to ignore these warnings.
+SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
+  #endif
+
+  #include <x86intrin.h> // elsewhere
+
+  #if SIMDUTF_GCC11ORMORE
+// cancels the suppression of the -Wuninitialized
+SIMDUTF_POP_DISABLE_WARNINGS
+  #endif
+
+  #ifndef _tzcnt_u64
+    #define _tzcnt_u64(x) __tzcnt_u64(x)
+  #endif // _tzcnt_u64
+#endif   // SIMDUTF_VISUAL_STUDIO
+
+#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
+  /**
+   * You are not supposed, normally, to include these
+   * headers directly. Instead you should either include intrin.h
+   * or x86intrin.h. However, when compiling with clang
+   * under Windows (i.e., when _MSC_VER is set), these headers
+   * only get included *if* the corresponding features are detected
+   * from macros:
+   * e.g., if __AVX2__ is set... in turn,  we normally set these
+   * macros by compiling against the corresponding architecture
+   * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
+   * software with these advanced instructions. In simdutf, we
+   * want to compile the whole program for a generic target,
+   * and only target our specific kernels. As a workaround,
+   * we directly include the needed headers. These headers would
+   * normally guard against such usage, but we carefully included
+   * <x86intrin.h>  (or <intrin.h>) before, so the headers
+   * are fooled.
+   */
+  #include <bmiintrin.h>   // for _blsr_u64
+  #include <bmi2intrin.h>  // for _pext_u64, _pdep_u64
+  #include <lzcntintrin.h> // for  __lzcnt64
+  #include <immintrin.h>   // for most things (AVX2, AVX512, _popcnt64)
+  #include <smmintrin.h>
+  #include <tmmintrin.h>
+  #include <avxintrin.h>
+  #include <avx2intrin.h>
+  // Important: we need the AVX-512 headers:
+  #include <avx512fintrin.h>
+  #include <avx512dqintrin.h>
+  #include <avx512cdintrin.h>
+  #include <avx512bwintrin.h>
+  #include <avx512vlintrin.h>
+  #include <avx512vlbwintrin.h>
+  #include <avx512vbmiintrin.h>
+  #include <avx512vbmi2intrin.h>
+  #include <avx512vpopcntdqintrin.h>
+  #include <avx512vpopcntdqvlintrin.h>
+  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
+  // has it as a macro.
+  #ifndef _blsr_u64
+    // we roll our own
+    #define _blsr_u64(n) ((n - 1) & n)
+  #endif //  _blsr_u64
+#endif   // SIMDUTF_CLANG_VISUAL_STUDIO
+
+#if defined(__GNUC__) && !defined(__clang__)
+
+  #if __GNUC__ == 8
+    #define SIMDUTF_GCC8 1
+  #elif __GNUC__ == 9
+    #define SIMDUTF_GCC9 1
+  #endif //  __GNUC__ == 8 || __GNUC__ == 9
+
+#endif // defined(__GNUC__) && !defined(__clang__)
+
+#if SIMDUTF_GCC8
+  #pragma GCC push_options
+  #pragma GCC target("avx512f")
+/**
+ * GCC 8 fails to provide _mm512_set_epi8. We roll our own.
+ */
+inline __m512i
+_mm512_set_epi8(uint8_t a0, uint8_t a1, uint8_t a2, uint8_t a3, uint8_t a4,
+                uint8_t a5, uint8_t a6, uint8_t a7, uint8_t a8, uint8_t a9,
+                uint8_t a10, uint8_t a11, uint8_t a12, uint8_t a13, uint8_t a14,
+                uint8_t a15, uint8_t a16, uint8_t a17, uint8_t a18, uint8_t a19,
+                uint8_t a20, uint8_t a21, uint8_t a22, uint8_t a23, uint8_t a24,
+                uint8_t a25, uint8_t a26, uint8_t a27, uint8_t a28, uint8_t a29,
+                uint8_t a30, uint8_t a31, uint8_t a32, uint8_t a33, uint8_t a34,
+                uint8_t a35, uint8_t a36, uint8_t a37, uint8_t a38, uint8_t a39,
+                uint8_t a40, uint8_t a41, uint8_t a42, uint8_t a43, uint8_t a44,
+                uint8_t a45, uint8_t a46, uint8_t a47, uint8_t a48, uint8_t a49,
+                uint8_t a50, uint8_t a51, uint8_t a52, uint8_t a53, uint8_t a54,
+                uint8_t a55, uint8_t a56, uint8_t a57, uint8_t a58, uint8_t a59,
+                uint8_t a60, uint8_t a61, uint8_t a62, uint8_t a63) {
+  return _mm512_set_epi64(
+      uint64_t(a7) + (uint64_t(a6) << 8) + (uint64_t(a5) << 16) +
+          (uint64_t(a4) << 24) + (uint64_t(a3) << 32) + (uint64_t(a2) << 40) +
+          (uint64_t(a1) << 48) + (uint64_t(a0) << 56),
+      uint64_t(a15) + (uint64_t(a14) << 8) + (uint64_t(a13) << 16) +
+          (uint64_t(a12) << 24) + (uint64_t(a11) << 32) +
+          (uint64_t(a10) << 40) + (uint64_t(a9) << 48) + (uint64_t(a8) << 56),
+      uint64_t(a23) + (uint64_t(a22) << 8) + (uint64_t(a21) << 16) +
+          (uint64_t(a20) << 24) + (uint64_t(a19) << 32) +
+          (uint64_t(a18) << 40) + (uint64_t(a17) << 48) + (uint64_t(a16) << 56),
+      uint64_t(a31) + (uint64_t(a30) << 8) + (uint64_t(a29) << 16) +
+          (uint64_t(a28) << 24) + (uint64_t(a27) << 32) +
+          (uint64_t(a26) << 40) + (uint64_t(a25) << 48) + (uint64_t(a24) << 56),
+      uint64_t(a39) + (uint64_t(a38) << 8) + (uint64_t(a37) << 16) +
+          (uint64_t(a36) << 24) + (uint64_t(a35) << 32) +
+          (uint64_t(a34) << 40) + (uint64_t(a33) << 48) + (uint64_t(a32) << 56),
+      uint64_t(a47) + (uint64_t(a46) << 8) + (uint64_t(a45) << 16) +
+          (uint64_t(a44) << 24) + (uint64_t(a43) << 32) +
+          (uint64_t(a42) << 40) + (uint64_t(a41) << 48) + (uint64_t(a40) << 56),
+      uint64_t(a55) + (uint64_t(a54) << 8) + (uint64_t(a53) << 16) +
+          (uint64_t(a52) << 24) + (uint64_t(a51) << 32) +
+          (uint64_t(a50) << 40) + (uint64_t(a49) << 48) + (uint64_t(a48) << 56),
+      uint64_t(a63) + (uint64_t(a62) << 8) + (uint64_t(a61) << 16) +
+          (uint64_t(a60) << 24) + (uint64_t(a59) << 32) +
+          (uint64_t(a58) << 40) + (uint64_t(a57) << 48) +
+          (uint64_t(a56) << 56));
+}
+  #pragma GCC pop_options
+#endif // SIMDUTF_GCC8
+
+#endif // SIMDUTF_HASWELL_INTRINSICS_H
+/* end file src/simdutf/icelake/intrinsics.h */
+/* begin file src/simdutf/icelake/implementation.h */
+#ifndef SIMDUTF_ICELAKE_IMPLEMENTATION_H
+#define SIMDUTF_ICELAKE_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace icelake {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation(
+            "icelake",
+            "Intel AVX512 (AVX-512BW, AVX-512CD, AVX-512VL, AVX-512VBMI2 "
+            "extensions)",
+            internal::instruction_set::AVX2 | internal::instruction_set::BMI1 |
+                internal::instruction_set::BMI2 |
+                internal::instruction_set::AVX512BW |
+                internal::instruction_set::AVX512CD |
+                internal::instruction_set::AVX512VL |
+                internal::instruction_set::AVX512VBMI2 |
+                internal::instruction_set::AVX512VPOPCNTDQ) {}
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace icelake
+} // namespace simdutf
+
+#endif // SIMDUTF_ICELAKE_IMPLEMENTATION_H
+/* end file src/simdutf/icelake/implementation.h */
+
+  //
+  // The rest need to be inside the region
+  //
+/* begin file src/simdutf/icelake/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "icelake"
+// #define SIMDUTF_IMPLEMENTATION icelake
+
+#if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
+// nothing needed.
+#else
+SIMDUTF_TARGET_ICELAKE
+#endif
+
+#if SIMDUTF_GCC11ORMORE // workaround for
+                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
+// clang-format off
+SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
+// clang-format on
+#endif // end of workaround
+/* end file src/simdutf/icelake/begin.h */
+  // Declarations
+/* begin file src/simdutf/icelake/bitmanipulation.h */
+#ifndef SIMDUTF_ICELAKE_BITMANIPULATION_H
+#define SIMDUTF_ICELAKE_BITMANIPULATION_H
+
+namespace simdutf {
+namespace icelake {
+namespace {
+
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
+  // note: we do not support legacy 32-bit Windows
+  return __popcnt64(input_num); // Visual Studio wants two underscores
+}
+#else
+simdutf_really_inline long long int count_ones(uint64_t input_num) {
+  return _popcnt64(input_num);
+}
+#endif
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
+  #if SIMDUTF_REGULAR_VISUAL_STUDIO
+  return (int)_tzcnt_u64(input_num);
+  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
+  return __builtin_ctzll(input_num);
+  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+}
+#endif
+
+} // unnamed namespace
+} // namespace icelake
+} // namespace simdutf
+
+#endif // SIMDUTF_ICELAKE_BITMANIPULATION_H
+/* end file src/simdutf/icelake/bitmanipulation.h */
+/* begin file src/simdutf/icelake/simd.h */
+#ifndef SIMDUTF_ICELAKE_SIMD_H
+#define SIMDUTF_ICELAKE_SIMD_H
+
+namespace simdutf {
+namespace icelake {
+namespace {
+namespace simd {
+
+/* begin file src/simdutf/icelake/simd32-inl.h */
+template <typename T> struct simd32;
+
+template <> struct simd32<uint32_t> {
+  static const size_t SIZE = sizeof(__m512i);
+  static const size_t ELEMENTS = SIZE / sizeof(uint32_t);
+
+  __m512i value;
+
+  simdutf_really_inline simd32(const __m512i v) : value(v) {}
+
+  template <typename Pointer>
+  simdutf_really_inline simd32(const Pointer *ptr)
+      : value(_mm512_loadu_si512(reinterpret_cast<const __m512i *>(ptr))) {}
+
+  uint64_t sum() const {
+    const __m512i mask = _mm512_set1_epi64(0xffffffff);
+    const __m512i t0 = _mm512_and_si512(value, mask);
+    const __m512i t1 = _mm512_srli_epi64(value, 32);
+    const __m512i t2 = _mm512_add_epi64(t0, t1);
+    return _mm512_reduce_add_epi64(t2);
+  }
+
+  // operators
+  simdutf_really_inline simd32 &operator+=(const simd32 other) {
+    value = _mm512_add_epi32(value, other.value);
+    return *this;
+  }
+
+  // static members
+  simdutf_really_inline static simd32<uint32_t> zero() {
+    return _mm512_setzero_si512();
+  }
+
+  simdutf_really_inline static simd32<uint32_t> splat(uint32_t v) {
+    return _mm512_set1_epi32(v);
+  }
+};
+
+simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> b,
+                                           const simd32<uint32_t> a) {
+  return _mm512_min_epu32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> b,
+                                                 const simd32<uint32_t> a) {
+  return _mm512_and_si512(a.value, b.value);
+}
+/* end file src/simdutf/icelake/simd32-inl.h */
+
+} // namespace simd
+} // unnamed namespace
+} // namespace icelake
+} // namespace simdutf
+
+#endif // SIMDUTF_ICELAKE_SIMD_H
+/* end file src/simdutf/icelake/simd.h */
+
+/* begin file src/simdutf/icelake/end.h */
+#if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
+// nothing needed.
+#else
+SIMDUTF_UNTARGET_REGION
+#endif
+
+
+#if SIMDUTF_GCC11ORMORE // workaround for
+                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
+SIMDUTF_POP_DISABLE_WARNINGS
+#endif // end of workaround
+/* end file src/simdutf/icelake/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_ICELAKE
+#endif // SIMDUTF_ICELAKE_H
+/* end file src/simdutf/icelake.h */
+/* begin file src/simdutf/haswell.h */
+#ifndef SIMDUTF_HASWELL_H
+#define SIMDUTF_HASWELL_H
+
+#ifdef SIMDUTF_WESTMERE_H
+  #error "haswell.h must be included before westmere.h"
+#endif
+#ifdef SIMDUTF_FALLBACK_H
+  #error "haswell.h must be included before fallback.h"
+#endif
+
+
+// Default Haswell to on if this is x86-64. Even if we are not compiled for it,
+// it could be selected at runtime.
+#ifndef SIMDUTF_IMPLEMENTATION_HASWELL
+  //
+  // You do not want to restrict it like so: SIMDUTF_IS_X86_64 && __AVX2__
+  // because we want to rely on *runtime dispatch*.
+  //
+  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
+    #define SIMDUTF_IMPLEMENTATION_HASWELL 0
+  #else
+    #define SIMDUTF_IMPLEMENTATION_HASWELL (SIMDUTF_IS_X86_64)
+  #endif
+
+#endif
+// To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
+// https://github.com/simdutf/simdutf/issues/1247
+#if ((SIMDUTF_IMPLEMENTATION_HASWELL) && (SIMDUTF_IS_X86_64) && (__AVX2__))
+  #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 0
+#endif
+
+#if SIMDUTF_IMPLEMENTATION_HASWELL
+
+  #define SIMDUTF_TARGET_HASWELL SIMDUTF_TARGET_REGION("avx2,bmi,lzcnt,popcnt")
+
+namespace simdutf {
+/**
+ * Implementation for Haswell (Intel AVX2).
+ */
+namespace haswell {} // namespace haswell
+} // namespace simdutf
+
+  //
+  // These two need to be included outside SIMDUTF_TARGET_REGION
+  //
+/* begin file src/simdutf/haswell/implementation.h */
+#ifndef SIMDUTF_HASWELL_IMPLEMENTATION_H
+#define SIMDUTF_HASWELL_IMPLEMENTATION_H
+
+
+// The constructor may be executed on any host, so we take care not to use
+// SIMDUTF_TARGET_REGION
+namespace simdutf {
+namespace haswell {
+
+using namespace simdutf;
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("haswell", "Intel/AMD AVX2",
+                                internal::instruction_set::AVX2 |
+                                    internal::instruction_set::BMI1 |
+                                    internal::instruction_set::BMI2) {}
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace haswell
+} // namespace simdutf
+
+#endif // SIMDUTF_HASWELL_IMPLEMENTATION_H
+/* end file src/simdutf/haswell/implementation.h */
+/* begin file src/simdutf/haswell/intrinsics.h */
+#ifndef SIMDUTF_HASWELL_INTRINSICS_H
+#define SIMDUTF_HASWELL_INTRINSICS_H
+
+
+#ifdef SIMDUTF_VISUAL_STUDIO
+  // under clang within visual studio, this will include <x86intrin.h>
+  #include <intrin.h> // visual studio or clang
+#else
+
+  #if SIMDUTF_GCC11ORMORE
+// We should not get warnings while including <x86intrin.h> yet we do
+// under some versions of GCC.
+// If the x86intrin.h header has uninitialized values that are problematic,
+// it is a GCC issue, we want to ignore these warnings.
+SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
+  #endif
+
+  #include <x86intrin.h> // elsewhere
+
+  #if SIMDUTF_GCC11ORMORE
+// cancels the suppression of the -Wuninitialized
+SIMDUTF_POP_DISABLE_WARNINGS
+  #endif
+
+#endif // SIMDUTF_VISUAL_STUDIO
+
+#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
+  /**
+   * You are not supposed, normally, to include these
+   * headers directly. Instead you should either include intrin.h
+   * or x86intrin.h. However, when compiling with clang
+   * under Windows (i.e., when _MSC_VER is set), these headers
+   * only get included *if* the corresponding features are detected
+   * from macros:
+   * e.g., if __AVX2__ is set... in turn,  we normally set these
+   * macros by compiling against the corresponding architecture
+   * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
+   * software with these advanced instructions. In simdutf, we
+   * want to compile the whole program for a generic target,
+   * and only target our specific kernels. As a workaround,
+   * we directly include the needed headers. These headers would
+   * normally guard against such usage, but we carefully included
+   * <x86intrin.h>  (or <intrin.h>) before, so the headers
+   * are fooled.
+   */
+  #include <bmiintrin.h>   // for _blsr_u64
+  #include <lzcntintrin.h> // for  __lzcnt64
+  #include <immintrin.h>   // for most things (AVX2, AVX512, _popcnt64)
+  #include <smmintrin.h>
+  #include <tmmintrin.h>
+  #include <avxintrin.h>
+  #include <avx2intrin.h>
+  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
+  // has it as a macro.
+  #ifndef _blsr_u64
+    // we roll our own
+    #define _blsr_u64(n) (((n) - 1) & (n))
+  #endif //  _blsr_u64
+  // Same issue with _blsmsk_u32:
+  #ifndef _blsmsk_u32
+    // we roll our own
+    #define _blsmsk_u32(n) (((n) - 1) ^ (n))
+  #endif //  _blsmsk_u32
+#endif   // SIMDUTF_CLANG_VISUAL_STUDIO
+
+#endif // SIMDUTF_HASWELL_INTRINSICS_H
+/* end file src/simdutf/haswell/intrinsics.h */
+
+  //
+  // The rest need to be inside the region
+  //
+/* begin file src/simdutf/haswell/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "haswell"
+// #define SIMDUTF_IMPLEMENTATION haswell
+
+#if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
+// nothing needed.
+#else
+SIMDUTF_TARGET_HASWELL
+#endif
+
+#if SIMDUTF_GCC11ORMORE // workaround for
+                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
+// clang-format off
+SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
+// clang-format on
+#endif // end of workaround
+/* end file src/simdutf/haswell/begin.h */
+  // Declarations
+/* begin file src/simdutf/haswell/bitmanipulation.h */
+#ifndef SIMDUTF_HASWELL_BITMANIPULATION_H
+#define SIMDUTF_HASWELL_BITMANIPULATION_H
+
+namespace simdutf {
+namespace haswell {
+namespace {
+
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
+  // note: we do not support legacy 32-bit Windows
+  return __popcnt64(input_num); // Visual Studio wants two underscores
+}
+#else
+simdutf_really_inline long long int count_ones(uint64_t input_num) {
+  return _popcnt64(input_num);
+}
+#endif
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_inline int trailing_zeroes(uint64_t input_num) {
+  #if SIMDUTF_REGULAR_VISUAL_STUDIO
+  return (int)_tzcnt_u64(input_num);
+  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
+  return __builtin_ctzll(input_num);
+  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+}
+#endif
+
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+
+#endif // SIMDUTF_HASWELL_BITMANIPULATION_H
+/* end file src/simdutf/haswell/bitmanipulation.h */
+/* begin file src/simdutf/haswell/simd.h */
+#ifndef SIMDUTF_HASWELL_SIMD_H
+#define SIMDUTF_HASWELL_SIMD_H
+
+namespace simdutf {
+namespace haswell {
+namespace {
+namespace simd {
+
+// Forward-declared so they can be used by splat and friends.
+template <typename Child> struct base {
+  __m256i value;
+
+  // Zero constructor
+  simdutf_really_inline base() : value{__m256i()} {}
+
+  // Conversion from SIMD register
+  simdutf_really_inline base(const __m256i _value) : value(_value) {}
+  // Conversion to SIMD register
+  simdutf_really_inline operator const __m256i &() const { return this->value; }
+  simdutf_really_inline operator __m256i &() { return this->value; }
+  template <endianness big_endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    __m256i first = _mm256_cvtepu8_epi16(_mm256_castsi256_si128(*this));
+    __m256i second = _mm256_cvtepu8_epi16(_mm256_extractf128_si256(*this, 1));
+    if (big_endian) {
+      const __m256i swap = _mm256_setr_epi8(
+          1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
+          21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
+      first = _mm256_shuffle_epi8(first, swap);
+      second = _mm256_shuffle_epi8(second, swap);
+    }
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr), first);
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 16), second);
+  }
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr),
+                        _mm256_cvtepu8_epi32(_mm256_castsi256_si128(*this)));
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 8),
+                        _mm256_cvtepu8_epi32(_mm256_castsi256_si128(
+                            _mm256_srli_si256(*this, 8))));
+    _mm256_storeu_si256(
+        reinterpret_cast<__m256i *>(ptr + 16),
+        _mm256_cvtepu8_epi32(_mm256_extractf128_si256(*this, 1)));
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(ptr + 24),
+                        _mm256_cvtepu8_epi32(_mm_srli_si128(
+                            _mm256_extractf128_si256(*this, 1), 8)));
+  }
+  // Bit operations
+  simdutf_really_inline Child operator|(const Child other) const {
+    return _mm256_or_si256(*this, other);
+  }
+  simdutf_really_inline Child operator&(const Child other) const {
+    return _mm256_and_si256(*this, other);
+  }
+  simdutf_really_inline Child operator^(const Child other) const {
+    return _mm256_xor_si256(*this, other);
+  }
+  simdutf_really_inline Child bit_andnot(const Child other) const {
+    return _mm256_andnot_si256(other, *this);
+  }
+  simdutf_really_inline Child &operator|=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator&=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator^=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+};
+
+// Forward-declared so they can be used by splat and friends.
+template <typename T> struct simd8;
+
+template <typename T, typename Mask = simd8<bool>>
+struct base8 : base<simd8<T>> {
+  typedef uint32_t bitmask_t;
+  typedef uint64_t bitmask2_t;
+
+  simdutf_really_inline base8() : base<simd8<T>>() {}
+  simdutf_really_inline base8(const __m256i _value) : base<simd8<T>>(_value) {}
+  simdutf_really_inline T first() const {
+    return _mm256_extract_epi8(*this, 0);
+  }
+  simdutf_really_inline T last() const {
+    return _mm256_extract_epi8(*this, 31);
+  }
+  friend simdutf_always_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return _mm256_cmpeq_epi8(lhs, rhs);
+  }
+
+  static const int SIZE = sizeof(base<T>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
+    return _mm256_alignr_epi8(
+        *this, _mm256_permute2x128_si256(prev_chunk, *this, 0x21), 16 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base8<bool> {
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return _mm256_set1_epi8(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8() : base8() {}
+  simdutf_really_inline simd8(const __m256i _value) : base8<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
+
+  simdutf_really_inline uint32_t to_bitmask() const {
+    return uint32_t(_mm256_movemask_epi8(*this));
+  }
+  simdutf_really_inline bool any() const {
+    return !_mm256_testz_si256(*this, *this);
+  }
+  simdutf_really_inline bool none() const {
+    return _mm256_testz_si256(*this, *this);
+  }
+  simdutf_really_inline bool all() const {
+    return static_cast<uint32_t>(_mm256_movemask_epi8(*this)) == 0xFFFFFFFF;
+  }
+  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base8_numeric : base8<T> {
+  static simdutf_really_inline simd8<T> splat(T _value) {
+    return _mm256_set1_epi8(_value);
+  }
+  static simdutf_really_inline simd8<T> zero() {
+    return _mm256_setzero_si256();
+  }
+  static simdutf_really_inline simd8<T> load(const T values[32]) {
+    return _mm256_loadu_si256(reinterpret_cast<const __m256i *>(values));
+  }
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
+                                                  T v5, T v6, T v7, T v8, T v9,
+                                                  T v10, T v11, T v12, T v13,
+                                                  T v14, T v15) {
+    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
+                    v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                    v12, v13, v14, v15);
+  }
+
+  simdutf_really_inline base8_numeric() : base8<T>() {}
+  simdutf_really_inline base8_numeric(const __m256i _value)
+      : base8<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[32]) const {
+    return _mm256_storeu_si256(reinterpret_cast<__m256i *>(dst), *this);
+  }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
+    return _mm256_add_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
+    return _mm256_sub_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
+    *this = *this + other;
+    return *static_cast<simd8<T> *>(this);
+  }
+  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
+    *this = *this - other;
+    return *static_cast<simd8<T> *>(this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return _mm256_shuffle_epi8(lookup_table, *this);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> : base8_numeric<int8_t> {
+  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
+  simdutf_really_inline simd8(const __m256i _value)
+      : base8_numeric<int8_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t values[32]) : simd8(load(values)) {}
+  simdutf_really_inline operator simd8<uint8_t>() const;
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
+        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
+        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
+        int8_t v30, int8_t v31)
+      : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                               v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
+                               v22, v23, v24, v25, v26, v27, v28, v29, v30,
+                               v31)) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                         v10, v11, v12, v13, v14, v15);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    return _mm256_movemask_epi8(*this) == 0;
+  }
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return _mm256_max_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return _mm256_min_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return _mm256_cmpgt_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return _mm256_cmpgt_epi8(other, *this);
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
+  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
+  simdutf_really_inline simd8(const __m256i _value)
+      : base8_numeric<uint8_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t values[32]) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
+        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
+        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
+        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
+        uint8_t v31)
+      : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                               v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
+                               v22, v23, v24, v25, v26, v27, v28, v29, v30,
+                               v31)) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                          v10, v11, v12, v13, v14, v15);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return _mm256_adds_epu8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return _mm256_subs_epu8(*this, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return _mm256_max_epu8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return _mm256_min_epu8(other, *this);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return other.max_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return other.min_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return this->lt_bits(other).any_bits_set();
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> bits_not_set() const {
+    return *this == uint8_t(0);
+  }
+  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    return _mm256_movemask_epi8(*this) == 0;
+  }
+  simdutf_really_inline bool bits_not_set_anywhere() const {
+    return _mm256_testz_si256(*this, *this);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return !bits_not_set_anywhere();
+  }
+  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
+    return _mm256_testz_si256(*this, bits);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return !bits_not_set_anywhere(bits);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return simd8<uint8_t>(_mm256_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return simd8<uint8_t>(_mm256_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
+  }
+  // Get one of the bits and make a bitmask out of it.
+  // e.g. value.get_bit<7>() gets the high bit
+  template <int N> simdutf_really_inline int get_bit() const {
+    return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 7 - N));
+  }
+};
+simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(NUM_CHUNKS == 2,
+                "Haswell kernel should use two registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
+      : chunks{chunk0, chunk1} {}
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r_hi = this->chunks[1].to_bitmask();
+    return r_lo | (r_hi << 32);
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return this->chunks[0] | this->chunks[1];
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  template <endianness endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 0);
+    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 1);
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
+    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
+  }
+
+  simdutf_really_inline simd8x64<T> bit_or(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
+    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
+                          this->chunks[1] == other.chunks[1])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+    return simd8x64<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
+                          (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+
+/* begin file src/simdutf/haswell/simd16-inl.h */
+#ifdef __GNUC__
+  #if __GNUC__ < 8
+    #define _mm256_set_m128i(xmm1, xmm2)                                       \
+      _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1),                  \
+                                _mm256_castsi128_si256(xmm2), 2)
+    #define _mm256_setr_m128i(xmm2, xmm1)                                      \
+      _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1),                  \
+                                _mm256_castsi128_si256(xmm2), 2)
+  #endif
+#endif
+
+template <typename T> struct simd16;
+
+template <typename T, typename Mask = simd16<bool>>
+struct base16 : base<simd16<T>> {
+  using bitmask_type = uint32_t;
+
+  simdutf_really_inline base16() : base<simd16<T>>() {}
+  simdutf_really_inline base16(const __m256i _value)
+      : base<simd16<T>>(_value) {}
+  template <typename Pointer>
+  simdutf_really_inline base16(const Pointer *ptr)
+      : base16(_mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr))) {}
+  friend simdutf_always_inline Mask operator==(const simd16<T> lhs,
+                                               const simd16<T> rhs) {
+    return _mm256_cmpeq_epi16(lhs, rhs);
+  }
+
+  /// the size of vector in bytes
+  static const int SIZE = sizeof(base<simd16<T>>::value);
+
+  /// the number of elements of type T a vector can hold
+  static const int ELEMENTS = SIZE / sizeof(T);
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return _mm256_alignr_epi8(*this, prev_chunk, 16 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd16<bool> : base16<bool> {
+  static simdutf_really_inline simd16<bool> splat(bool _value) {
+    return _mm256_set1_epi16(uint16_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd16() : base16() {}
+  simdutf_really_inline simd16(const __m256i _value) : base16<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
+
+  simdutf_really_inline bitmask_type to_bitmask() const {
+    return _mm256_movemask_epi8(*this);
+  }
+  simdutf_really_inline bool any() const {
+    return !_mm256_testz_si256(*this, *this);
+  }
+  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base16_numeric : base16<T> {
+  static simdutf_really_inline simd16<T> splat(T _value) {
+    return _mm256_set1_epi16(_value);
+  }
+  static simdutf_really_inline simd16<T> zero() {
+    return _mm256_setzero_si256();
+  }
+  static simdutf_really_inline simd16<T> load(const T values[8]) {
+    return _mm256_loadu_si256(reinterpret_cast<const __m256i *>(values));
+  }
+
+  simdutf_really_inline base16_numeric() : base16<T>() {}
+  simdutf_really_inline base16_numeric(const __m256i _value)
+      : base16<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[8]) const {
+    return _mm256_storeu_si256(reinterpret_cast<__m256i *>(dst), *this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
+    return _mm256_add_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
+    return _mm256_sub_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
+    *this = *this + other;
+    return *static_cast<simd16<T> *>(this);
+  }
+  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
+    *this = *this - other;
+    return *static_cast<simd16<T> *>(this);
+  }
+};
+
+// Signed code units
+template <> struct simd16<int16_t> : base16_numeric<int16_t> {
+  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
+  simdutf_really_inline simd16(const __m256i _value)
+      : base16_numeric<int16_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
+  // Order-sensitive comparisons
+  simdutf_really_inline simd16<int16_t>
+  max_val(const simd16<int16_t> other) const {
+    return _mm256_max_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<int16_t>
+  min_val(const simd16<int16_t> other) const {
+    return _mm256_min_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<int16_t> other) const {
+    return _mm256_cmpgt_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<int16_t> other) const {
+    return _mm256_cmpgt_epi16(other, *this);
+  }
+};
+
+// Unsigned code units
+template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
+  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
+  simdutf_really_inline simd16(const __m256i _value)
+      : base16_numeric<uint16_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
+
+  // Saturated math
+  simdutf_really_inline simd16<uint16_t>
+  saturating_add(const simd16<uint16_t> other) const {
+    return _mm256_adds_epu16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  saturating_sub(const simd16<uint16_t> other) const {
+    return _mm256_subs_epu16(*this, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd16<uint16_t>
+  max_val(const simd16<uint16_t> other) const {
+    return _mm256_max_epu16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  min_val(const simd16<uint16_t> other) const {
+    return _mm256_min_epu16(*this, other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  gt_bits(const simd16<uint16_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  lt_bits(const simd16<uint16_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<=(const simd16<uint16_t> other) const {
+    return other.max_val(*this) == other;
+  }
+  simdutf_really_inline simd16<bool>
+  operator>=(const simd16<uint16_t> other) const {
+    return other.min_val(*this) == other;
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<uint16_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<uint16_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd16<bool> bits_not_set() const {
+    return *this == uint16_t(0);
+  }
+  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+
+  simdutf_really_inline bool bits_not_set_anywhere() const {
+    return _mm256_testz_si256(*this, *this);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return !bits_not_set_anywhere();
+  }
+  simdutf_really_inline bool
+  bits_not_set_anywhere(simd16<uint16_t> bits) const {
+    return _mm256_testz_si256(*this, bits);
+  }
+  simdutf_really_inline bool
+  any_bits_set_anywhere(simd16<uint16_t> bits) const {
+    return !bits_not_set_anywhere(bits);
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
+    return simd16<uint16_t>(_mm256_srli_epi16(*this, N));
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
+    return simd16<uint16_t>(_mm256_slli_epi16(*this, N));
+  }
+  // Get one of the bits and make a bitmask out of it.
+  // e.g. value.get_bit<7>() gets the high bit
+  template <int N> simdutf_really_inline int get_bit() const {
+    return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 15 - N));
+  }
+
+  // Change the endianness
+  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
+    const __m256i swap = _mm256_setr_epi8(
+        1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
+        21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
+    return _mm256_shuffle_epi8(*this, swap);
+  }
+
+  // Pack with the unsigned saturation of two uint16_t code units into single
+  // uint8_t vector
+  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
+                                                   const simd16<uint16_t> &v1) {
+    // Note: the AVX2 variant of pack operates on 128-bit lanes, thus
+    //       we have to shuffle lanes in order to produce bytes in the
+    //       correct order.
+
+    // get the 0th lanes
+    const __m128i lo_0 = _mm256_extracti128_si256(v0, 0);
+    const __m128i lo_1 = _mm256_extracti128_si256(v1, 0);
+
+    // get the 1st lanes
+    const __m128i hi_0 = _mm256_extracti128_si256(v0, 1);
+    const __m128i hi_1 = _mm256_extracti128_si256(v1, 1);
+
+    // build new vectors (shuffle lanes)
+    const __m256i t0 = _mm256_set_m128i(lo_1, lo_0);
+    const __m256i t1 = _mm256_set_m128i(hi_1, hi_0);
+
+    // pack code units in linear order from v0 and v1
+    return _mm256_packus_epi16(t0, t1);
+  }
+};
+
+template <typename T> struct simd16x32 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
+  static_assert(NUM_CHUNKS == 2,
+                "Haswell kernel should use two registers per 64-byte block.");
+  simd16<T> chunks[NUM_CHUNKS];
+
+  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
+  simd16x32<T> &
+  operator=(const simd16<T> other) = delete; // no assignment allowed
+  simd16x32() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd16x32(const simd16<T> chunk0,
+                                  const simd16<T> chunk1)
+      : chunks{chunk0, chunk1} {}
+  simdutf_really_inline simd16x32(const T *ptr)
+      : chunks{simd16<T>::load(ptr),
+               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r_hi = this->chunks[1].to_bitmask();
+    return r_lo | (r_hi << 32);
+  }
+
+  simdutf_really_inline simd16<T> reduce_or() const {
+    return this->chunks[0] | this->chunks[1];
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
+    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
+  }
+
+  simdutf_really_inline simd16x32<T> bit_or(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
+  }
+
+  simdutf_really_inline void swap_bytes() {
+    this->chunks[0] = this->chunks[0].swap_bytes();
+    this->chunks[1] = this->chunks[1].swap_bytes();
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
+    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
+                           this->chunks[1] == other.chunks[1])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+
+    return simd16x32<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
+    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
+    return simd16x32<bool>(
+               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
+               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
+        .to_bitmask();
+  }
+}; // struct simd16x32<T>
+/* end file src/simdutf/haswell/simd16-inl.h */
+/* begin file src/simdutf/haswell/simd32-inl.h */
+template <typename T> struct simd32;
+
+template <> struct simd32<uint32_t> {
+  static const size_t SIZE = sizeof(__m256i);
+  static const size_t ELEMENTS = SIZE / sizeof(uint32_t);
+
+  __m256i value;
+
+  simdutf_really_inline simd32(const __m256i v) : value(v) {}
+
+  template <typename Pointer>
+  simdutf_really_inline simd32(const Pointer *ptr)
+      : value(_mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr))) {}
+
+  simdutf_really_inline uint64_t sum() const {
+    const __m256i mask = _mm256_set1_epi64x(0xffffffff);
+    const __m256i t0 = _mm256_and_si256(value, mask);
+    const __m256i t1 = _mm256_srli_epi64(value, 32);
+    const __m256i t2 = _mm256_add_epi64(t0, t1);
+
+    return uint64_t(_mm256_extract_epi64(t2, 0)) +
+           uint64_t(_mm256_extract_epi64(t2, 1)) +
+           uint64_t(_mm256_extract_epi64(t2, 2)) +
+           uint64_t(_mm256_extract_epi64(t2, 3));
+  }
+
+  simdutf_really_inline simd32<uint32_t> swap_bytes() const {
+    const __m256i shuffle =
+        _mm256_setr_epi8(3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12,
+                         3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12);
+
+    return _mm256_shuffle_epi8(value, shuffle);
+  }
+
+  // operators
+  simdutf_really_inline simd32 &operator+=(const simd32 other) {
+    value = _mm256_add_epi32(value, other.value);
+    return *this;
+  }
+
+  // static members
+  simdutf_really_inline static simd32<uint32_t> zero() {
+    return _mm256_setzero_si256();
+  }
+
+  simdutf_really_inline static simd32<uint32_t> splat(uint32_t v) {
+    return _mm256_set1_epi32(v);
+  }
+};
+
+//----------------------------------------------------------------------
+
+template <> struct simd32<bool> {
+  static const size_t SIZE = sizeof(__m128i);
+  static const size_t ELEMENTS = SIZE / sizeof(uint32_t);
+
+  __m256i value;
+
+  simdutf_really_inline simd32(const __m256i v) : value(v) {}
+
+  simdutf_really_inline bool any() const {
+    return _mm256_movemask_epi8(value) != 0;
+  }
+};
+
+//----------------------------------------------------------------------
+
+template <typename T>
+simdutf_really_inline simd32<T> operator|(const simd32<T> a,
+                                          const simd32<T> b) {
+  return _mm256_or_si256(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> b,
+                                           const simd32<uint32_t> a) {
+  return _mm256_min_epu32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> max(const simd32<uint32_t> a,
+                                           const simd32<uint32_t> b) {
+  return _mm256_max_epu32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> b,
+                                                 const simd32<uint32_t> a) {
+  return _mm256_and_si256(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> operator+(const simd32<uint32_t> a,
+                                                 const simd32<uint32_t> b) {
+  return _mm256_add_epi32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<bool> operator>=(const simd32<uint32_t> a,
+                                              const simd32<uint32_t> b) {
+  return _mm256_cmpeq_epi32(_mm256_max_epu32(a.value, b.value), a.value);
+}
+
+simdutf_really_inline simd32<bool> operator!(const simd32<bool> v) {
+  return _mm256_xor_si256(v.value, _mm256_set1_epi8(-1));
+}
+
+simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
+                                             const simd32<uint32_t> b) {
+  return !(b >= a);
+}
+/* end file src/simdutf/haswell/simd32-inl.h */
+
+} // namespace simd
+
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+
+#endif // SIMDUTF_HASWELL_SIMD_H
+/* end file src/simdutf/haswell/simd.h */
+
+/* begin file src/simdutf/haswell/end.h */
+#if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
+// nothing needed.
+#else
+SIMDUTF_UNTARGET_REGION
+#endif
+
+
+#if SIMDUTF_GCC11ORMORE // workaround for
+                        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
+SIMDUTF_POP_DISABLE_WARNINGS
+#endif // end of workaround
+/* end file src/simdutf/haswell/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_HASWELL
+#endif // SIMDUTF_HASWELL_COMMON_H
+/* end file src/simdutf/haswell.h */
+/* begin file src/simdutf/westmere.h */
+#ifndef SIMDUTF_WESTMERE_H
+#define SIMDUTF_WESTMERE_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "westmere.h must be included before fallback.h"
+#endif
+
+
+// Default Westmere to on if this is x86-64, unless we'll always select Haswell.
+#ifndef SIMDUTF_IMPLEMENTATION_WESTMERE
+  //
+  // You do not want to set it to (SIMDUTF_IS_X86_64 &&
+  // !SIMDUTF_REQUIRES_HASWELL) because you want to rely on runtime dispatch!
+  //
+  #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE || SIMDUTF_CAN_ALWAYS_RUN_HASWELL
+    #define SIMDUTF_IMPLEMENTATION_WESTMERE 0
+  #else
+    #define SIMDUTF_IMPLEMENTATION_WESTMERE (SIMDUTF_IS_X86_64)
+  #endif
+
+#endif
+
+#if (SIMDUTF_IMPLEMENTATION_WESTMERE && SIMDUTF_IS_X86_64 && __SSE4_2__)
+  #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 0
+#endif
+
+#if SIMDUTF_IMPLEMENTATION_WESTMERE
+
+  #define SIMDUTF_TARGET_WESTMERE SIMDUTF_TARGET_REGION("sse4.2,popcnt")
+
+namespace simdutf {
+/**
+ * Implementation for Westmere (Intel SSE4.2).
+ */
+namespace westmere {} // namespace westmere
+} // namespace simdutf
+
+  //
+  // These two need to be included outside SIMDUTF_TARGET_REGION
+  //
+/* begin file src/simdutf/westmere/implementation.h */
+#ifndef SIMDUTF_WESTMERE_IMPLEMENTATION_H
+#define SIMDUTF_WESTMERE_IMPLEMENTATION_H
+
+
+// The constructor may be executed on any host, so we take care not to use
+// SIMDUTF_TARGET_REGION
+namespace simdutf {
+namespace westmere {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("westmere", "Intel/AMD SSE4.2",
+                                internal::instruction_set::SSE42) {}
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace westmere
+} // namespace simdutf
+
+#endif // SIMDUTF_WESTMERE_IMPLEMENTATION_H
+/* end file src/simdutf/westmere/implementation.h */
+/* begin file src/simdutf/westmere/intrinsics.h */
+#ifndef SIMDUTF_WESTMERE_INTRINSICS_H
+#define SIMDUTF_WESTMERE_INTRINSICS_H
+
+#ifdef SIMDUTF_VISUAL_STUDIO
+  // under clang within visual studio, this will include <x86intrin.h>
+  #include <intrin.h> // visual studio or clang
+#else
+
+  #if SIMDUTF_GCC11ORMORE
+// We should not get warnings while including <x86intrin.h> yet we do
+// under some versions of GCC.
+// If the x86intrin.h header has uninitialized values that are problematic,
+// it is a GCC issue, we want to ignore these warnings.
+SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
+  #endif
+
+  #include <x86intrin.h> // elsewhere
+
+  #if SIMDUTF_GCC11ORMORE
+// cancels the suppression of the -Wuninitialized
+SIMDUTF_POP_DISABLE_WARNINGS
+  #endif
+
+#endif // SIMDUTF_VISUAL_STUDIO
+
+#ifdef SIMDUTF_CLANG_VISUAL_STUDIO
+  /**
+   * You are not supposed, normally, to include these
+   * headers directly. Instead you should either include intrin.h
+   * or x86intrin.h. However, when compiling with clang
+   * under Windows (i.e., when _MSC_VER is set), these headers
+   * only get included *if* the corresponding features are detected
+   * from macros:
+   */
+  #include <smmintrin.h> // for _mm_alignr_epi8
+#endif
+
+#endif // SIMDUTF_WESTMERE_INTRINSICS_H
+/* end file src/simdutf/westmere/intrinsics.h */
+
+  //
+  // The rest need to be inside the region
+  //
+/* begin file src/simdutf/westmere/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "westmere"
+// #define SIMDUTF_IMPLEMENTATION westmere
+
+#if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
+// nothing needed.
+#else
+SIMDUTF_TARGET_WESTMERE
+#endif
+/* end file src/simdutf/westmere/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/westmere/bitmanipulation.h */
+#ifndef SIMDUTF_WESTMERE_BITMANIPULATION_H
+#define SIMDUTF_WESTMERE_BITMANIPULATION_H
+
+namespace simdutf {
+namespace westmere {
+namespace {
+
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num) {
+  // note: we do not support legacy 32-bit Windows
+  return __popcnt64(input_num); // Visual Studio wants two underscores
+}
+#else
+simdutf_really_inline long long int count_ones(uint64_t input_num) {
+  return _popcnt64(input_num);
+}
+#endif
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
+  #if SIMDUTF_REGULAR_VISUAL_STUDIO
+  unsigned long ret;
+  _BitScanForward64(&ret, input_num);
+  return (int)ret;
+  #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
+  return __builtin_ctzll(input_num);
+  #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
+}
+#endif
+
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+
+#endif // SIMDUTF_WESTMERE_BITMANIPULATION_H
+/* end file src/simdutf/westmere/bitmanipulation.h */
+/* begin file src/simdutf/westmere/simd.h */
+#ifndef SIMDUTF_WESTMERE_SIMD_H
+#define SIMDUTF_WESTMERE_SIMD_H
+
+namespace simdutf {
+namespace westmere {
+namespace {
+namespace simd {
+
+template <typename Child> struct base {
+  __m128i value;
+
+  // Zero constructor
+  simdutf_really_inline base() : value{__m128i()} {}
+
+  // Conversion from SIMD register
+  simdutf_really_inline base(const __m128i _value) : value(_value) {}
+  // Conversion to SIMD register
+  simdutf_really_inline operator const __m128i &() const { return this->value; }
+  simdutf_really_inline operator __m128i &() { return this->value; }
+  template <endianness big_endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
+    __m128i first = _mm_cvtepu8_epi16(*this);
+    __m128i second = _mm_cvtepu8_epi16(_mm_srli_si128(*this, 8));
+    if (big_endian) {
+      const __m128i swap =
+          _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+      first = _mm_shuffle_epi8(first, swap);
+      second = _mm_shuffle_epi8(second, swap);
+    }
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p), first);
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 8), second);
+  }
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p), _mm_cvtepu8_epi32(*this));
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 4),
+                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 4)));
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 8),
+                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 8)));
+    _mm_storeu_si128(reinterpret_cast<__m128i *>(p + 12),
+                     _mm_cvtepu8_epi32(_mm_srli_si128(*this, 12)));
+  }
+  // Bit operations
+  simdutf_really_inline Child operator|(const Child other) const {
+    return _mm_or_si128(*this, other);
+  }
+  simdutf_really_inline Child operator&(const Child other) const {
+    return _mm_and_si128(*this, other);
+  }
+  simdutf_really_inline Child operator^(const Child other) const {
+    return _mm_xor_si128(*this, other);
+  }
+  simdutf_really_inline Child bit_andnot(const Child other) const {
+    return _mm_andnot_si128(other, *this);
+  }
+  simdutf_really_inline Child &operator|=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator&=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator^=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+};
+
+// Forward-declared so they can be used by splat and friends.
+template <typename T> struct simd8;
+
+template <typename T, typename Mask = simd8<bool>>
+struct base8 : base<simd8<T>> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  simdutf_really_inline T first() const { return _mm_extract_epi8(*this, 0); }
+  simdutf_really_inline T last() const { return _mm_extract_epi8(*this, 15); }
+  simdutf_really_inline base8() : base<simd8<T>>() {}
+  simdutf_really_inline base8(const __m128i _value) : base<simd8<T>>(_value) {}
+
+  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return _mm_cmpeq_epi8(lhs, rhs);
+  }
+
+  static const int SIZE = sizeof(base<simd8<T>>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
+    return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base8<bool> {
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return _mm_set1_epi8(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8() : base8() {}
+  simdutf_really_inline simd8(const __m128i _value) : base8<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
+
+  simdutf_really_inline int to_bitmask() const {
+    return _mm_movemask_epi8(*this);
+  }
+  simdutf_really_inline bool any() const {
+    return !_mm_testz_si128(*this, *this);
+  }
+  simdutf_really_inline bool none() const {
+    return _mm_testz_si128(*this, *this);
+  }
+  simdutf_really_inline bool all() const {
+    return _mm_movemask_epi8(*this) == 0xFFFF;
+  }
+  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base8_numeric : base8<T> {
+  static simdutf_really_inline simd8<T> splat(T _value) {
+    return _mm_set1_epi8(_value);
+  }
+  static simdutf_really_inline simd8<T> zero() { return _mm_setzero_si128(); }
+  static simdutf_really_inline simd8<T> load(const T values[16]) {
+    return _mm_loadu_si128(reinterpret_cast<const __m128i *>(values));
+  }
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
+                                                  T v5, T v6, T v7, T v8, T v9,
+                                                  T v10, T v11, T v12, T v13,
+                                                  T v14, T v15) {
+    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
+                    v14, v15);
+  }
+
+  simdutf_really_inline base8_numeric() : base8<T>() {}
+  simdutf_really_inline base8_numeric(const __m128i _value)
+      : base8<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[16]) const {
+    return _mm_storeu_si128(reinterpret_cast<__m128i *>(dst), *this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
+    return _mm_add_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
+    return _mm_sub_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
+    *this = *this + other;
+    return *static_cast<simd8<T> *>(this);
+  }
+  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
+    *this = *this - other;
+    return *static_cast<simd8<T> *>(this);
+  }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return _mm_shuffle_epi8(lookup_table, *this);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> : base8_numeric<int8_t> {
+  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
+  simdutf_really_inline simd8(const __m128i _value)
+      : base8_numeric<int8_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
+                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
+                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
+      : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                            v12, v13, v14, v15)) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15);
+  }
+  simdutf_really_inline operator simd8<uint8_t>() const;
+  simdutf_really_inline bool is_ascii() const {
+    return _mm_movemask_epi8(*this) == 0;
+  }
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return _mm_max_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return _mm_min_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return _mm_cmpgt_epi8(*this, other);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return _mm_cmpgt_epi8(other, *this);
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
+  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
+  simdutf_really_inline simd8(const __m128i _value)
+      : base8_numeric<uint8_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
+      : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                            v12, v13, v14, v15)) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return _mm_adds_epu8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return _mm_subs_epu8(*this, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return _mm_max_epu8(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return _mm_min_epu8(*this, other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return other.max_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return other.min_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> bits_not_set() const {
+    return *this == uint8_t(0);
+  }
+  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    return _mm_movemask_epi8(*this) == 0;
+  }
+
+  simdutf_really_inline bool bits_not_set_anywhere() const {
+    return _mm_testz_si128(*this, *this);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return !bits_not_set_anywhere();
+  }
+  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
+    return _mm_testz_si128(*this, bits);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return !bits_not_set_anywhere(bits);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return simd8<uint8_t>(_mm_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return simd8<uint8_t>(_mm_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
+  }
+  // Get one of the bits and make a bitmask out of it.
+  // e.g. value.get_bit<7>() gets the high bit
+  template <int N> simdutf_really_inline int get_bit() const {
+    return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
+  }
+};
+simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(NUM_CHUNKS == 4,
+                "Westmere kernel should use four registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
+                                 const simd8<T> chunk2, const simd8<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    this->chunks[2] |= other.chunks[2];
+    this->chunks[3] |= other.chunks[3];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  template <endianness endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 0);
+    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 1);
+    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 2);
+    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
+    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
+    this->chunks[2].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 2);
+    this->chunks[3].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r1 = this->chunks[1].to_bitmask();
+    uint64_t r2 = this->chunks[2].to_bitmask();
+    uint64_t r3 = this->chunks[3].to_bitmask();
+    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                          this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
+    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
+                          this->chunks[1] == other.chunks[1],
+                          this->chunks[2] == other.chunks[2],
+                          this->chunks[3] == other.chunks[3])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                          this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low - 1);
+    const simd8<T> mask_high = simd8<T>::splat(high + 1);
+    return simd8x64<bool>(
+               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
+               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
+               (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
+               (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                          this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
+                          this->chunks[2] > mask, this->chunks[3] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
+                          this->chunks[2] >= mask, this->chunks[3] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>(simd8<uint8_t>(__m128i(this->chunks[0])) >= mask,
+                          simd8<uint8_t>(__m128i(this->chunks[1])) >= mask,
+                          simd8<uint8_t>(__m128i(this->chunks[2])) >= mask,
+                          simd8<uint8_t>(__m128i(this->chunks[3])) >= mask)
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+
+/* begin file src/simdutf/westmere/simd16-inl.h */
+template <typename T> struct simd16;
+
+template <typename T, typename Mask = simd16<bool>>
+struct base16 : base<simd16<T>> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  simdutf_really_inline base16() : base<simd16<T>>() {}
+  simdutf_really_inline base16(const __m128i _value)
+      : base<simd16<T>>(_value) {}
+  template <typename Pointer>
+  simdutf_really_inline base16(const Pointer *ptr)
+      : base16(_mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr))) {}
+
+  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
+                                               const simd16<T> rhs) {
+    return _mm_cmpeq_epi16(lhs, rhs);
+  }
+
+  static const int SIZE = sizeof(base<simd16<T>>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd16<bool> : base16<bool> {
+  static simdutf_really_inline simd16<bool> splat(bool _value) {
+    return _mm_set1_epi16(uint16_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd16() : base16() {}
+  simdutf_really_inline simd16(const __m128i _value) : base16<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
+
+  simdutf_really_inline int to_bitmask() const {
+    return _mm_movemask_epi8(*this);
+  }
+  simdutf_really_inline bool any() const {
+    return !_mm_testz_si128(*this, *this);
+  }
+  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base16_numeric : base16<T> {
+  static simdutf_really_inline simd16<T> splat(T _value) {
+    return _mm_set1_epi16(_value);
+  }
+  static simdutf_really_inline simd16<T> zero() { return _mm_setzero_si128(); }
+  static simdutf_really_inline simd16<T> load(const T values[8]) {
+    return _mm_loadu_si128(reinterpret_cast<const __m128i *>(values));
+  }
+
+  simdutf_really_inline base16_numeric() : base16<T>() {}
+  simdutf_really_inline base16_numeric(const __m128i _value)
+      : base16<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[8]) const {
+    return _mm_storeu_si128(reinterpret_cast<__m128i *>(dst), *this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
+    return _mm_add_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
+    return _mm_sub_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
+    *this = *this + other;
+    return *static_cast<simd16<T> *>(this);
+  }
+  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
+    *this = *this - other;
+    return *static_cast<simd16<T> *>(this);
+  }
+};
+
+// Signed code units
+template <> struct simd16<int16_t> : base16_numeric<int16_t> {
+  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
+  simdutf_really_inline simd16(const __m128i _value)
+      : base16_numeric<int16_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
+  // Member-by-member initialization
+  simdutf_really_inline simd16(int16_t v0, int16_t v1, int16_t v2, int16_t v3,
+                               int16_t v4, int16_t v5, int16_t v6, int16_t v7)
+      : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7)) {}
+  simdutf_really_inline operator simd16<uint16_t>() const;
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd16<int16_t>
+  max_val(const simd16<int16_t> other) const {
+    return _mm_max_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<int16_t>
+  min_val(const simd16<int16_t> other) const {
+    return _mm_min_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<int16_t> other) const {
+    return _mm_cmpgt_epi16(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<int16_t> other) const {
+    return _mm_cmpgt_epi16(other, *this);
+  }
+};
+
+// Unsigned code units
+template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
+  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
+  simdutf_really_inline simd16(const __m128i _value)
+      : base16_numeric<uint16_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
+  // Member-by-member initialization
+  simdutf_really_inline simd16(uint16_t v0, uint16_t v1, uint16_t v2,
+                               uint16_t v3, uint16_t v4, uint16_t v5,
+                               uint16_t v6, uint16_t v7)
+      : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7)) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd16<uint16_t>
+  repeat_16(uint16_t v0, uint16_t v1, uint16_t v2, uint16_t v3, uint16_t v4,
+            uint16_t v5, uint16_t v6, uint16_t v7) {
+    return simd16<uint16_t>(v0, v1, v2, v3, v4, v5, v6, v7);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd16<uint16_t>
+  saturating_add(const simd16<uint16_t> other) const {
+    return _mm_adds_epu16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  saturating_sub(const simd16<uint16_t> other) const {
+    return _mm_subs_epu16(*this, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd16<uint16_t>
+  max_val(const simd16<uint16_t> other) const {
+    return _mm_max_epu16(*this, other);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  min_val(const simd16<uint16_t> other) const {
+    return _mm_min_epu16(*this, other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  gt_bits(const simd16<uint16_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  lt_bits(const simd16<uint16_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<=(const simd16<uint16_t> other) const {
+    return other.max_val(*this) == other;
+  }
+  simdutf_really_inline simd16<bool>
+  operator>=(const simd16<uint16_t> other) const {
+    return other.min_val(*this) == other;
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<uint16_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<uint16_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd16<bool> bits_not_set() const {
+    return *this == uint16_t(0);
+  }
+  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+
+  simdutf_really_inline bool bits_not_set_anywhere() const {
+    return _mm_testz_si128(*this, *this);
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return !bits_not_set_anywhere();
+  }
+  simdutf_really_inline bool
+  bits_not_set_anywhere(simd16<uint16_t> bits) const {
+    return _mm_testz_si128(*this, bits);
+  }
+  simdutf_really_inline bool
+  any_bits_set_anywhere(simd16<uint16_t> bits) const {
+    return !bits_not_set_anywhere(bits);
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
+    return simd16<uint16_t>(_mm_srli_epi16(*this, N));
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
+    return simd16<uint16_t>(_mm_slli_epi16(*this, N));
+  }
+  // Get one of the bits and make a bitmask out of it.
+  // e.g. value.get_bit<7>() gets the high bit
+  template <int N> simdutf_really_inline int get_bit() const {
+    return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
+  }
+
+  // Change the endianness
+  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
+    const __m128i swap =
+        _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+    return _mm_shuffle_epi8(*this, swap);
+  }
+
+  // Pack with the unsigned saturation of two uint16_t code units into single
+  // uint8_t vector
+  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
+                                                   const simd16<uint16_t> &v1) {
+    return _mm_packus_epi16(v0, v1);
+  }
+};
+simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd16x32 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
+  static_assert(NUM_CHUNKS == 4,
+                "Westmere kernel should use four registers per 64-byte block.");
+  simd16<T> chunks[NUM_CHUNKS];
+
+  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
+  simd16x32<T> &
+  operator=(const simd16<T> other) = delete; // no assignment allowed
+  simd16x32() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline
+  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
+            const simd16<T> chunk2, const simd16<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd16x32(const T *ptr)
+      : chunks{simd16<T>::load(ptr),
+               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd16<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
+    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
+    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
+    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r1 = this->chunks[1].to_bitmask();
+    uint64_t r2 = this->chunks[2].to_bitmask();
+    uint64_t r3 = this->chunks[3].to_bitmask();
+    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
+  }
+
+  simdutf_really_inline void swap_bytes() {
+    this->chunks[0] = this->chunks[0].swap_bytes();
+    this->chunks[1] = this->chunks[1].swap_bytes();
+    this->chunks[2] = this->chunks[2].swap_bytes();
+    this->chunks[3] = this->chunks[3].swap_bytes();
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                           this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
+    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
+                           this->chunks[1] == other.chunks[1],
+                           this->chunks[2] == other.chunks[2],
+                           this->chunks[3] == other.chunks[3])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                           this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+
+    return simd16x32<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
+    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
+    return simd16x32<bool>(
+               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
+               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
+               (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
+               (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                           this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+}; // struct simd16x32<T>
+/* end file src/simdutf/westmere/simd16-inl.h */
+/* begin file src/simdutf/westmere/simd32-inl.h */
+template <typename T> struct simd32;
+
+template <> struct simd32<uint32_t> {
+  static const size_t SIZE = sizeof(__m128i);
+  static const size_t ELEMENTS = SIZE / sizeof(uint32_t);
+
+  __m128i value;
+
+  simdutf_really_inline simd32(const __m128i v) : value(v) {}
+
+  template <typename Pointer>
+  simdutf_really_inline simd32(const Pointer *ptr)
+      : value(_mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr))) {}
+
+  simdutf_really_inline uint64_t sum() const {
+    return uint64_t(_mm_extract_epi32(value, 0)) +
+           uint64_t(_mm_extract_epi32(value, 1)) +
+           uint64_t(_mm_extract_epi32(value, 2)) +
+           uint64_t(_mm_extract_epi32(value, 3));
+  }
+
+  simdutf_really_inline simd32<uint32_t> swap_bytes() const {
+    const __m128i shuffle =
+        _mm_setr_epi8(3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12);
+
+    return _mm_shuffle_epi8(value, shuffle);
+  }
+
+  void dump() const {
+    printf("[%08x, %08x, %08x, %08x]\n", uint32_t(_mm_extract_epi32(value, 0)),
+           uint32_t(_mm_extract_epi32(value, 1)),
+           uint32_t(_mm_extract_epi32(value, 2)),
+           uint32_t(_mm_extract_epi32(value, 3)));
+  }
+
+  // operators
+  simdutf_really_inline simd32 &operator+=(const simd32 other) {
+    value = _mm_add_epi32(value, other.value);
+    return *this;
+  }
+
+  // static members
+  simdutf_really_inline static simd32<uint32_t> zero() {
+    return _mm_setzero_si128();
+  }
+
+  simdutf_really_inline static simd32<uint32_t> splat(uint32_t v) {
+    return _mm_set1_epi32(v);
+  }
+};
+
+//----------------------------------------------------------------------
+
+template <> struct simd32<bool> {
+  static const size_t SIZE = sizeof(__m128i);
+  static const size_t ELEMENTS = SIZE / sizeof(uint32_t);
+
+  __m128i value;
+
+  simdutf_really_inline simd32(const __m128i v) : value(v) {}
+
+  simdutf_really_inline bool any() const {
+    return _mm_movemask_epi8(value) != 0;
+  }
+};
+
+//----------------------------------------------------------------------
+
+template <typename T>
+simdutf_really_inline simd32<T> operator|(const simd32<T> a,
+                                          const simd32<T> b) {
+  return _mm_or_si128(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> a,
+                                           const simd32<uint32_t> b) {
+  return _mm_min_epu32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> max(const simd32<uint32_t> a,
+                                           const simd32<uint32_t> b) {
+  return _mm_max_epu32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
+                                                 const simd32<uint32_t> b) {
+  return _mm_and_si128(a.value, b.value);
+}
+
+simdutf_really_inline simd32<uint32_t> operator+(const simd32<uint32_t> a,
+                                                 const simd32<uint32_t> b) {
+  return _mm_add_epi32(a.value, b.value);
+}
+
+simdutf_really_inline simd32<bool> operator>=(const simd32<uint32_t> a,
+                                              const simd32<uint32_t> b) {
+  return _mm_cmpeq_epi32(_mm_max_epu32(a.value, b.value), a.value);
+}
+
+simdutf_really_inline simd32<bool> operator!(const simd32<bool> v) {
+  return _mm_xor_si128(v.value, _mm_set1_epi8(-1));
+}
+
+simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
+                                             const simd32<uint32_t> b) {
+  return !(b >= a);
+}
+/* end file src/simdutf/westmere/simd32-inl.h */
+
+} // namespace simd
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+
+#endif // SIMDUTF_WESTMERE_SIMD_INPUT_H
+/* end file src/simdutf/westmere/simd.h */
+
+/* begin file src/simdutf/westmere/end.h */
+#if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
+// nothing needed.
+#else
+SIMDUTF_UNTARGET_REGION
+#endif
+
+/* end file src/simdutf/westmere/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_WESTMERE
+#endif // SIMDUTF_WESTMERE_COMMON_H
+/* end file src/simdutf/westmere.h */
+/* begin file src/simdutf/ppc64.h */
+#ifndef SIMDUTF_PPC64_H
+#define SIMDUTF_PPC64_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "ppc64.h must be included before fallback.h"
+#endif
+
+
+#ifndef SIMDUTF_IMPLEMENTATION_PPC64
+  #define SIMDUTF_IMPLEMENTATION_PPC64 (SIMDUTF_IS_PPC64)
+#endif
+#define SIMDUTF_CAN_ALWAYS_RUN_PPC64                                           \
+  SIMDUTF_IMPLEMENTATION_PPC64 &&SIMDUTF_IS_PPC64
+
+
+#if SIMDUTF_IMPLEMENTATION_PPC64
+
+namespace simdutf {
+/**
+ * Implementation for ALTIVEC (PPC64).
+ */
+namespace ppc64 {} // namespace ppc64
+} // namespace simdutf
+
+/* begin file src/simdutf/ppc64/implementation.h */
+#ifndef SIMDUTF_PPC64_IMPLEMENTATION_H
+#define SIMDUTF_PPC64_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace ppc64 {
+
+namespace {
+using namespace simdutf;
+} // namespace
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("ppc64", "PPC64 ALTIVEC",
+                                internal::instruction_set::ALTIVEC) {}
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+};
+
+} // namespace ppc64
+} // namespace simdutf
+
+#endif // SIMDUTF_PPC64_IMPLEMENTATION_H
+/* end file src/simdutf/ppc64/implementation.h */
+
+/* begin file src/simdutf/ppc64/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "ppc64"
+// #define SIMDUTF_IMPLEMENTATION ppc64
+/* end file src/simdutf/ppc64/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/ppc64/intrinsics.h */
+#ifndef SIMDUTF_PPC64_INTRINSICS_H
+#define SIMDUTF_PPC64_INTRINSICS_H
+
+
+// This should be the correct header whether
+// you use visual studio or other compilers.
+#include <altivec.h>
+
+// These are defined by altivec.h in GCC toolchain, it is safe to undef them.
+#ifdef bool
+  #undef bool
+#endif
+
+#ifdef vector
+  #undef vector
+#endif
+
+#endif //  SIMDUTF_PPC64_INTRINSICS_H
+/* end file src/simdutf/ppc64/intrinsics.h */
+/* begin file src/simdutf/ppc64/bitmanipulation.h */
+#ifndef SIMDUTF_PPC64_BITMANIPULATION_H
+#define SIMDUTF_PPC64_BITMANIPULATION_H
+
+namespace simdutf {
+namespace ppc64 {
+namespace {
+
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+simdutf_really_inline int count_ones(uint64_t input_num) {
+  // note: we do not support legacy 32-bit Windows
+  return __popcnt64(input_num); // Visual Studio wants two underscores
+}
+#else
+simdutf_really_inline int count_ones(uint64_t input_num) {
+  return __builtin_popcountll(input_num);
+}
+#endif
+
+} // unnamed namespace
+} // namespace ppc64
+} // namespace simdutf
+
+#endif // SIMDUTF_PPC64_BITMANIPULATION_H
+/* end file src/simdutf/ppc64/bitmanipulation.h */
+/* begin file src/simdutf/ppc64/simd.h */
+#ifndef SIMDUTF_PPC64_SIMD_H
+#define SIMDUTF_PPC64_SIMD_H
+
+#include <type_traits>
+
+namespace simdutf {
+namespace ppc64 {
+namespace {
+namespace simd {
+
+using __m128i = __vector unsigned char;
+
+template <typename Child> struct base {
+  __m128i value;
+
+  // Zero constructor
+  simdutf_really_inline base() : value{__m128i()} {}
+
+  // Conversion from SIMD register
+  simdutf_really_inline base(const __m128i _value) : value(_value) {}
+
+  // Conversion to SIMD register
+  simdutf_really_inline operator const __m128i &() const { return this->value; }
+  simdutf_really_inline operator __m128i &() { return this->value; }
+
+  // Bit operations
+  simdutf_really_inline Child operator|(const Child other) const {
+    return vec_or(this->value, (__m128i)other);
+  }
+  simdutf_really_inline Child operator&(const Child other) const {
+    return vec_and(this->value, (__m128i)other);
+  }
+  simdutf_really_inline Child operator^(const Child other) const {
+    return vec_xor(this->value, (__m128i)other);
+  }
+  simdutf_really_inline Child bit_andnot(const Child other) const {
+    return vec_andc(this->value, (__m128i)other);
+  }
+  simdutf_really_inline Child &operator|=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator&=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator^=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+};
+
+// Forward-declared so they can be used by splat and friends.
+template <typename T> struct simd8;
+
+template <typename T, typename Mask = simd8<bool>>
+struct base8 : base<simd8<T>> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  simdutf_really_inline base8() : base<simd8<T>>() {}
+  simdutf_really_inline base8(const __m128i _value) : base<simd8<T>>(_value) {}
+
+  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return (__m128i)vec_cmpeq(lhs.value, (__m128i)rhs);
+  }
+
+  static const int SIZE = sizeof(base<simd8<T>>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(simd8<T> prev_chunk) const {
+    __m128i chunk = this->value;
+#ifdef __LITTLE_ENDIAN__
+    chunk = (__m128i)vec_reve(this->value);
+    prev_chunk = (__m128i)vec_reve((__m128i)prev_chunk);
+#endif
+    chunk = (__m128i)vec_sld((__m128i)prev_chunk, (__m128i)chunk, 16 - N);
+#ifdef __LITTLE_ENDIAN__
+    chunk = (__m128i)vec_reve((__m128i)chunk);
+#endif
+    return chunk;
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base8<bool> {
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return (__m128i)vec_splats((unsigned char)(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8() : base8() {}
+  simdutf_really_inline simd8(const __m128i _value) : base8<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
+
+  simdutf_really_inline int to_bitmask() const {
+    __vector unsigned long long result;
+    const __m128i perm_mask = {0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
+                               0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00};
+
+    result = ((__vector unsigned long long)vec_vbpermq((__m128i)this->value,
+                                                       (__m128i)perm_mask));
+#ifdef __LITTLE_ENDIAN__
+    return static_cast<int>(result[1]);
+#else
+    return static_cast<int>(result[0]);
+#endif
+  }
+  simdutf_really_inline bool any() const {
+    return !vec_all_eq(this->value, (__m128i)vec_splats(0));
+  }
+  simdutf_really_inline simd8<bool> operator~() const {
+    return this->value ^ (__m128i)splat(true);
+  }
+};
+
+template <typename T> struct base8_numeric : base8<T> {
+  static simdutf_really_inline simd8<T> splat(T value) {
+    (void)value;
+    return (__m128i)vec_splats(value);
+  }
+  static simdutf_really_inline simd8<T> zero() { return splat(0); }
+  static simdutf_really_inline simd8<T> load(const T values[16]) {
+    return (__m128i)(vec_vsx_ld(0, reinterpret_cast<const uint8_t *>(values)));
+  }
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
+                                                  T v5, T v6, T v7, T v8, T v9,
+                                                  T v10, T v11, T v12, T v13,
+                                                  T v14, T v15) {
+    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
+                    v14, v15);
+  }
+
+  simdutf_really_inline base8_numeric() : base8<T>() {}
+  simdutf_really_inline base8_numeric(const __m128i _value)
+      : base8<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[16]) const {
+    vec_vsx_st(this->value, 0, reinterpret_cast<__m128i *>(dst));
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
+    return (__m128i)((__m128i)this->value + (__m128i)other);
+  }
+  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
+    return (__m128i)((__m128i)this->value - (__m128i)other);
+  }
+  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
+    *this = *this + other;
+    return *static_cast<simd8<T> *>(this);
+  }
+  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
+    *this = *this - other;
+    return *static_cast<simd8<T> *>(this);
+  }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return (__m128i)vec_perm((__m128i)lookup_table, (__m128i)lookup_table,
+                             this->value);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> : base8_numeric<int8_t> {
+  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
+  simdutf_really_inline simd8(const __m128i _value)
+      : base8_numeric<int8_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
+                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
+                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
+      : simd8((__m128i)(__vector signed char){v0, v1, v2, v3, v4, v5, v6, v7,
+                                              v8, v9, v10, v11, v12, v13, v14,
+                                              v15}) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15);
+  }
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return (__m128i)vec_max((__vector signed char)this->value,
+                            (__vector signed char)(__m128i)other);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return (__m128i)vec_min((__vector signed char)this->value,
+                            (__vector signed char)(__m128i)other);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return (__m128i)vec_cmpgt((__vector signed char)this->value,
+                              (__vector signed char)(__m128i)other);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return (__m128i)vec_cmplt((__vector signed char)this->value,
+                              (__vector signed char)(__m128i)other);
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
+  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
+  simdutf_really_inline simd8(const __m128i _value)
+      : base8_numeric<uint8_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
+      : simd8((__m128i){v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                        v13, v14, v15}) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return (__m128i)vec_adds(this->value, (__m128i)other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return (__m128i)vec_subs(this->value, (__m128i)other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return (__m128i)vec_max(this->value, (__m128i)other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return (__m128i)vec_min(this->value, (__m128i)other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return other.max_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return other.min_val(*this) == other;
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return this->gt_bits(other).any_bits_set();
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> bits_not_set() const {
+    return (__m128i)vec_cmpeq(this->value, (__m128i)vec_splats(uint8_t(0)));
+  }
+  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->saturating_sub(0b01111111u).bits_not_set_anywhere();
+  }
+
+  simdutf_really_inline bool bits_not_set_anywhere() const {
+    return vec_all_eq(this->value, (__m128i)vec_splats(0));
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return !bits_not_set_anywhere();
+  }
+  simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const {
+    return vec_all_eq(vec_and(this->value, (__m128i)bits),
+                      (__m128i)vec_splats(0));
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return !bits_not_set_anywhere(bits);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return simd8<uint8_t>(
+        (__m128i)vec_sr(this->value, (__m128i)vec_splat_u8(N)));
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return simd8<uint8_t>(
+        (__m128i)vec_sl(this->value, (__m128i)vec_splat_u8(N)));
+  }
+};
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(NUM_CHUNKS == 4,
+                "PPC64 kernel should use four registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
+                                 const simd8<T> chunk2, const simd8<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    this->chunks[2] |= other.chunks[2];
+    this->chunks[3] |= other.chunks[3];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return input.reduce_or().is_ascii();
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r1 = this->chunks[1].to_bitmask();
+    uint64_t r2 = this->chunks[2].to_bitmask();
+    uint64_t r3 = this->chunks[3].to_bitmask();
+    return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                          this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
+    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
+                          this->chunks[1] == other.chunks[1],
+                          this->chunks[2] == other.chunks[2],
+                          this->chunks[3] == other.chunks[3])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                          this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+    return simd8x64<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
+               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
+               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                          this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
+                          this->chunks[2] > mask, this->chunks[3] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
+                          this->chunks[2] >= mask, this->chunks[3] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>(simd8<uint8_t>(this->chunks[0]) >= mask,
+                          simd8<uint8_t>(this->chunks[1]) >= mask,
+                          simd8<uint8_t>(this->chunks[2]) >= mask,
+                          simd8<uint8_t>(this->chunks[3]) >= mask)
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+
+} // namespace simd
+} // unnamed namespace
+} // namespace ppc64
+} // namespace simdutf
+
+#endif // SIMDUTF_PPC64_SIMD_INPUT_H
+/* end file src/simdutf/ppc64/simd.h */
+
+/* begin file src/simdutf/ppc64/end.h */
+/* end file src/simdutf/ppc64/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_PPC64
+
+#endif // SIMDUTF_PPC64_H
+/* end file src/simdutf/ppc64.h */
+/* begin file src/simdutf/rvv.h */
+#ifndef SIMDUTF_RVV_H
+#define SIMDUTF_RVV_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "rvv.h must be included before fallback.h"
+#endif
+
+
+#define SIMDUTF_CAN_ALWAYS_RUN_RVV SIMDUTF_IS_RVV
+
+#ifndef SIMDUTF_IMPLEMENTATION_RVV
+  #define SIMDUTF_IMPLEMENTATION_RVV                                           \
+    (SIMDUTF_CAN_ALWAYS_RUN_RVV ||                                             \
+     (SIMDUTF_IS_RISCV64 && SIMDUTF_HAS_RVV_INTRINSICS &&                      \
+      SIMDUTF_HAS_RVV_TARGET_REGION))
+#endif
+
+#if SIMDUTF_IMPLEMENTATION_RVV
+
+  #if SIMDUTF_CAN_ALWAYS_RUN_RVV
+    #define SIMDUTF_TARGET_RVV
+  #else
+    #define SIMDUTF_TARGET_RVV SIMDUTF_TARGET_REGION("arch=+v")
+  #endif
+  #if !SIMDUTF_IS_ZVBB && SIMDUTF_HAS_ZVBB_INTRINSICS
+    #define SIMDUTF_TARGET_ZVBB SIMDUTF_TARGET_REGION("arch=+v,+zvbb")
+  #endif
+
+namespace simdutf {
+namespace rvv {} // namespace rvv
+} // namespace simdutf
+
+/* begin file src/simdutf/rvv/implementation.h */
+#ifndef SIMDUTF_RVV_IMPLEMENTATION_H
+#define SIMDUTF_RVV_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace rvv {
+
+namespace {
+using namespace simdutf;
+} // namespace
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("rvv", "RISC-V Vector Extension",
+                                internal::instruction_set::RVV),
+        _supports_zvbb(internal::detect_supported_architectures() &
+                       internal::instruction_set::ZVBB) {}
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+private:
+  const bool _supports_zvbb;
+
+#if SIMDUTF_IS_ZVBB
+  bool supports_zvbb() const { return true; }
+#elif SIMDUTF_HAS_ZVBB_INTRINSICS
+  bool supports_zvbb() const { return _supports_zvbb; }
+#else
+  bool supports_zvbb() const { return false; }
+#endif
+};
+
+} // namespace rvv
+} // namespace simdutf
+
+#endif // SIMDUTF_RVV_IMPLEMENTATION_H
+/* end file src/simdutf/rvv/implementation.h */
+/* begin file src/simdutf/rvv/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "rvv"
+// #define SIMDUTF_IMPLEMENTATION rvv
+
+#if SIMDUTF_CAN_ALWAYS_RUN_RVV
+// nothing needed.
+#else
+SIMDUTF_TARGET_RVV
+#endif
+/* end file src/simdutf/rvv/begin.h */
+/* begin file src/simdutf/rvv/intrinsics.h */
+#ifndef SIMDUTF_RVV_INTRINSICS_H
+#define SIMDUTF_RVV_INTRINSICS_H
+
+
+#include <riscv_vector.h>
+
+#if __riscv_v_intrinsic >= 1000000 || __GCC__ >= 14
+  #define simdutf_vrgather_u8m1x2(tbl, idx)                                    \
+    __riscv_vcreate_v_u8m1_u8m2(                                               \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 0),        \
+                                 __riscv_vsetvlmax_e8m1()),                    \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1),        \
+                                 __riscv_vsetvlmax_e8m1()));
+
+  #define simdutf_vrgather_u8m1x4(tbl, idx)                                    \
+    __riscv_vcreate_v_u8m1_u8m4(                                               \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 0),        \
+                                 __riscv_vsetvlmax_e8m1()),                    \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 1),        \
+                                 __riscv_vsetvlmax_e8m1()),                    \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2),        \
+                                 __riscv_vsetvlmax_e8m1()),                    \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3),        \
+                                 __riscv_vsetvlmax_e8m1()));
+#else
+  // This has worse codegen on gcc
+  #define simdutf_vrgather_u8m1x2(tbl, idx)                                    \
+    __riscv_vset_v_u8m1_u8m2(                                                  \
+        __riscv_vlmul_ext_v_u8m1_u8m2(__riscv_vrgather_vv_u8m1(                \
+            tbl, __riscv_vget_v_u8m2_u8m1(idx, 0), __riscv_vsetvlmax_e8m1())), \
+        1,                                                                     \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1),        \
+                                 __riscv_vsetvlmax_e8m1()))
+
+  #define simdutf_vrgather_u8m1x4(tbl, idx)                                    \
+    __riscv_vset_v_u8m1_u8m4(                                                  \
+        __riscv_vset_v_u8m1_u8m4(                                              \
+            __riscv_vset_v_u8m1_u8m4(                                          \
+                __riscv_vlmul_ext_v_u8m1_u8m4(__riscv_vrgather_vv_u8m1(        \
+                    tbl, __riscv_vget_v_u8m4_u8m1(idx, 0),                     \
+                    __riscv_vsetvlmax_e8m1())),                                \
+                1,                                                             \
+                __riscv_vrgather_vv_u8m1(tbl,                                  \
+                                         __riscv_vget_v_u8m4_u8m1(idx, 1),     \
+                                         __riscv_vsetvlmax_e8m1())),           \
+            2,                                                                 \
+            __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2),    \
+                                     __riscv_vsetvlmax_e8m1())),               \
+        3,                                                                     \
+        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3),        \
+                                 __riscv_vsetvlmax_e8m1()))
+#endif
+
+/* Zvbb adds dedicated support for endianness swaps with vrev8, but if we can't
+ * use that, we have to emulate it with the standard V extension.
+ * Using LMUL=1 vrgathers could be faster than the srl+macc variant, but that
+ * would increase register pressure, and vrgather implementations performance
+ * varies a lot. */
+enum class simdutf_ByteFlip { NONE, V, ZVBB };
+
+template <simdutf_ByteFlip method>
+simdutf_really_inline static uint16_t simdutf_byteflip(uint16_t v) {
+  if (method != simdutf_ByteFlip::NONE)
+    return (uint16_t)((v * 1u) << 8 | (v * 1u) >> 8);
+  return v;
+}
+
+#ifdef SIMDUTF_TARGET_ZVBB
+SIMDUTF_UNTARGET_REGION
+SIMDUTF_TARGET_ZVBB
+#endif
+
+template <simdutf_ByteFlip method>
+simdutf_really_inline static vuint16m1_t simdutf_byteflip(vuint16m1_t v,
+                                                          size_t vl) {
+#if SIMDUTF_HAS_ZVBB_INTRINSICS
+  if (method == simdutf_ByteFlip::ZVBB)
+    return __riscv_vrev8_v_u16m1(v, vl);
+#endif
+  if (method == simdutf_ByteFlip::V)
+    return __riscv_vmacc_vx_u16m1(__riscv_vsrl_vx_u16m1(v, 8, vl), 0x100, v,
+                                  vl);
+  return v;
+}
+
+template <simdutf_ByteFlip method>
+simdutf_really_inline static vuint16m2_t simdutf_byteflip(vuint16m2_t v,
+                                                          size_t vl) {
+#if SIMDUTF_HAS_ZVBB_INTRINSICS
+  if (method == simdutf_ByteFlip::ZVBB)
+    return __riscv_vrev8_v_u16m2(v, vl);
+#endif
+  if (method == simdutf_ByteFlip::V)
+    return __riscv_vmacc_vx_u16m2(__riscv_vsrl_vx_u16m2(v, 8, vl), 0x100, v,
+                                  vl);
+  return v;
+}
+
+template <simdutf_ByteFlip method>
+simdutf_really_inline static vuint16m4_t simdutf_byteflip(vuint16m4_t v,
+                                                          size_t vl) {
+#if SIMDUTF_HAS_ZVBB_INTRINSICS
+  if (method == simdutf_ByteFlip::ZVBB)
+    return __riscv_vrev8_v_u16m4(v, vl);
+#endif
+  if (method == simdutf_ByteFlip::V)
+    return __riscv_vmacc_vx_u16m4(__riscv_vsrl_vx_u16m4(v, 8, vl), 0x100, v,
+                                  vl);
+  return v;
+}
+
+template <simdutf_ByteFlip method>
+simdutf_really_inline static vuint16m8_t simdutf_byteflip(vuint16m8_t v,
+                                                          size_t vl) {
+#if SIMDUTF_HAS_ZVBB_INTRINSICS
+  if (method == simdutf_ByteFlip::ZVBB)
+    return __riscv_vrev8_v_u16m8(v, vl);
+#endif
+  if (method == simdutf_ByteFlip::V)
+    return __riscv_vmacc_vx_u16m8(__riscv_vsrl_vx_u16m8(v, 8, vl), 0x100, v,
+                                  vl);
+  return v;
+}
+
+#ifdef SIMDUTF_TARGET_ZVBB
+SIMDUTF_UNTARGET_REGION
+SIMDUTF_TARGET_RVV
+#endif
+
+#endif //  SIMDUTF_RVV_INTRINSICS_H
+/* end file src/simdutf/rvv/intrinsics.h */
+/* begin file src/simdutf/rvv/end.h */
+#if SIMDUTF_CAN_ALWAYS_RUN_RVV
+// nothing needed.
+#else
+SIMDUTF_UNTARGET_REGION
+#endif
+
+/* end file src/simdutf/rvv/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_RVV
+
+#endif // SIMDUTF_RVV_H
+/* end file src/simdutf/rvv.h */
+/* begin file src/simdutf/lsx.h */
+#ifndef SIMDUTF_LSX_H
+#define SIMDUTF_LSX_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "lsx.h must be included before fallback.h"
+#endif
+
+
+#ifndef SIMDUTF_IMPLEMENTATION_LSX
+  #define SIMDUTF_IMPLEMENTATION_LSX (SIMDUTF_IS_LSX)
+#endif
+#if SIMDUTF_IMPLEMENTATION_LSX && SIMDUTF_IS_LSX
+  #define SIMDUTF_CAN_ALWAYS_RUN_LSX 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_LSX 0
+#endif
+
+#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
+
+#if SIMDUTF_IMPLEMENTATION_LSX
+
+namespace simdutf {
+/**
+ * Implementation for LoongArch SX.
+ */
+namespace lsx {} // namespace lsx
+} // namespace simdutf
+
+/* begin file src/simdutf/lsx/implementation.h */
+#ifndef SIMDUTF_LSX_IMPLEMENTATION_H
+#define SIMDUTF_LSX_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace lsx {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("lsx", "LOONGARCH SX",
+                                internal::instruction_set::LSX) {}
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace lsx
+} // namespace simdutf
+
+#endif // SIMDUTF_LSX_IMPLEMENTATION_H
+/* end file src/simdutf/lsx/implementation.h */
+
+/* begin file src/simdutf/lsx/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "lsx"
+// #define SIMDUTF_IMPLEMENTATION lsx
+/* end file src/simdutf/lsx/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/lsx/intrinsics.h */
+#ifndef SIMDUTF_LSX_INTRINSICS_H
+#define SIMDUTF_LSX_INTRINSICS_H
+
+
+// This should be the correct header whether
+// you use visual studio or other compilers.
+#include <lsxintrin.h>
+
+#endif //  SIMDUTF_LSX_INTRINSICS_H
+/* end file src/simdutf/lsx/intrinsics.h */
+/* begin file src/simdutf/lsx/bitmanipulation.h */
+#ifndef SIMDUTF_LSX_BITMANIPULATION_H
+#define SIMDUTF_LSX_BITMANIPULATION_H
+
+#include <limits>
+
+namespace simdutf {
+namespace lsx {
+namespace {
+
+simdutf_really_inline int count_ones(uint64_t input_num) {
+  return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
+}
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
+  return __builtin_ctzll(input_num);
+}
+#endif
+
+} // unnamed namespace
+} // namespace lsx
+} // namespace simdutf
+
+#endif // SIMDUTF_LSX_BITMANIPULATION_H
+/* end file src/simdutf/lsx/bitmanipulation.h */
+/* begin file src/simdutf/lsx/simd.h */
+#ifndef SIMDUTF_LSX_SIMD_H
+#define SIMDUTF_LSX_SIMD_H
+
+#include <type_traits>
+
+namespace simdutf {
+namespace lsx {
+namespace {
+namespace simd {
+
+template <typename T> struct simd8;
+
+//
+// Base class of simd8<uint8_t> and simd8<bool>, both of which use __m128i
+// internally.
+//
+template <typename T, typename Mask = simd8<bool>> struct base_u8 {
+  __m128i value;
+  static const int SIZE = sizeof(value);
+
+  // Conversion from/to SIMD register
+  simdutf_really_inline base_u8(const __m128i _value) : value(_value) {}
+  simdutf_really_inline operator const __m128i &() const { return this->value; }
+  simdutf_really_inline operator __m128i &() { return this->value; }
+  simdutf_really_inline T first() const {
+    return __lsx_vpickve2gr_bu(this->value, 0);
+  }
+  simdutf_really_inline T last() const {
+    return __lsx_vpickve2gr_bu(this->value, 15);
+  }
+
+  // Bit operations
+  simdutf_really_inline simd8<T> operator|(const simd8<T> other) const {
+    return __lsx_vor_v(this->value, other);
+  }
+  simdutf_really_inline simd8<T> operator&(const simd8<T> other) const {
+    return __lsx_vand_v(this->value, other);
+  }
+  simdutf_really_inline simd8<T> operator^(const simd8<T> other) const {
+    return __lsx_vxor_v(this->value, other);
+  }
+  simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const {
+    return __lsx_vandn_v(this->value, other);
+  }
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+  simdutf_really_inline simd8<T> &operator|=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd8<T> &operator&=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd8<T> &operator^=(const simd8<T> other) {
+    auto this_cast = static_cast<simd8<T> *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+
+  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return __lsx_vseq_b(lhs, rhs);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
+    return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
+                       __lsx_vbsrl_v(prev_chunk.value, 16 - N));
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base_u8<bool> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return __lsx_vreplgr2vr_b(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8(const __m128i _value) : base_u8<bool>(_value) {}
+  // False constructor
+  simdutf_really_inline simd8() : simd8(__lsx_vldi(0)) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : simd8(splat(_value)) {}
+  simdutf_really_inline void store(uint8_t dst[16]) const {
+    return __lsx_vst(this->value, dst, 0);
+  }
+
+  simdutf_really_inline uint32_t to_bitmask() const {
+    return __lsx_vpickve2gr_wu(__lsx_vmsknz_b(*this), 0);
+  }
+
+  simdutf_really_inline bool any() const {
+    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) != 0;
+  }
+  simdutf_really_inline bool none() const {
+    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0;
+  }
+  simdutf_really_inline bool all() const {
+    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0xFFFF;
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base_u8<uint8_t> {
+  static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value) {
+    return __lsx_vreplgr2vr_b(_value);
+  }
+  static simdutf_really_inline simd8<uint8_t> zero() { return __lsx_vldi(0); }
+  static simdutf_really_inline simd8<uint8_t> load(const uint8_t *values) {
+    return __lsx_vld(values, 0);
+  }
+  simdutf_really_inline simd8(const __m128i _value)
+      : base_u8<uint8_t>(_value) {}
+  // Zero constructor
+  simdutf_really_inline simd8() : simd8(zero()) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t values[16]) : simd8(load(values)) {}
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Member-by-member initialization
+
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
+      : simd8((__m128i)v16u8{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                             v12, v13, v14, v15}) {}
+
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15);
+  }
+
+  // Store to array
+  simdutf_really_inline void store(uint8_t dst[16]) const {
+    return __lsx_vst(this->value, dst, 0);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return __lsx_vsadd_bu(this->value, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return __lsx_vssub_bu(this->value, other);
+  }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<uint8_t>
+  operator+(const simd8<uint8_t> other) const {
+    return __lsx_vadd_b(this->value, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  operator-(const simd8<uint8_t> other) const {
+    return __lsx_vsub_b(this->value, other);
+  }
+  simdutf_really_inline simd8<uint8_t> &operator+=(const simd8<uint8_t> other) {
+    *this = *this + other;
+    return *this;
+  }
+  simdutf_really_inline simd8<uint8_t> &operator-=(const simd8<uint8_t> other) {
+    *this = *this - other;
+    return *this;
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return __lsx_vmax_bu(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return __lsx_vmin_bu(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return __lsx_vsle_bu(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return __lsx_vsle_bu(other, *this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return __lsx_vslt_bu(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return __lsx_vslt_bu(other, *this);
+  }
+  // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
+  // = nonzero. For ARM, returns all 1's.
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return simd8<uint8_t>(*this > other);
+  }
+  // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
+  // = nonzero. For ARM, returns all 1's.
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return simd8<uint8_t>(*this < other);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return __lsx_vslt_bu(__lsx_vldi(0), __lsx_vand_v(this->value, bits));
+  }
+  simdutf_really_inline bool is_ascii() const {
+    return __lsx_vpickve2gr_hu(__lsx_vmskgez_b(this->value), 0) == 0xFFFF;
+  }
+
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(this->value), 0) > 0;
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return (*this & bits).any_bits_set_anywhere();
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return __lsx_vsrli_b(this->value, N);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return __lsx_vslli_b(this->value, N);
+  }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return lookup_table.apply_lookup_16_to(*this);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+
+  template <typename T>
+  simdutf_really_inline simd8<uint8_t>
+  apply_lookup_16_to(const simd8<T> original) const {
+    __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
+    return __lsx_vshuf_b(__lsx_vldi(0), *this, simd8<uint8_t>(original_tmp));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> {
+  __m128i value;
+
+  static simdutf_really_inline simd8<int8_t> splat(int8_t _value) {
+    return __lsx_vreplgr2vr_b(_value);
+  }
+  static simdutf_really_inline simd8<int8_t> zero() { return __lsx_vldi(0); }
+  static simdutf_really_inline simd8<int8_t> load(const int8_t values[16]) {
+    return __lsx_vld(values, 0);
+  }
+
+  template <endianness big_endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *p) const {
+    __m128i zero = __lsx_vldi(0);
+    if (match_system(big_endian)) {
+      __lsx_vst(__lsx_vilvl_b(zero, (__m128i)this->value),
+                reinterpret_cast<uint16_t *>(p), 0);
+      __lsx_vst(__lsx_vilvh_b(zero, (__m128i)this->value),
+                reinterpret_cast<uint16_t *>(p + 8), 0);
+    } else {
+      __lsx_vst(__lsx_vilvl_b((__m128i)this->value, zero),
+                reinterpret_cast<uint16_t *>(p), 0);
+      __lsx_vst(__lsx_vilvh_b((__m128i)this->value, zero),
+                reinterpret_cast<uint16_t *>(p + 8), 0);
+    }
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *p) const {
+    __m128i zero = __lsx_vldi(0);
+    __m128i in16low = __lsx_vilvl_b(zero, (__m128i)this->value);
+    __m128i in16high = __lsx_vilvh_b(zero, (__m128i)this->value);
+    __m128i in32_0 = __lsx_vilvl_h(zero, in16low);
+    __m128i in32_1 = __lsx_vilvh_h(zero, in16low);
+    __m128i in32_2 = __lsx_vilvl_h(zero, in16high);
+    __m128i in32_3 = __lsx_vilvh_h(zero, in16high);
+    __lsx_vst(in32_0, reinterpret_cast<uint32_t *>(p), 0);
+    __lsx_vst(in32_1, reinterpret_cast<uint32_t *>(p + 4), 0);
+    __lsx_vst(in32_2, reinterpret_cast<uint32_t *>(p + 8), 0);
+    __lsx_vst(in32_3, reinterpret_cast<uint32_t *>(p + 12), 0);
+  }
+
+  // In places where the table can be reused, which is most uses in simdutf, it
+  // is worth it to do 4 table lookups, as there is no direct zero extension
+  // from u8 to u32.
+  simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t *p) const {
+    const simd8<uint8_t> tb1{0, 255, 255, 255, 1, 255, 255, 255,
+                             2, 255, 255, 255, 3, 255, 255, 255};
+    const simd8<uint8_t> tb2{4, 255, 255, 255, 5, 255, 255, 255,
+                             6, 255, 255, 255, 7, 255, 255, 255};
+    const simd8<uint8_t> tb3{8,  255, 255, 255, 9,  255, 255, 255,
+                             10, 255, 255, 255, 11, 255, 255, 255};
+    const simd8<uint8_t> tb4{12, 255, 255, 255, 13, 255, 255, 255,
+                             14, 255, 255, 255, 15, 255, 255, 255};
+
+    // encourage store pairing and interleaving
+    const auto shuf1 = this->apply_lookup_16_to(tb1);
+    const auto shuf2 = this->apply_lookup_16_to(tb2);
+    shuf1.store(reinterpret_cast<int8_t *>(p));
+    shuf2.store(reinterpret_cast<int8_t *>(p + 4));
+
+    const auto shuf3 = this->apply_lookup_16_to(tb3);
+    const auto shuf4 = this->apply_lookup_16_to(tb4);
+    shuf3.store(reinterpret_cast<int8_t *>(p + 8));
+    shuf4.store(reinterpret_cast<int8_t *>(p + 12));
+  }
+  // Conversion from/to SIMD register
+  simdutf_really_inline simd8(const __m128i _value) : value(_value) {}
+  simdutf_really_inline operator const __m128i &() const { return this->value; }
+
+  simdutf_really_inline operator const __m128i() const { return this->value; }
+
+  simdutf_really_inline operator __m128i &() { return this->value; }
+
+  // Zero constructor
+  simdutf_really_inline simd8() : simd8(zero()) {}
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t *values) : simd8(load(values)) {}
+  // Member-by-member initialization
+
+  simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
+                              int8_t v4, int8_t v5, int8_t v6, int8_t v7,
+                              int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+                              int8_t v12, int8_t v13, int8_t v14, int8_t v15)
+      : simd8((__m128i)v16i8{v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                             v12, v13, v14, v15}) {}
+
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15);
+  }
+
+  // Store to array
+  simdutf_really_inline void store(int8_t dst[16]) const {
+    return __lsx_vst(value, dst, 0);
+  }
+
+  simdutf_really_inline operator simd8<uint8_t>() const {
+    return ((__m128i)this->value);
+  }
+
+  simdutf_really_inline simd8<int8_t>
+  operator|(const simd8<int8_t> other) const {
+    return __lsx_vor_v((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator&(const simd8<int8_t> other) const {
+    return __lsx_vand_v((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator^(const simd8<int8_t> other) const {
+    return __lsx_vxor_v((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  bit_andnot(const simd8<int8_t> other) const {
+    return __lsx_vandn_v((__m128i)other.value, (__m128i)value);
+  }
+
+  // Math
+  simdutf_really_inline simd8<int8_t>
+  operator+(const simd8<int8_t> other) const {
+    return __lsx_vadd_b((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t>
+  operator-(const simd8<int8_t> other) const {
+    return __lsx_vsub_b((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t> &operator+=(const simd8<int8_t> other) {
+    *this = *this + other;
+    return *this;
+  }
+  simdutf_really_inline simd8<int8_t> &operator-=(const simd8<int8_t> other) {
+    *this = *this - other;
+    return *this;
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return (__lsx_vpickve2gr_hu(__lsx_vmskgez_b((__m128i)this->value), 0) ==
+            0xffff);
+  }
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return __lsx_vmax_b((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return __lsx_vmin_b((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return __lsx_vslt_b((__m128i)other.value, (__m128i)value);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return __lsx_vslt_b((__m128i)value, (__m128i)other.value);
+  }
+  simdutf_really_inline simd8<bool>
+  operator==(const simd8<int8_t> other) const {
+    return __lsx_vseq_b((__m128i)value, (__m128i)other.value);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd8<int8_t>
+  prev(const simd8<int8_t> prev_chunk) const {
+    return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
+                       __lsx_vbsrl_v(prev_chunk.value, 16 - N));
+  }
+
+  // Perform a lookup assuming no value is larger than 16
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    return lookup_table.apply_lookup_16_to(*this);
+  }
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+
+  template <typename T>
+  simdutf_really_inline simd8<int8_t>
+  apply_lookup_16_to(const simd8<T> original) const {
+    __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
+    return __lsx_vshuf_b(__lsx_vldi(0), (__m128i)this->value,
+                         simd8<uint8_t>(original_tmp));
+  }
+};
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(
+      NUM_CHUNKS == 4,
+      "LoongArch kernel should use four registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
+                                 const simd8<T> chunk2, const simd8<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
+               simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    this->chunks[2] |= other.chunks[2];
+    this->chunks[3] |= other.chunks[3];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
+
+  template <endianness endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 0);
+    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 1);
+    this->chunks[2].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 2);
+    this->chunks[3].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
+    this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
+    this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
+    this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[3]), 6);
+    mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[2]), 4));
+    mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[1]), 2));
+    mask = __lsx_vor_v(mask, __lsx_vmsknz_b(this->chunks[0]));
+    return __lsx_vpickve2gr_du(mask, 0);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                          this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                          this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+    return simd8x64<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
+               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
+               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                          this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
+                          this->chunks[2] > mask, this->chunks[3] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
+                          this->chunks[2] >= mask, this->chunks[3] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>(simd8<uint8_t>(this->chunks[0].value) >= mask,
+                          simd8<uint8_t>(this->chunks[1].value) >= mask,
+                          simd8<uint8_t>(this->chunks[2].value) >= mask,
+                          simd8<uint8_t>(this->chunks[3].value) >= mask)
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+/* begin file src/simdutf/lsx/simd16-inl.h */
+template <typename T> struct simd16;
+
+template <typename T, typename Mask = simd16<bool>> struct base_u16 {
+  __m128i value;
+  static const int SIZE = sizeof(value);
+
+  // Conversion from/to SIMD register
+  simdutf_really_inline base_u16() = default;
+  simdutf_really_inline base_u16(const __m128i _value) : value(_value) {}
+  // Bit operations
+  simdutf_really_inline simd16<T> operator|(const simd16<T> other) const {
+    return __lsx_vor_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<T> operator&(const simd16<T> other) const {
+    return __lsx_vand_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<T> operator^(const simd16<T> other) const {
+    return __lsx_vxor_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const {
+    return __lsx_vandn_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
+  simdutf_really_inline simd16<T> &operator|=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd16<T> &operator&=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline simd16<T> &operator^=(const simd16<T> other) {
+    auto this_cast = static_cast<simd16<T> *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+
+  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
+                                               const simd16<T> rhs) {
+    return __lsx_vseq_h(lhs.value, rhs.value);
+  }
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
+                       __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
+  }
+};
+
+template <typename T, typename Mask = simd16<bool>>
+struct base16 : base_u16<T> {
+  typedef uint16_t bitmask_t;
+  typedef uint32_t bitmask2_t;
+
+  simdutf_really_inline base16() : base_u16<T>() {}
+  simdutf_really_inline base16(const __m128i _value) : base_u16<T>(_value) {}
+  template <typename Pointer>
+  simdutf_really_inline base16(const Pointer *ptr)
+      : base16(__lsx_vld(ptr, 0)) {}
+
+  static const int SIZE = sizeof(base_u16<T>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
+                       __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd16<bool> : base16<bool> {
+  static simdutf_really_inline simd16<bool> splat(bool _value) {
+    return __lsx_vreplgr2vr_h(uint16_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd16() : base16() {}
+  simdutf_really_inline simd16(const __m128i _value) : base16<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
+};
+
+template <typename T> struct base16_numeric : base16<T> {
+  static simdutf_really_inline simd16<T> splat(T _value) {
+    return __lsx_vreplgr2vr_h(_value);
+  }
+  static simdutf_really_inline simd16<T> zero() { return __lsx_vldi(0); }
+  static simdutf_really_inline simd16<T> load(const T values[8]) {
+    return __lsx_vld(reinterpret_cast<const uint16_t *>(values), 0);
+  }
+
+  simdutf_really_inline base16_numeric() : base16<T>() {}
+  simdutf_really_inline base16_numeric(const __m128i _value)
+      : base16<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[8]) const {
+    return __lsx_vst(this->value, dst, 0);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
+    return __lsx_vadd_b(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
+    return __lsx_vsub_b(*this, other);
+  }
+  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
+    *this = *this + other;
+    return *static_cast<simd16<T> *>(this);
+  }
+  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
+    *this = *this - other;
+    return *static_cast<simd16<T> *>(this);
+  }
+};
+
+// Signed code unitstemplate<>
+template <> struct simd16<int16_t> : base16_numeric<int16_t> {
+  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
+  simdutf_really_inline simd16(const __m128i _value)
+      : base16_numeric<int16_t>(_value) {}
+  simdutf_really_inline simd16(simd16<bool> other)
+      : base16_numeric<int16_t>(other.value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
+  simdutf_really_inline operator simd16<uint16_t>() const;
+
+  // Order-sensitive comparisons
+  simdutf_really_inline simd16<int16_t>
+  max_val(const simd16<int16_t> other) const {
+    return __lsx_vmax_h(this->value, other.value);
+  }
+  simdutf_really_inline simd16<int16_t>
+  min_val(const simd16<int16_t> other) const {
+    return __lsx_vmin_h(this->value, other.value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<int16_t> other) const {
+    return __lsx_vsle_h(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<int16_t> other) const {
+    return __lsx_vslt_h(this->value, other.value);
+  }
+};
+
+// Unsigned code unitstemplate<>
+template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
+  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
+  simdutf_really_inline simd16(const __m128i _value)
+      : base16_numeric<uint16_t>((__m128i)_value) {}
+  simdutf_really_inline simd16(simd16<bool> other)
+      : base16_numeric<uint16_t>(other.value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
+
+  // Saturated math
+  simdutf_really_inline simd16<uint16_t>
+  saturating_add(const simd16<uint16_t> other) const {
+    return __lsx_vsadd_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  saturating_sub(const simd16<uint16_t> other) const {
+    return __lsx_vssub_hu(this->value, other.value);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd16<uint16_t>
+  max_val(const simd16<uint16_t> other) const {
+    return __lsx_vmax_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  min_val(const simd16<uint16_t> other) const {
+    return __lsx_vmin_hu(this->value, other.value);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  gt_bits(const simd16<uint16_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  lt_bits(const simd16<uint16_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<=(const simd16<uint16_t> other) const {
+    return __lsx_vsle_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>=(const simd16<uint16_t> other) const {
+    return __lsx_vsle_hu(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<uint16_t> other) const {
+    return __lsx_vslt_hu(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<uint16_t> other) const {
+    return __lsx_vslt_hu(this->value, other.value);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd16<bool> bits_not_set() const {
+    return *this == uint16_t(0);
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
+    return simd16<uint16_t>(__lsx_vsrli_h(this->value, N));
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
+    return simd16<uint16_t>(__lsx_vslli_h(this->value, N));
+  }
+
+  // logical operations
+  simdutf_really_inline simd16<uint16_t>
+  operator|(const simd16<uint16_t> other) const {
+    return __lsx_vor_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  operator&(const simd16<uint16_t> other) const {
+    return __lsx_vand_v(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  operator^(const simd16<uint16_t> other) const {
+    return __lsx_vxor_v(this->value, other.value);
+  }
+
+  // Pack with the unsigned saturation of two uint16_t code units into single
+  // uint8_t vector
+  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
+                                                   const simd16<uint16_t> &v1) {
+    return __lsx_vssrlni_bu_h(v1.value, v0.value, 0);
+  }
+
+  // Change the endianness
+  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
+    return __lsx_vshuf4i_b(this->value, 0b10110001);
+  }
+};
+
+simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd16x32 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
+  static_assert(
+      NUM_CHUNKS == 4,
+      "LOONGARCH kernel should use four registers per 64-byte block.");
+  simd16<T> chunks[NUM_CHUNKS];
+
+  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
+  simd16x32<T> &
+  operator=(const simd16<T> other) = delete; // no assignment allowed
+  simd16x32() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline
+  simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
+            const simd16<T> chunk2, const simd16<T> chunk3)
+      : chunks{chunk0, chunk1, chunk2, chunk3} {}
+  simdutf_really_inline simd16x32(const T *ptr)
+      : chunks{simd16<T>::load(ptr),
+               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
+               simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
+    this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
+    this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
+  }
+
+  simdutf_really_inline simd16<T> reduce_or() const {
+    return (this->chunks[0] | this->chunks[1]) |
+           (this->chunks[2] | this->chunks[3]);
+  }
+
+  simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }
+
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
+    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
+    this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
+    this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[3]).value), 6);
+    mask = __lsx_vor_v(
+        mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[2]).value), 4));
+    mask = __lsx_vor_v(
+        mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[1]).value), 2));
+    mask = __lsx_vor_v(mask, __lsx_vmsknz_b((this->chunks[0]).value));
+    return __lsx_vpickve2gr_du(mask, 0);
+  }
+
+  simdutf_really_inline void swap_bytes() {
+    this->chunks[0] = this->chunks[0].swap_bytes();
+    this->chunks[1] = this->chunks[1].swap_bytes();
+    this->chunks[2] = this->chunks[2].swap_bytes();
+    this->chunks[3] = this->chunks[3].swap_bytes();
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
+                           this->chunks[2] == mask, this->chunks[3] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
+                           this->chunks[2] <= mask, this->chunks[3] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+
+    return simd16x32<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
+               (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
+               (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+    return simd16x32<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
+               (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
+               (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
+                           this->chunks[2] < mask, this->chunks[3] < mask)
+        .to_bitmask();
+  }
+
+}; // struct simd16x32<T>
+
+template <>
+simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
+    const uint16_t low, const uint16_t high) const {
+  const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
+  const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
+  simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) |
+                                         (this->chunks[0] < mask_low)),
+                        simd16<uint16_t>((this->chunks[1] > mask_high) |
+                                         (this->chunks[1] < mask_low)),
+                        simd16<uint16_t>((this->chunks[2] > mask_high) |
+                                         (this->chunks[2] < mask_low)),
+                        simd16<uint16_t>((this->chunks[3] > mask_high) |
+                                         (this->chunks[3] < mask_low)));
+  return x.to_bitmask();
+}
+/* end file src/simdutf/lsx/simd16-inl.h */
+} // namespace simd
+} // unnamed namespace
+} // namespace lsx
+} // namespace simdutf
+
+#endif // SIMDUTF_LSX_SIMD_H
+/* end file src/simdutf/lsx/simd.h */
+
+/* begin file src/simdutf/lsx/end.h */
+/* end file src/simdutf/lsx/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_LSX
+
+#endif // SIMDUTF_LSX_H
+/* end file src/simdutf/lsx.h */
+/* begin file src/simdutf/lasx.h */
+#ifndef SIMDUTF_LASX_H
+#define SIMDUTF_LASX_H
+
+#ifdef SIMDUTF_FALLBACK_H
+  #error "lasx.h must be included before fallback.h"
+#endif
+
+
+#ifndef SIMDUTF_IMPLEMENTATION_LASX
+  #define SIMDUTF_IMPLEMENTATION_LASX (SIMDUTF_IS_LASX)
+#endif
+#if SIMDUTF_IMPLEMENTATION_LASX && SIMDUTF_IS_LASX
+  #define SIMDUTF_CAN_ALWAYS_RUN_LASX 1
+#else
+  #define SIMDUTF_CAN_ALWAYS_RUN_LASX 0
+#endif
+
+#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
+
+#if SIMDUTF_IMPLEMENTATION_LASX
+
+namespace simdutf {
+/**
+ * Implementation for LoongArch ASX.
+ */
+namespace lasx {} // namespace lasx
+} // namespace simdutf
+
+/* begin file src/simdutf/lasx/implementation.h */
+#ifndef SIMDUTF_LASX_IMPLEMENTATION_H
+#define SIMDUTF_LASX_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace lasx {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("lasx", "LOONGARCH ASX",
+                                internal::instruction_set::LSX |
+                                    internal::instruction_set::LASX) {}
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+
+} // namespace lasx
+} // namespace simdutf
+
+#endif // SIMDUTF_LASX_IMPLEMENTATION_H
+/* end file src/simdutf/lasx/implementation.h */
+
+/* begin file src/simdutf/lasx/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "lasx"
+// #define SIMDUTF_IMPLEMENTATION lasx
+/* end file src/simdutf/lasx/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/lasx/intrinsics.h */
+#ifndef SIMDUTF_LASX_INTRINSICS_H
+#define SIMDUTF_LASX_INTRINSICS_H
+
+
+// This should be the correct header whether
+// you use visual studio or other compilers.
+#include <lsxintrin.h>
+#include <lasxintrin.h>
+
+#if defined(__loongarch_asx)
+  #ifdef __clang__
+    #define VREGS_PREFIX "$vr"
+    #define XREGS_PREFIX "$xr"
+  #else // GCC
+    #define VREGS_PREFIX "$f"
+    #define XREGS_PREFIX "$f"
+  #endif
+  #define __ALL_REGS                                                           \
+    "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,"  \
+    "27,28,29,30,31"
+// Convert __m128i to __m256i
+static inline __m256i ____m256i(__m128i in) {
+  __m256i out = __lasx_xvldi(0);
+  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
+                   " .ifc %[out], " XREGS_PREFIX "\\i    \n\t"
+                   "  .irp j," __ALL_REGS "\n\t"
+                   "   .ifc %[in], " VREGS_PREFIX "\\j  \n\t"
+                   "    xvpermi.q $xr\\i, $xr\\j, 0x0  \n\t"
+                   "   .endif                           \n\t"
+                   "  .endr                             \n\t"
+                   " .endif                             \n\t"
+                   ".endr                               \n\t"
+                   : [out] "+f"(out)
+                   : [in] "f"(in));
+  return out;
+}
+// Convert two __m128i to __m256i
+static inline __m256i lasx_set_q(__m128i inhi, __m128i inlo) {
+  __m256i out;
+  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
+                   " .ifc %[hi], " VREGS_PREFIX "\\i    \n\t"
+                   "  .irp j," __ALL_REGS "\n\t"
+                   "   .ifc %[lo], " VREGS_PREFIX "\\j  \n\t"
+                   "    xvpermi.q $xr\\i, $xr\\j, 0x20  \n\t"
+                   "   .endif                           \n\t"
+                   "  .endr                             \n\t"
+                   " .endif                             \n\t"
+                   ".endr                               \n\t"
+                   ".ifnc %[out], %[hi]                 \n\t"
+                   ".irp i," __ALL_REGS "\n\t"
+                   " .ifc %[out], " XREGS_PREFIX "\\i   \n\t"
+                   "  .irp j," __ALL_REGS "\n\t"
+                   "   .ifc %[hi], " VREGS_PREFIX "\\j  \n\t"
+                   "    xvori.b $xr\\i, $xr\\j, 0       \n\t"
+                   "   .endif                           \n\t"
+                   "  .endr                             \n\t"
+                   " .endif                             \n\t"
+                   ".endr                               \n\t"
+                   ".endif                              \n\t"
+                   : [out] "=f"(out), [hi] "+f"(inhi)
+                   : [lo] "f"(inlo));
+  return out;
+}
+// Convert __m256i low part to __m128i
+static inline __m128i lasx_extracti128_lo(__m256i in) {
+  __m128i out;
+  __asm__ volatile(".ifnc %[out], %[in]                 \n\t"
+                   ".irp i," __ALL_REGS "\n\t"
+                   " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
+                   "  .irp j," __ALL_REGS "\n\t"
+                   "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
+                   "    vori.b $vr\\i, $vr\\j, 0        \n\t"
+                   "   .endif                           \n\t"
+                   "  .endr                             \n\t"
+                   " .endif                             \n\t"
+                   ".endr                               \n\t"
+                   ".endif                              \n\t"
+                   : [out] "=f"(out)
+                   : [in] "f"(in));
+  return out;
+}
+// Convert __m256i high part to __m128i
+static inline __m128i lasx_extracti128_hi(__m256i in) {
+  __m128i out;
+  __asm__ volatile(".irp i," __ALL_REGS "\n\t"
+                   " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
+                   "  .irp j," __ALL_REGS "\n\t"
+                   "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
+                   "    xvpermi.q $xr\\i, $xr\\j, 0x11  \n\t"
+                   "   .endif                           \n\t"
+                   "  .endr                             \n\t"
+                   " .endif                             \n\t"
+                   ".endr                               \n\t"
+                   : [out] "=f"(out)
+                   : [in] "f"(in));
+  return out;
+}
+#endif
+
+#endif //  SIMDUTF_LASX_INTRINSICS_H
+/* end file src/simdutf/lasx/intrinsics.h */
+/* begin file src/simdutf/lasx/bitmanipulation.h */
+#ifndef SIMDUTF_LASX_BITMANIPULATION_H
+#define SIMDUTF_LASX_BITMANIPULATION_H
+
+#include <limits>
+
+namespace simdutf {
+namespace lasx {
+namespace {
+
+simdutf_really_inline int count_ones(uint64_t input_num) {
+  return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
+}
+
+#if SIMDUTF_NEED_TRAILING_ZEROES
+simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
+  return __builtin_ctzll(input_num);
+}
+#endif
+
+} // unnamed namespace
+} // namespace lasx
+} // namespace simdutf
+
+#endif // SIMDUTF_LASX_BITMANIPULATION_H
+/* end file src/simdutf/lasx/bitmanipulation.h */
+/* begin file src/simdutf/lasx/simd.h */
+#ifndef SIMDUTF_LASX_SIMD_H
+#define SIMDUTF_LASX_SIMD_H
+
+#include <type_traits>
+
+namespace simdutf {
+namespace lasx {
+namespace {
+namespace simd {
+
+__attribute__((aligned(32))) static const uint8_t prev_shuf_table[32][32] = {
+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+    {0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+     31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14},
+    {0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
+     30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},
+    {0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+     29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
+    {0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
+     28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},
+    {0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+     27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
+    {0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
+     26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
+    {0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7, 8,
+     25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6, 7,
+     24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5, 6,
+     23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4, 5,
+     22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3, 4,
+     21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2, 3,
+     20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1, 2,
+     19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 1,
+     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1},
+    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0},
+    {15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
+     15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+     14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
+     13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
+     12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
+     11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+     10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+     9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0},
+    {8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
+     8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0},
+    {7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+     7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0,  0},
+    {6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+     6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0,  0},
+    {5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
+     5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0,  0},
+    {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+     4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0,  0},
+    {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
+     3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0,  0},
+    {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+     2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0,  0},
+    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
+     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0},
+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+};
+
+__attribute__((aligned(32))) static const uint8_t bitsel_mask_table[32][32] = {
+    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,  0x0},
+    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0}};
+
+// Forward-declared so they can be used by splat and friends.
+template <typename Child> struct base {
+  __m256i value;
+
+  // Zero constructor
+  simdutf_really_inline base() : value{__m256i()} {}
+
+  // Conversion from SIMD register
+  simdutf_really_inline base(const __m256i _value) : value(_value) {}
+  // Conversion to SIMD register
+  simdutf_really_inline operator const __m256i &() const { return this->value; }
+  simdutf_really_inline operator __m256i &() { return this->value; }
+  template <endianness big_endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    if (big_endian) {
+      __m256i zero = __lasx_xvldi(0);
+      __m256i in8 = __lasx_xvpermi_d(this->value, 0b11011000);
+      __m256i inlow = __lasx_xvilvl_b(in8, zero);
+      __m256i inhigh = __lasx_xvilvh_b(in8, zero);
+      __lasx_xvst(inlow, reinterpret_cast<uint16_t *>(ptr), 0);
+      __lasx_xvst(inhigh, reinterpret_cast<uint16_t *>(ptr), 32);
+    } else {
+      __m256i inlow = __lasx_vext2xv_hu_bu(this->value);
+      __m256i inhigh = __lasx_vext2xv_hu_bu(
+          __lasx_xvpermi_q(this->value, this->value, 0b00000001));
+      __lasx_xvst(inlow, reinterpret_cast<__m256i *>(ptr), 0);
+      __lasx_xvst(inhigh, reinterpret_cast<__m256i *>(ptr), 32);
+    }
+  }
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    __m256i in32_0 = __lasx_vext2xv_wu_bu(this->value);
+    __lasx_xvst(in32_0, reinterpret_cast<uint32_t *>(ptr), 0);
+
+    __m256i in8_1 = __lasx_xvpermi_d(this->value, 0b00000001);
+    __m256i in32_1 = __lasx_vext2xv_wu_bu(in8_1);
+    __lasx_xvst(in32_1, reinterpret_cast<uint32_t *>(ptr), 32);
+
+    __m256i in8_2 = __lasx_xvpermi_d(this->value, 0b00000010);
+    __m256i in32_2 = __lasx_vext2xv_wu_bu(in8_2);
+    __lasx_xvst(in32_2, reinterpret_cast<uint32_t *>(ptr), 64);
+
+    __m256i in8_3 = __lasx_xvpermi_d(this->value, 0b00000011);
+    __m256i in32_3 = __lasx_vext2xv_wu_bu(in8_3);
+    __lasx_xvst(in32_3, reinterpret_cast<uint32_t *>(ptr), 96);
+  }
+  // Bit operations
+  simdutf_really_inline Child operator|(const Child other) const {
+    return __lasx_xvor_v(this->value, other);
+  }
+  simdutf_really_inline Child operator&(const Child other) const {
+    return __lasx_xvand_v(this->value, other);
+  }
+  simdutf_really_inline Child operator^(const Child other) const {
+    return __lasx_xvxor_v(this->value, other);
+  }
+  simdutf_really_inline Child bit_andnot(const Child other) const {
+    return __lasx_xvandn_v(this->value, other);
+  }
+  simdutf_really_inline Child &operator|=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast | other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator&=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast & other;
+    return *this_cast;
+  }
+  simdutf_really_inline Child &operator^=(const Child other) {
+    auto this_cast = static_cast<Child *>(this);
+    *this_cast = *this_cast ^ other;
+    return *this_cast;
+  }
+};
+
+template <typename T> struct simd8;
+
+template <typename T, typename Mask = simd8<bool>>
+struct base8 : base<simd8<T>> {
+  typedef uint32_t bitmask_t;
+  typedef uint64_t bitmask2_t;
+
+  simdutf_really_inline base8() : base<simd8<T>>() {}
+  simdutf_really_inline base8(const __m256i _value) : base<simd8<T>>(_value) {}
+  simdutf_really_inline T first() const {
+    return __lasx_xvpickve2gr_wu(this->value, 0);
+  }
+  simdutf_really_inline T last() const {
+    return __lasx_xvpickve2gr_wu(this->value, 7);
+  }
+  friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
+                                               const simd8<T> rhs) {
+    return __lasx_xvseq_b(lhs, rhs);
+  }
+
+  static const int SIZE = sizeof(base<T>::value);
+
+  template <int N = 1>
+  simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const {
+    if (!N)
+      return this->value;
+
+    __m256i zero = __lasx_xvldi(0);
+    __m256i result, shuf;
+    if (N < 16) {
+      shuf = __lasx_xvld(prev_shuf_table[N], 0);
+
+      result = __lasx_xvshuf_b(
+          __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
+          shuf);
+      __m256i srl_prev = __lasx_xvbsrl_v(
+          __lasx_xvpermi_q(zero, prev_chunk.value, 0b00110001), (16 - N));
+      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
+      result = __lasx_xvbitsel_v(result, srl_prev, mask);
+
+      return result;
+    } else if (N == 16) {
+      return __lasx_xvpermi_q(this->value, prev_chunk.value, 0b00100001);
+    } /*else {
+      __m256i sll_value = __lasx_xvbsll_v(
+          __lasx_xvpermi_q(zero, this->value, 0b00000011), (N - 16) % 32);
+      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
+      shuf = __lasx_xvld(prev_shuf_table[N], 0);
+      result = __lasx_xvshuf_b(
+          __lasx_xvpermi_q(prev_chunk.value, prev_chunk.value, 0b00000001),
+          prev_chunk.value, shuf);
+      result = __lasx_xvbitsel_v(sll_value, result, mask);
+      return result;
+    }*/
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd8<bool> : base8<bool> {
+  static simdutf_really_inline simd8<bool> splat(bool _value) {
+    return __lasx_xvreplgr2vr_b(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd8() : base8() {}
+  simdutf_really_inline simd8(const __m256i _value) : base8<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(bool _value) : base8<bool>(splat(_value)) {}
+
+  simdutf_really_inline uint32_t to_bitmask() const {
+    __m256i mask = __lasx_xvmsknz_b(this->value);
+    uint32_t mask0 = __lasx_xvpickve2gr_wu(mask, 0);
+    uint32_t mask1 = __lasx_xvpickve2gr_wu(mask, 4);
+    return (mask0 | (mask1 << 16));
+  }
+  simdutf_really_inline bool any() const {
+    if (__lasx_xbz_b(this->value))
+      return false;
+    return true;
+  }
+  simdutf_really_inline bool none() const {
+    if (__lasx_xbz_b(this->value))
+      return true;
+    return false;
+  }
+  simdutf_really_inline bool all() const {
+    if (__lasx_xbnz_b(this->value))
+      return true;
+    return false;
+  }
+  simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base8_numeric : base8<T> {
+  static simdutf_really_inline simd8<T> splat(T _value) {
+    return __lasx_xvreplgr2vr_b(_value);
+  }
+  static simdutf_really_inline simd8<T> zero() { return __lasx_xvldi(0); }
+  static simdutf_really_inline simd8<T> load(const T values[32]) {
+    return __lasx_xvld(reinterpret_cast<const __m256i *>(values), 0);
+  }
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
+                                                  T v5, T v6, T v7, T v8, T v9,
+                                                  T v10, T v11, T v12, T v13,
+                                                  T v14, T v15) {
+    return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
+                    v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
+                    v12, v13, v14, v15);
+  }
+
+  simdutf_really_inline base8_numeric() : base8<T>() {}
+  simdutf_really_inline base8_numeric(const __m256i _value)
+      : base8<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[32]) const {
+    return __lasx_xvst(this->value, reinterpret_cast<__m256i *>(dst), 0);
+  }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd8<T> operator+(const simd8<T> other) const {
+    return __lasx_xvadd_b(this->value, other);
+  }
+  simdutf_really_inline simd8<T> operator-(const simd8<T> other) const {
+    return __lasx_xvsub_b(this->value, other);
+  }
+  simdutf_really_inline simd8<T> &operator+=(const simd8<T> other) {
+    *this = *this + other;
+    return *static_cast<simd8<T> *>(this);
+  }
+  simdutf_really_inline simd8<T> &operator-=(const simd8<T> other) {
+    *this = *this - other;
+    return *static_cast<simd8<T> *>(this);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
+
+  // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
+  // for out of range values)
+  template <typename L>
+  simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const {
+    __m256i origin = __lasx_xvand_v(this->value, __lasx_xvldi(0x1f));
+    return __lasx_xvshuf_b(__lasx_xvldi(0), lookup_table, origin);
+  }
+
+  template <typename L>
+  simdutf_really_inline simd8<L>
+  lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
+            L replace5, L replace6, L replace7, L replace8, L replace9,
+            L replace10, L replace11, L replace12, L replace13, L replace14,
+            L replace15) const {
+    return lookup_16(simd8<L>::repeat_16(
+        replace0, replace1, replace2, replace3, replace4, replace5, replace6,
+        replace7, replace8, replace9, replace10, replace11, replace12,
+        replace13, replace14, replace15));
+  }
+};
+
+// Signed bytes
+template <> struct simd8<int8_t> : base8_numeric<int8_t> {
+  simdutf_really_inline simd8() : base8_numeric<int8_t>() {}
+  simdutf_really_inline simd8(const __m256i _value)
+      : base8_numeric<int8_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd8(int8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const int8_t values[32]) : simd8(load(values)) {}
+  simdutf_really_inline operator simd8<uint8_t>() const;
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
+        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
+        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
+        int8_t v30, int8_t v31)
+      : simd8((__m256i)v32i8{v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
+                             v8,  v9,  v10, v11, v12, v13, v14, v15,
+                             v16, v17, v18, v19, v20, v21, v22, v23,
+                             v24, v25, v26, v27, v28, v29, v30, v31}) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<int8_t>
+  repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
+            int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
+            int8_t v12, int8_t v13, int8_t v14, int8_t v15) {
+    return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                         v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                         v10, v11, v12, v13, v14, v15);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
+    if (__lasx_xbnz_v(ascii_mask))
+      return false;
+    return true;
+  }
+  // Order-sensitive comparisons
+  simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const {
+    return __lasx_xvmax_b(this->value, other);
+  }
+  simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const {
+    return __lasx_xvmin_b(this->value, other);
+  }
+  simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const {
+    return __lasx_xvslt_b(other, this->value);
+  }
+  simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const {
+    return __lasx_xvslt_b(this->value, other);
+  }
+};
+
+// Unsigned bytes
+template <> struct simd8<uint8_t> : base8_numeric<uint8_t> {
+  simdutf_really_inline simd8() : base8_numeric<uint8_t>() {}
+  simdutf_really_inline simd8(const __m256i _value)
+      : base8_numeric<uint8_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd8(uint8_t _value) : simd8(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd8(const uint8_t values[32]) : simd8(load(values)) {}
+  // Member-by-member initialization
+  simdutf_really_inline
+  simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
+        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
+        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
+        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
+        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
+        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
+        uint8_t v31)
+      : simd8((__m256i)v32u8{v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,
+                             v8,  v9,  v10, v11, v12, v13, v14, v15,
+                             v16, v17, v18, v19, v20, v21, v22, v23,
+                             v24, v25, v26, v27, v28, v29, v30, v31}) {}
+  // Repeat 16 values as many times as necessary (usually for lookup tables)
+  simdutf_really_inline static simd8<uint8_t>
+  repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
+            uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
+            uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
+            uint8_t v15) {
+    return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
+                          v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
+                          v10, v11, v12, v13, v14, v15);
+  }
+
+  // Saturated math
+  simdutf_really_inline simd8<uint8_t>
+  saturating_add(const simd8<uint8_t> other) const {
+    return __lasx_xvsadd_bu(this->value, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  saturating_sub(const simd8<uint8_t> other) const {
+    return __lasx_xvssub_bu(this->value, other);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd8<uint8_t>
+  max_val(const simd8<uint8_t> other) const {
+    return __lasx_xvmax_bu(*this, other);
+  }
+  simdutf_really_inline simd8<uint8_t>
+  min_val(const simd8<uint8_t> other) const {
+    return __lasx_xvmin_bu(*this, other);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  gt_bits(const simd8<uint8_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd8<uint8_t>
+  lt_bits(const simd8<uint8_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<=(const simd8<uint8_t> other) const {
+    return __lasx_xvsle_bu(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>=(const simd8<uint8_t> other) const {
+    return __lasx_xvsle_bu(other, *this);
+  }
+  simdutf_really_inline simd8<bool>
+  operator>(const simd8<uint8_t> other) const {
+    return __lasx_xvslt_bu(*this, other);
+  }
+  simdutf_really_inline simd8<bool>
+  operator<(const simd8<uint8_t> other) const {
+    return __lasx_xvslt_bu(other, *this);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd8<bool> bits_not_set() const {
+    return *this == uint8_t(0);
+  }
+  simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+  simdutf_really_inline bool is_ascii() const {
+    __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
+    if (__lasx_xbnz_v(ascii_mask))
+      return false;
+    return true;
+  }
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    if (__lasx_xbnz_v(this->value))
+      return true;
+    return false;
+  }
+  simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const {
+    return (*this & bits).any_bits_set_anywhere();
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shr() const {
+    return __lasx_xvsrli_b(this->value, N);
+  }
+  template <int N> simdutf_really_inline simd8<uint8_t> shl() const {
+    return __lasx_xvslli_b(this->value, N);
+  }
+};
+simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const {
+  return this->value;
+}
+
+template <typename T> struct simd8x64 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
+  static_assert(NUM_CHUNKS == 2,
+                "LASX kernel should use two registers per 64-byte block.");
+  simd8<T> chunks[NUM_CHUNKS];
+
+  simd8x64(const simd8x64<T> &o) = delete; // no copy allowed
+  simd8x64<T> &
+  operator=(const simd8<T> other) = delete; // no assignment allowed
+  simd8x64() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
+      : chunks{chunk0, chunk1} {}
+  simdutf_really_inline simd8x64(const T *ptr)
+      : chunks{simd8<T>::load(ptr),
+               simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r_hi = this->chunks[1].to_bitmask();
+    return r_lo | (r_hi << 32);
+  }
+
+  simdutf_really_inline simd8x64<T> &operator|=(const simd8x64<T> &other) {
+    this->chunks[0] |= other.chunks[0];
+    this->chunks[1] |= other.chunks[1];
+    return *this;
+  }
+
+  simdutf_really_inline simd8<T> reduce_or() const {
+    return this->chunks[0] | this->chunks[1];
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  template <endianness endian>
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 0);
+    this->chunks[1].template store_ascii_as_utf16<endian>(ptr +
+                                                          sizeof(simd8<T>) * 1);
+  }
+
+  simdutf_really_inline void store_ascii_as_utf32(char32_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
+    this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
+  }
+
+  simdutf_really_inline simd8x64<T> bit_or(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd8x64<uint8_t> &other) const {
+    return simd8x64<bool>(this->chunks[0] == other.chunks[0],
+                          this->chunks[1] == other.chunks[1])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+
+    return simd8x64<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd8<T> mask_low = simd8<T>::splat(low);
+    const simd8<T> mask_high = simd8<T>::splat(high);
+    return simd8x64<bool>(
+               (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
+               (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t gt(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq(const T m) const {
+    const simd8<T> mask = simd8<T>::splat(m);
+    return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const {
+    const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
+    return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
+                          (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
+        .to_bitmask();
+  }
+}; // struct simd8x64<T>
+
+/* begin file src/simdutf/lasx/simd16-inl.h */
+template <typename T> struct simd16;
+
+template <typename T, typename Mask = simd16<bool>>
+struct base16 : base<simd16<T>> {
+  using bitmask_type = uint32_t;
+
+  simdutf_really_inline base16() : base<simd16<T>>() {}
+  simdutf_really_inline base16(const __m256i _value)
+      : base<simd16<T>>(_value) {}
+  template <typename Pointer>
+  simdutf_really_inline base16(const Pointer *ptr)
+      : base16(__lasx_xvld(reinterpret_cast<const __m256i *>(ptr), 0)) {}
+  friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
+                                               const simd16<T> rhs) {
+    return __lasx_xvseq_h(lhs.value, rhs.value);
+  }
+
+  /// the size of vector in bytes
+  static const int SIZE = sizeof(base<simd16<T>>::value);
+
+  /// the number of elements of type T a vector can hold
+  static const int ELEMENTS = SIZE / sizeof(T);
+
+  template <int N = 1>
+  simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const {
+    if (!N)
+      return this->value;
+
+    __m256i zero = __lasx_xvldi(0);
+    __m256i result, shuf;
+    if (N < 8) {
+      shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);
+
+      result = __lasx_xvshuf_b(
+          __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
+          shuf);
+      __m256i srl_prev = __lasx_xvbsrl_v(
+          __lasx_xvpermi_q(zero, prev_chunk, 0b00110001), (16 - N * 2));
+      __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
+      result = __lasx_xvbitsel_v(result, srl_prev, mask);
+
+      return result;
+    } else if (N == 8) {
+      return __lasx_xvpermi_q(this->value, prev_chunk, 0b00100001);
+    } else {
+      __m256i sll_value = __lasx_xvbsll_v(
+          __lasx_xvpermi_q(zero, this->value, 0b00000011), (N * 2 - 16));
+      __m256i mask = __lasx_xvld(bitsel_mask_table[N * 2], 0);
+      shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);
+      result =
+          __lasx_xvshuf_b(__lasx_xvpermi_q(prev_chunk, prev_chunk, 0b00000001),
+                          prev_chunk, shuf);
+      result = __lasx_xvbitsel_v(sll_value, result, mask);
+      return result;
+    }
+  }
+};
+
+// SIMD byte mask type (returned by things like eq and gt)
+template <> struct simd16<bool> : base16<bool> {
+  static simdutf_really_inline simd16<bool> splat(bool _value) {
+    return __lasx_xvreplgr2vr_h(uint8_t(-(!!_value)));
+  }
+
+  simdutf_really_inline simd16() : base16() {}
+  simdutf_really_inline simd16(const __m256i _value) : base16<bool>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(bool _value) : base16<bool>(splat(_value)) {}
+
+  simdutf_really_inline bitmask_type to_bitmask() const {
+    __m256i mask = __lasx_xvmsknz_b(this->value);
+    bitmask_type mask0 = __lasx_xvpickve2gr_wu(mask, 0);
+    bitmask_type mask1 = __lasx_xvpickve2gr_wu(mask, 4);
+    return (mask0 | (mask1 << 16));
+  }
+  simdutf_really_inline bool any() const {
+    if (__lasx_xbz_v(this->value))
+      return false;
+    return true;
+  }
+  simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
+};
+
+template <typename T> struct base16_numeric : base16<T> {
+  static simdutf_really_inline simd16<T> splat(T _value) {
+    return __lasx_xvreplgr2vr_h((uint16_t)_value);
+  }
+  static simdutf_really_inline simd16<T> zero() { return __lasx_xvldi(0); }
+  static simdutf_really_inline simd16<T> load(const T values[8]) {
+    return __lasx_xvld(reinterpret_cast<const __m256i *>(values), 0);
+  }
+
+  simdutf_really_inline base16_numeric() : base16<T>() {}
+  simdutf_really_inline base16_numeric(const __m256i _value)
+      : base16<T>(_value) {}
+
+  // Store to array
+  simdutf_really_inline void store(T dst[8]) const {
+    return __lasx_xvst(this->value, reinterpret_cast<__m256i *>(dst), 0);
+  }
+
+  // Override to distinguish from bool version
+  simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }
+
+  // Addition/subtraction are the same for signed and unsigned
+  simdutf_really_inline simd16<T> operator+(const simd16<T> other) const {
+    return __lasx_xvadd_h(*this, other);
+  }
+  simdutf_really_inline simd16<T> operator-(const simd16<T> other) const {
+    return __lasx_xvsub_h(*this, other);
+  }
+  simdutf_really_inline simd16<T> &operator+=(const simd16<T> other) {
+    *this = *this + other;
+    return *static_cast<simd16<T> *>(this);
+  }
+  simdutf_really_inline simd16<T> &operator-=(const simd16<T> other) {
+    *this = *this - other;
+    return *static_cast<simd16<T> *>(this);
+  }
+};
+
+// Signed code units
+template <> struct simd16<int16_t> : base16_numeric<int16_t> {
+  simdutf_really_inline simd16() : base16_numeric<int16_t>() {}
+  simdutf_really_inline simd16(const __m256i _value)
+      : base16_numeric<int16_t>(_value) {}
+  // Splat constructor
+  simdutf_really_inline simd16(int16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const int16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const int16_t *>(values))) {}
+  // Order-sensitive comparisons
+  simdutf_really_inline simd16<int16_t>
+  max_val(const simd16<int16_t> other) const {
+    return __lasx_xvmax_h(*this, other);
+  }
+  simdutf_really_inline simd16<int16_t>
+  min_val(const simd16<int16_t> other) const {
+    return __lasx_xvmin_h(*this, other);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<int16_t> other) const {
+    return __lasx_xvsle_h(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<int16_t> other) const {
+    return __lasx_xvslt_h(this->value, other.value);
+  }
+};
+
+// Unsigned code units
+template <> struct simd16<uint16_t> : base16_numeric<uint16_t> {
+  simdutf_really_inline simd16() : base16_numeric<uint16_t>() {}
+  simdutf_really_inline simd16(const __m256i _value)
+      : base16_numeric<uint16_t>(_value) {}
+
+  // Splat constructor
+  simdutf_really_inline simd16(uint16_t _value) : simd16(splat(_value)) {}
+  // Array constructor
+  simdutf_really_inline simd16(const uint16_t *values) : simd16(load(values)) {}
+  simdutf_really_inline simd16(const char16_t *values)
+      : simd16(load(reinterpret_cast<const uint16_t *>(values))) {}
+
+  // Saturated math
+  simdutf_really_inline simd16<uint16_t>
+  saturating_add(const simd16<uint16_t> other) const {
+    return __lasx_xvsadd_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  saturating_sub(const simd16<uint16_t> other) const {
+    return __lasx_xvssub_hu(this->value, other.value);
+  }
+
+  // Order-specific operations
+  simdutf_really_inline simd16<uint16_t>
+  max_val(const simd16<uint16_t> other) const {
+    return __lasx_xvmax_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<uint16_t>
+  min_val(const simd16<uint16_t> other) const {
+    return __lasx_xvmin_hu(this->value, other.value);
+  }
+  // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  gt_bits(const simd16<uint16_t> other) const {
+    return this->saturating_sub(other);
+  }
+  // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
+  simdutf_really_inline simd16<uint16_t>
+  lt_bits(const simd16<uint16_t> other) const {
+    return other.saturating_sub(*this);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<=(const simd16<uint16_t> other) const {
+    return __lasx_xvsle_hu(this->value, other.value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>=(const simd16<uint16_t> other) const {
+    return __lasx_xvsle_hu(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator>(const simd16<uint16_t> other) const {
+    return __lasx_xvslt_hu(other.value, this->value);
+  }
+  simdutf_really_inline simd16<bool>
+  operator<(const simd16<uint16_t> other) const {
+    return __lasx_xvslt_hu(this->value, other.value);
+  }
+
+  // Bit-specific operations
+  simdutf_really_inline simd16<bool> bits_not_set() const {
+    return *this == uint16_t(0);
+  }
+  simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const {
+    return (*this & bits).bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set() const {
+    return ~this->bits_not_set();
+  }
+  simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const {
+    return ~this->bits_not_set(bits);
+  }
+
+  simdutf_really_inline bool any_bits_set_anywhere() const {
+    if (__lasx_xbnz_v(this->value))
+      return true;
+    return false;
+  }
+  simdutf_really_inline bool
+  any_bits_set_anywhere(simd16<uint16_t> bits) const {
+    return (*this & bits).any_bits_set_anywhere();
+  }
+
+  template <int N> simdutf_really_inline simd16<uint16_t> shr() const {
+    return simd16<uint16_t>(__lasx_xvsrli_h(this->value, N));
+  }
+  template <int N> simdutf_really_inline simd16<uint16_t> shl() const {
+    return simd16<uint16_t>(__lasx_xvslli_h(this->value, N));
+  }
+
+  // Change the endianness
+  simdutf_really_inline simd16<uint16_t> swap_bytes() const {
+    return __lasx_xvshuf4i_b(this->value, 0b10110001);
+  }
+
+  // Pack with the unsigned saturation of two uint16_t code units into single
+  // uint8_t vector
+  static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t> &v0,
+                                                   const simd16<uint16_t> &v1) {
+    return __lasx_xvpermi_d(__lasx_xvssrlni_bu_h(v1.value, v0.value, 0),
+                            0b11011000);
+  }
+};
+
+template <typename T> struct simd16x32 {
+  static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
+  static_assert(NUM_CHUNKS == 2,
+                "LASX kernel should use two registers per 64-byte block.");
+  simd16<T> chunks[NUM_CHUNKS];
+
+  simd16x32(const simd16x32<T> &o) = delete; // no copy allowed
+  simd16x32<T> &
+  operator=(const simd16<T> other) = delete; // no assignment allowed
+  simd16x32() = delete;                      // no default constructor allowed
+
+  simdutf_really_inline simd16x32(const simd16<T> chunk0,
+                                  const simd16<T> chunk1)
+      : chunks{chunk0, chunk1} {}
+  simdutf_really_inline simd16x32(const T *ptr)
+      : chunks{simd16<T>::load(ptr),
+               simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T))} {}
+
+  simdutf_really_inline void store(T *ptr) const {
+    this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
+    this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
+  }
+
+  simdutf_really_inline uint64_t to_bitmask() const {
+    uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
+    uint64_t r_hi = this->chunks[1].to_bitmask();
+    return r_lo | (r_hi << 32);
+  }
+
+  simdutf_really_inline simd16<T> reduce_or() const {
+    return this->chunks[0] | this->chunks[1];
+  }
+
+  simdutf_really_inline bool is_ascii() const {
+    return this->reduce_or().is_ascii();
+  }
+
+  simdutf_really_inline void store_ascii_as_utf16(char16_t *ptr) const {
+    this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
+    this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
+  }
+
+  simdutf_really_inline simd16x32<T> bit_or(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
+  }
+
+  simdutf_really_inline void swap_bytes() {
+    this->chunks[0] = this->chunks[0].swap_bytes();
+    this->chunks[1] = this->chunks[1].swap_bytes();
+  }
+
+  simdutf_really_inline uint64_t eq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t eq(const simd16x32<uint16_t> &other) const {
+    return simd16x32<bool>(this->chunks[0] == other.chunks[0],
+                           this->chunks[1] == other.chunks[1])
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t lteq(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
+        .to_bitmask();
+  }
+
+  simdutf_really_inline uint64_t in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(low);
+    const simd16<T> mask_high = simd16<T>::splat(high);
+
+    return simd16x32<bool>(
+               (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
+               (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t not_in_range(const T low, const T high) const {
+    const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
+    const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
+    return simd16x32<bool>(
+               (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
+               (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
+        .to_bitmask();
+  }
+  simdutf_really_inline uint64_t lt(const T m) const {
+    const simd16<T> mask = simd16<T>::splat(m);
+    return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
+        .to_bitmask();
+  }
+}; // struct simd16x32<T>
+/* end file src/simdutf/lasx/simd16-inl.h */
+} // namespace simd
+} // unnamed namespace
+} // namespace lasx
+} // namespace simdutf
+
+#endif // SIMDUTF_LASX_SIMD_H
+/* end file src/simdutf/lasx/simd.h */
+
+/* begin file src/simdutf/lasx/end.h */
+/* end file src/simdutf/lasx/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_LASX
+
+#endif // SIMDUTF_LASX_H
+/* end file src/simdutf/lasx.h */
+/* begin file src/simdutf/fallback.h */
+#ifndef SIMDUTF_FALLBACK_H
+#define SIMDUTF_FALLBACK_H
+
+
+// Note that fallback.h is always imported last.
+
+// Default Fallback to on unless a builtin implementation has already been
+// selected.
+#ifndef SIMDUTF_IMPLEMENTATION_FALLBACK
+  #if SIMDUTF_CAN_ALWAYS_RUN_ARM64 || SIMDUTF_CAN_ALWAYS_RUN_ICELAKE ||        \
+      SIMDUTF_CAN_ALWAYS_RUN_HASWELL || SIMDUTF_CAN_ALWAYS_RUN_WESTMERE ||     \
+      SIMDUTF_CAN_ALWAYS_RUN_PPC64 || SIMDUTF_CAN_ALWAYS_RUN_RVV ||            \
+      SIMDUTF_CAN_ALWAYS_RUN_LSX || SIMDUTF_CAN_ALWAYS_RUN_LASX
+    #define SIMDUTF_IMPLEMENTATION_FALLBACK 0
+  #else
+    #define SIMDUTF_IMPLEMENTATION_FALLBACK 1
+  #endif
+#endif
+
+#define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)
+
+#if SIMDUTF_IMPLEMENTATION_FALLBACK
+
+namespace simdutf {
+/**
+ * Fallback implementation (runs on any machine).
+ */
+namespace fallback {} // namespace fallback
+} // namespace simdutf
+
+/* begin file src/simdutf/fallback/implementation.h */
+#ifndef SIMDUTF_FALLBACK_IMPLEMENTATION_H
+#define SIMDUTF_FALLBACK_IMPLEMENTATION_H
+
+
+namespace simdutf {
+namespace fallback {
+
+namespace {
+using namespace simdutf;
+}
+
+class implementation final : public simdutf::implementation {
+public:
+  simdutf_really_inline implementation()
+      : simdutf::implementation("fallback", "Generic fallback implementation",
+                                0) {}
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *input,
+                                           size_t length) const noexcept final;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *buf,
+                                         size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result
+  validate_utf8_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool validate_ascii(const char *buf,
+                                          size_t len) const noexcept final;
+  simdutf_warn_unused result
+  validate_ascii_with_errors(const char *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                            size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                            size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                          size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *buf, size_t len, char *utf8_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len, char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len, char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len, char16_t *utf16_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len, char16_t *utf16_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len, char32_t *utf32_output) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len, char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_latin1(const char16_t *buf, size_t len,
+                                  char *latin1_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *buf, size_t len, char *utf8_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final;
+  simdutf_warn_unused result
+  convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
+                                      char *latin1_output) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_latin1(const char32_t *buf, size_t len,
+                                char *latin1_output) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16le(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf16be(const char32_t *buf, size_t len,
+                           char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16le(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf16be(const char32_t *buf, size_t len,
+                                 char16_t *utf16_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf32(const char16_t *buf, size_t len,
+                           char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16le_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+  simdutf_warn_unused size_t
+  convert_valid_utf16be_to_utf32(const char16_t *buf, size_t len,
+                                 char32_t *utf32_buffer) const noexcept final;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t length,
+                               char16_t *output) const noexcept final;
+  simdutf_warn_unused size_t count_utf16le(const char16_t *buf,
+                                           size_t length) const noexcept;
+  simdutf_warn_unused size_t count_utf16be(const char16_t *buf,
+                                           size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *buf,
+                                        size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *input, size_t length) const noexcept;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *input, size_t length) const noexcept;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *input, size_t length, char *output,
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options =
+                       last_chunk_handling_options::loose) const noexcept;
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_options =
+          last_chunk_handling_options::loose) const noexcept;
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept;
+#endif // SIMDUTF_FEATURE_BASE64
+};
+} // namespace fallback
+} // namespace simdutf
+
+#endif // SIMDUTF_FALLBACK_IMPLEMENTATION_H
+/* end file src/simdutf/fallback/implementation.h */
+
+/* begin file src/simdutf/fallback/begin.h */
+// redefining SIMDUTF_IMPLEMENTATION to "fallback"
+// #define SIMDUTF_IMPLEMENTATION fallback
+/* end file src/simdutf/fallback/begin.h */
+
+  // Declarations
+/* begin file src/simdutf/fallback/bitmanipulation.h */
+#ifndef SIMDUTF_FALLBACK_BITMANIPULATION_H
+#define SIMDUTF_FALLBACK_BITMANIPULATION_H
+
+#include <limits>
+
+namespace simdutf {
+namespace fallback {
+namespace {} // unnamed namespace
+} // namespace fallback
+} // namespace simdutf
+
+#endif // SIMDUTF_FALLBACK_BITMANIPULATION_H
+/* end file src/simdutf/fallback/bitmanipulation.h */
+
+/* begin file src/simdutf/fallback/end.h */
+/* end file src/simdutf/fallback/end.h */
+
+#endif // SIMDUTF_IMPLEMENTATION_FALLBACK
+#endif // SIMDUTF_FALLBACK_H
+/* end file src/simdutf/fallback.h */
+
+// The scalar routines should be included once.
+/* begin file src/scalar/swap_bytes.h */
+#ifndef SIMDUTF_SWAP_BYTES_H
+#define SIMDUTF_SWAP_BYTES_H
+
+namespace simdutf {
+namespace scalar {
+
+inline simdutf_warn_unused uint16_t u16_swap_bytes(const uint16_t word) {
+  return uint16_t((word >> 8) | (word << 8));
+}
+
+inline simdutf_warn_unused uint32_t u32_swap_bytes(const uint32_t word) {
+  return ((word >> 24) & 0xff) |      // move byte 3 to byte 0
+         ((word << 8) & 0xff0000) |   // move byte 1 to byte 2
+         ((word >> 8) & 0xff00) |     // move byte 2 to byte 1
+         ((word << 24) & 0xff000000); // byte 0 to byte 3
+}
+
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/swap_bytes.h */
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/scalar/ascii.h */
+#ifndef SIMDUTF_ASCII_H
+#define SIMDUTF_ASCII_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace ascii {
+#if SIMDUTF_IMPLEMENTATION_FALLBACK
+// Only used by the fallback kernel.
+inline simdutf_warn_unused bool validate(const char *buf, size_t len) noexcept {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  uint64_t pos = 0;
+  // process in blocks of 16 bytes when possible
+  for (; pos + 16 <= len; pos += 16) {
+    uint64_t v1;
+    std::memcpy(&v1, data + pos, sizeof(uint64_t));
+    uint64_t v2;
+    std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+    uint64_t v{v1 | v2};
+    if ((v & 0x8080808080808080) != 0) {
+      return false;
+    }
+  }
+  // process the tail byte-by-byte
+  for (; pos < len; pos++) {
+    if (data[pos] >= 0b10000000) {
+      return false;
+    }
+  }
+  return true;
+}
+#endif
+
+inline simdutf_warn_unused result validate_with_errors(const char *buf,
+                                                       size_t len) noexcept {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  // process in blocks of 16 bytes when possible
+  for (; pos + 16 <= len; pos += 16) {
+    uint64_t v1;
+    std::memcpy(&v1, data + pos, sizeof(uint64_t));
+    uint64_t v2;
+    std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+    uint64_t v{v1 | v2};
+    if ((v & 0x8080808080808080) != 0) {
+      for (; pos < len; pos++) {
+        if (data[pos] >= 0b10000000) {
+          return result(error_code::TOO_LARGE, pos);
+        }
+      }
+    }
+  }
+  // process the tail byte-by-byte
+  for (; pos < len; pos++) {
+    if (data[pos] >= 0b10000000) {
+      return result(error_code::TOO_LARGE, pos);
+    }
+  }
+  return result(error_code::SUCCESS, pos);
+}
+
+} // namespace ascii
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/ascii.h */
+#endif // SIMDUTF_FEATURE_ASCII
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/scalar/utf8.h */
+#ifndef SIMDUTF_UTF8_H
+#define SIMDUTF_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8 {
+#if SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_RVV
+// only used by the fallback kernel.
+// credit: based on code from Google Fuchsia (Apache Licensed)
+inline simdutf_warn_unused bool validate(const char *buf, size_t len) noexcept {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  uint64_t pos = 0;
+  uint32_t code_point = 0;
+  while (pos < len) {
+    // check of the next 16 bytes are ascii.
+    uint64_t next_pos = pos + 16;
+    if (next_pos <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      std::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        pos = next_pos;
+        continue;
+      }
+    }
+    unsigned char byte = data[pos];
+
+    while (byte < 0b10000000) {
+      if (++pos == len) {
+        return true;
+      }
+      byte = data[pos];
+    }
+
+    if ((byte & 0b11100000) == 0b11000000) {
+      next_pos = pos + 2;
+      if (next_pos > len) {
+        return false;
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      // range check
+      code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if ((code_point < 0x80) || (0x7ff < code_point)) {
+        return false;
+      }
+    } else if ((byte & 0b11110000) == 0b11100000) {
+      next_pos = pos + 3;
+      if (next_pos > len) {
+        return false;
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      // range check
+      code_point = (byte & 0b00001111) << 12 |
+                   (data[pos + 1] & 0b00111111) << 6 |
+                   (data[pos + 2] & 0b00111111);
+      if ((code_point < 0x800) || (0xffff < code_point) ||
+          (0xd7ff < code_point && code_point < 0xe000)) {
+        return false;
+      }
+    } else if ((byte & 0b11111000) == 0b11110000) { // 0b11110000
+      next_pos = pos + 4;
+      if (next_pos > len) {
+        return false;
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return false;
+      }
+      // range check
+      code_point =
+          (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 |
+          (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff || 0x10ffff < code_point) {
+        return false;
+      }
+    } else {
+      // we may have a continuation
+      return false;
+    }
+    pos = next_pos;
+  }
+  return true;
+}
+#endif
+
+inline simdutf_warn_unused result validate_with_errors(const char *buf,
+                                                       size_t len) noexcept {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  uint32_t code_point = 0;
+  while (pos < len) {
+    // check of the next 16 bytes are ascii.
+    size_t next_pos = pos + 16;
+    if (next_pos <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      std::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        pos = next_pos;
+        continue;
+      }
+    }
+    unsigned char byte = data[pos];
+
+    while (byte < 0b10000000) {
+      if (++pos == len) {
+        return result(error_code::SUCCESS, len);
+      }
+      byte = data[pos];
+    }
+
+    if ((byte & 0b11100000) == 0b11000000) {
+      next_pos = pos + 2;
+      if (next_pos > len) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if ((code_point < 0x80) || (0x7ff < code_point)) {
+        return result(error_code::OVERLONG, pos);
+      }
+    } else if ((byte & 0b11110000) == 0b11100000) {
+      next_pos = pos + 3;
+      if (next_pos > len) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      code_point = (byte & 0b00001111) << 12 |
+                   (data[pos + 1] & 0b00111111) << 6 |
+                   (data[pos + 2] & 0b00111111);
+      if ((code_point < 0x800) || (0xffff < code_point)) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0xd7ff < code_point && code_point < 0xe000) {
+        return result(error_code::SURROGATE, pos);
+      }
+    } else if ((byte & 0b11111000) == 0b11110000) { // 0b11110000
+      next_pos = pos + 4;
+      if (next_pos > len) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      code_point =
+          (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 |
+          (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0x10ffff < code_point) {
+        return result(error_code::TOO_LARGE, pos);
+      }
+    } else {
+      // we either have too many continuation bytes or an invalid leading byte
+      if ((byte & 0b11000000) == 0b10000000) {
+        return result(error_code::TOO_LONG, pos);
+      } else {
+        return result(error_code::HEADER_BITS, pos);
+      }
+    }
+    pos = next_pos;
+  }
+  return result(error_code::SUCCESS, len);
+}
+
+// Finds the previous leading byte starting backward from buf and validates with
+// errors from there Used to pinpoint the location of an error when an invalid
+// chunk is detected We assume that the stream starts with a leading byte, and
+// to check that it is the case, we ask that you pass a pointer to the start of
+// the stream (start).
+inline simdutf_warn_unused result rewind_and_validate_with_errors(
+    const char *start, const char *buf, size_t len) noexcept {
+  // First check that we start with a leading byte
+  if ((*start & 0b11000000) == 0b10000000) {
+    return result(error_code::TOO_LONG, 0);
+  }
+  size_t extra_len{0};
+  // A leading byte cannot be further than 4 bytes away
+  for (int i = 0; i < 5; i++) {
+    unsigned char byte = *buf;
+    if ((byte & 0b11000000) != 0b10000000) {
+      break;
+    } else {
+      buf--;
+      extra_len++;
+    }
+  }
+
+  result res = validate_with_errors(buf, len + extra_len);
+  res.count -= extra_len;
+  return res;
+}
+
+inline size_t count_code_points(const char *buf, size_t len) {
+  const int8_t *p = reinterpret_cast<const int8_t *>(buf);
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    // -65 is 0b10111111, anything larger in two-complement's should start a new
+    // code point.
+    if (p[i] > -65) {
+      counter++;
+    }
+  }
+  return counter;
+}
+
+inline size_t utf16_length_from_utf8(const char *buf, size_t len) {
+  const int8_t *p = reinterpret_cast<const int8_t *>(buf);
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    if (p[i] > -65) {
+      counter++;
+    }
+    if (uint8_t(p[i]) >= 240) {
+      counter++;
+    }
+  }
+  return counter;
+}
+
+simdutf_warn_unused inline size_t trim_partial_utf8(const char *input,
+                                                    size_t length) {
+  if (length < 3) {
+    switch (length) {
+    case 2:
+      if (uint8_t(input[length - 1]) >= 0xc0) {
+        return length - 1;
+      } // 2-, 3- and 4-byte characters with only 1 byte left
+      if (uint8_t(input[length - 2]) >= 0xe0) {
+        return length - 2;
+      } // 3- and 4-byte characters with only 2 bytes left
+      return length;
+    case 1:
+      if (uint8_t(input[length - 1]) >= 0xc0) {
+        return length - 1;
+      } // 2-, 3- and 4-byte characters with only 1 byte left
+      return length;
+    case 0:
+      return length;
+    }
+  }
+  if (uint8_t(input[length - 1]) >= 0xc0) {
+    return length - 1;
+  } // 2-, 3- and 4-byte characters with only 1 byte left
+  if (uint8_t(input[length - 2]) >= 0xe0) {
+    return length - 2;
+  } // 3- and 4-byte characters with only 1 byte left
+  if (uint8_t(input[length - 3]) >= 0xf0) {
+    return length - 3;
+  } // 4-byte characters with only 3 bytes left
+  return length;
+}
+
+} // namespace utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    (SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1)
+/* begin file src/scalar/utf16.h */
+#ifndef SIMDUTF_UTF16_H
+#define SIMDUTF_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16 {
+
+template <endianness big_endian>
+inline simdutf_warn_unused bool validate(const char16_t *data,
+                                         size_t len) noexcept {
+  uint64_t pos = 0;
+  while (pos < len) {
+    char16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xF800) == 0xD800) {
+      if (pos + 1 >= len) {
+        return false;
+      }
+      char16_t diff = char16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return false;
+      }
+      char16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      char16_t diff2 = char16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return false;
+      }
+      pos += 2;
+    } else {
+      pos++;
+    }
+  }
+  return true;
+}
+
+template <endianness big_endian>
+inline simdutf_warn_unused result validate_with_errors(const char16_t *data,
+                                                       size_t len) noexcept {
+  size_t pos = 0;
+  while (pos < len) {
+    char16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xF800) == 0xD800) {
+      if (pos + 1 >= len) {
+        return result(error_code::SURROGATE, pos);
+      }
+      char16_t diff = char16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      char16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      char16_t diff2 = uint16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      pos += 2;
+    } else {
+      pos++;
+    }
+  }
+  return result(error_code::SUCCESS, pos);
+}
+
+template <endianness big_endian>
+inline size_t count_code_points(const char16_t *p, size_t len) {
+  // We are not BOM aware.
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    char16_t word = !match_system(big_endian) ? u16_swap_bytes(p[i]) : p[i];
+    counter += ((word & 0xFC00) != 0xDC00);
+  }
+  return counter;
+}
+
+template <endianness big_endian>
+inline size_t utf8_length_from_utf16(const char16_t *p, size_t len) {
+  // We are not BOM aware.
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    char16_t word = !match_system(big_endian) ? u16_swap_bytes(p[i]) : p[i];
+    counter++; // ASCII
+    counter += static_cast<size_t>(
+        word >
+        0x7F); // non-ASCII is at least 2 bytes, surrogates are 2*2 == 4 bytes
+    counter += static_cast<size_t>((word > 0x7FF && word <= 0xD7FF) ||
+                                   (word >= 0xE000)); // three-byte
+  }
+  return counter;
+}
+
+template <endianness big_endian>
+inline size_t utf32_length_from_utf16(const char16_t *p, size_t len) {
+  // We are not BOM aware.
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    char16_t word = !match_system(big_endian) ? u16_swap_bytes(p[i]) : p[i];
+    counter += ((word & 0xFC00) != 0xDC00);
+  }
+  return counter;
+}
+
+simdutf_really_inline void
+change_endianness_utf16(const char16_t *input, size_t size, char16_t *output) {
+  for (size_t i = 0; i < size; i++) {
+    *output++ = char16_t(input[i] >> 8 | input[i] << 8);
+  }
+}
+
+template <endianness big_endian>
+simdutf_warn_unused inline size_t trim_partial_utf16(const char16_t *input,
+                                                     size_t length) {
+  if (length <= 1) {
+    return length;
+  }
+  uint16_t last_word = uint16_t(input[length - 1]);
+  last_word = !match_system(big_endian) ? u16_swap_bytes(last_word) : last_word;
+  length -= ((last_word & 0xFC00) == 0xD800);
+  return length;
+}
+
+} // namespace utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // (SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1)
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/scalar/utf32.h */
+#ifndef SIMDUTF_UTF32_H
+#define SIMDUTF_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32 {
+
+inline simdutf_warn_unused bool validate(const char32_t *buf,
+                                         size_t len) noexcept {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  uint64_t pos = 0;
+  for (; pos < len; pos++) {
+    uint32_t word = data[pos];
+    if (word > 0x10FFFF || (word >= 0xD800 && word <= 0xDFFF)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+inline simdutf_warn_unused result validate_with_errors(const char32_t *buf,
+                                                       size_t len) noexcept {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  for (; pos < len; pos++) {
+    uint32_t word = data[pos];
+    if (word > 0x10FFFF) {
+      return result(error_code::TOO_LARGE, pos);
+    }
+    if (word >= 0xD800 && word <= 0xDFFF) {
+      return result(error_code::SURROGATE, pos);
+    }
+  }
+  return result(error_code::SUCCESS, pos);
+}
+
+inline size_t utf8_length_from_utf32(const char32_t *buf, size_t len) {
+  // We are not BOM aware.
+  const uint32_t *p = reinterpret_cast<const uint32_t *>(buf);
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    // credit: @ttsugriy  for the vectorizable approach
+    counter++;                                     // ASCII
+    counter += static_cast<size_t>(p[i] > 0x7F);   // two-byte
+    counter += static_cast<size_t>(p[i] > 0x7FF);  // three-byte
+    counter += static_cast<size_t>(p[i] > 0xFFFF); // four-bytes
+  }
+  return counter;
+}
+
+inline size_t utf16_length_from_utf32(const char32_t *buf, size_t len) {
+  // We are not BOM aware.
+  const uint32_t *p = reinterpret_cast<const uint32_t *>(buf);
+  size_t counter{0};
+  for (size_t i = 0; i < len; i++) {
+    counter++;                                     // non-surrogate word
+    counter += static_cast<size_t>(p[i] > 0xFFFF); // surrogate pair
+  }
+  return counter;
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32.h */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/latin1.h */
+#ifndef SIMDUTF_LATIN1_H
+#define SIMDUTF_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace latin1 {
+
+inline size_t utf8_length_from_latin1(const char *buf, size_t len) {
+  const uint8_t *c = reinterpret_cast<const uint8_t *>(buf);
+  size_t answer = 0;
+  for (size_t i = 0; i < len; i++) {
+    if ((c[i] >> 7)) {
+      answer++;
+    }
+  }
+  return answer + len;
+}
+
+} // namespace latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/latin1.h */
+#endif // SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_BASE64
+/* begin file src/scalar/base64.h */
+#ifndef SIMDUTF_BASE64_H
+#define SIMDUTF_BASE64_H
+
+#include <cstddef>
+#include <cstdint>
+#include <cstring>
+#include <iostream>
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace base64 {
+
+// This function is not expected to be fast. Do not use in long loops.
+template <class char_type> bool is_ascii_white_space(char_type c) {
+  return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f';
+}
+
+template <class char_type> bool is_ascii_white_space_or_padding(char_type c) {
+  return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' ||
+         c == '=';
+}
+
+template <class char_type> bool is_eight_byte(char_type c) {
+  if (sizeof(char_type) == 1) {
+    return true;
+  }
+  return uint8_t(c) == c;
+}
+
+// Returns true upon success. The destination buffer must be large enough.
+// This functions assumes that the padding (=) has been removed.
+template <class char_type>
+full_result
+base64_tail_decode(char *dst, const char_type *src, size_t length,
+                   size_t padded_characters, // number of padding characters
+                                             // '=', typically 0, 1, 2.
+                   base64_options options,
+                   last_chunk_handling_options last_chunk_options) {
+  // This looks like 5 branches, but we expect the compiler to resolve this to a
+  // single branch:
+  const uint8_t *to_base64 = (options & base64_url)
+                                 ? tables::base64::to_base64_url_value
+                                 : tables::base64::to_base64_value;
+  const uint32_t *d0 = (options & base64_url)
+                           ? tables::base64::base64_url::d0
+                           : tables::base64::base64_default::d0;
+  const uint32_t *d1 = (options & base64_url)
+                           ? tables::base64::base64_url::d1
+                           : tables::base64::base64_default::d1;
+  const uint32_t *d2 = (options & base64_url)
+                           ? tables::base64::base64_url::d2
+                           : tables::base64::base64_default::d2;
+  const uint32_t *d3 = (options & base64_url)
+                           ? tables::base64::base64_url::d3
+                           : tables::base64::base64_default::d3;
+
+  const char_type *srcend = src + length;
+  const char_type *srcinit = src;
+  const char *dstinit = dst;
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
+
+  uint32_t x;
+  size_t idx;
+  uint8_t buffer[4];
+  while (true) {
+    while (src + 4 <= srcend && is_eight_byte(src[0]) &&
+           is_eight_byte(src[1]) && is_eight_byte(src[2]) &&
+           is_eight_byte(src[3]) &&
+           (x = d0[uint8_t(src[0])] | d1[uint8_t(src[1])] |
+                d2[uint8_t(src[2])] | d3[uint8_t(src[3])]) < 0x01FFFFFF) {
+      if (match_system(endianness::BIG)) {
+        x = scalar::u32_swap_bytes(x);
+      }
+      std::memcpy(dst, &x, 3); // optimization opportunity: copy 4 bytes
+      dst += 3;
+      src += 4;
+    }
+    idx = 0;
+    // we need at least four characters.
+#ifdef __clang__
+    // If possible, we read four characters at a time. (It is an optimization.)
+    if (ignore_garbage && src + 4 <= srcend) {
+      char_type c0 = src[0];
+      char_type c1 = src[1];
+      char_type c2 = src[2];
+      char_type c3 = src[3];
+      uint8_t code0 = to_base64[uint8_t(c0)];
+      uint8_t code1 = to_base64[uint8_t(c1)];
+      uint8_t code2 = to_base64[uint8_t(c2)];
+      uint8_t code3 = to_base64[uint8_t(c3)];
+      buffer[idx] = code0;
+      idx += (is_eight_byte(c0) && code0 <= 63);
+      buffer[idx] = code1;
+      idx += (is_eight_byte(c1) && code1 <= 63);
+      buffer[idx] = code2;
+      idx += (is_eight_byte(c2) && code2 <= 63);
+      buffer[idx] = code3;
+      idx += (is_eight_byte(c3) && code3 <= 63);
+      src += 4;
+    }
+#endif
+    while ((idx < 4) && (src < srcend)) {
+      char_type c = *src;
+      uint8_t code = to_base64[uint8_t(c)];
+      buffer[idx] = uint8_t(code);
+      if (is_eight_byte(c) && code <= 63) {
+        idx++;
+      } else if (!ignore_garbage &&
+                 (code > 64 || !scalar::base64::is_eight_byte(c))) {
+        return {INVALID_BASE64_CHARACTER, size_t(src - srcinit),
+                size_t(dst - dstinit)};
+      } else {
+        // We have a space or a newline or garbage. We ignore it.
+      }
+      src++;
+    }
+    if (idx != 4) {
+      if (!ignore_garbage &&
+          last_chunk_options == last_chunk_handling_options::strict &&
+          (idx != 1) && ((idx + padded_characters) & 3) != 0) {
+        // The partial chunk was at src - idx
+        return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
+                size_t(dst - dstinit)};
+      } else if (!ignore_garbage &&
+                 last_chunk_options ==
+                     last_chunk_handling_options::stop_before_partial &&
+                 (idx != 1) && ((idx + padded_characters) & 3) != 0) {
+        // Rewind src to before partial chunk
+        src -= idx;
+        return {SUCCESS, size_t(src - srcinit), size_t(dst - dstinit)};
+      } else {
+        if (idx == 2) {
+          uint32_t triple =
+              (uint32_t(buffer[0]) << 3 * 6) + (uint32_t(buffer[1]) << 2 * 6);
+          if (!ignore_garbage &&
+              (last_chunk_options == last_chunk_handling_options::strict) &&
+              (triple & 0xffff)) {
+            return {BASE64_EXTRA_BITS, size_t(src - srcinit),
+                    size_t(dst - dstinit)};
+          }
+          if (match_system(endianness::BIG)) {
+            triple <<= 8;
+            std::memcpy(dst, &triple, 1);
+          } else {
+            triple = scalar::u32_swap_bytes(triple);
+            triple >>= 8;
+            std::memcpy(dst, &triple, 1);
+          }
+          dst += 1;
+        } else if (idx == 3) {
+          uint32_t triple = (uint32_t(buffer[0]) << 3 * 6) +
+                            (uint32_t(buffer[1]) << 2 * 6) +
+                            (uint32_t(buffer[2]) << 1 * 6);
+          if (!ignore_garbage &&
+              (last_chunk_options == last_chunk_handling_options::strict) &&
+              (triple & 0xff)) {
+            return {BASE64_EXTRA_BITS, size_t(src - srcinit),
+                    size_t(dst - dstinit)};
+          }
+          if (match_system(endianness::BIG)) {
+            triple <<= 8;
+            std::memcpy(dst, &triple, 2);
+          } else {
+            triple = scalar::u32_swap_bytes(triple);
+            triple >>= 8;
+            std::memcpy(dst, &triple, 2);
+          }
+          dst += 2;
+        } else if (!ignore_garbage && idx == 1) {
+          return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
+                  size_t(dst - dstinit)};
+        }
+        return {SUCCESS, size_t(src - srcinit), size_t(dst - dstinit)};
+      }
+    }
+
+    uint32_t triple =
+        (uint32_t(buffer[0]) << 3 * 6) + (uint32_t(buffer[1]) << 2 * 6) +
+        (uint32_t(buffer[2]) << 1 * 6) + (uint32_t(buffer[3]) << 0 * 6);
+    if (match_system(endianness::BIG)) {
+      triple <<= 8;
+      std::memcpy(dst, &triple, 3);
+    } else {
+      triple = scalar::u32_swap_bytes(triple);
+      triple >>= 8;
+      std::memcpy(dst, &triple, 3);
+    }
+    dst += 3;
+  }
+}
+
+// like base64_tail_decode, but it will not write past the end of the output
+// buffer. The outlen paramter is modified to reflect the number of bytes
+// written. This functions assumes that the padding (=) has been removed.
+template <class char_type>
+result base64_tail_decode_safe(
+    char *dst, size_t &outlen, const char_type *&srcr, size_t length,
+    size_t padded_characters, // number of padding characters '=', typically 0,
+                              // 1, 2.
+    base64_options options, last_chunk_handling_options last_chunk_options) {
+  const char_type *src = srcr;
+  if (length == 0) {
+    outlen = 0;
+    return {SUCCESS, 0};
+  }
+  // This looks like 5 branches, but we expect the compiler to resolve this to a
+  // single branch:
+  const uint8_t *to_base64 = (options & base64_url)
+                                 ? tables::base64::to_base64_url_value
+                                 : tables::base64::to_base64_value;
+  const uint32_t *d0 = (options & base64_url)
+                           ? tables::base64::base64_url::d0
+                           : tables::base64::base64_default::d0;
+  const uint32_t *d1 = (options & base64_url)
+                           ? tables::base64::base64_url::d1
+                           : tables::base64::base64_default::d1;
+  const uint32_t *d2 = (options & base64_url)
+                           ? tables::base64::base64_url::d2
+                           : tables::base64::base64_default::d2;
+  const uint32_t *d3 = (options & base64_url)
+                           ? tables::base64::base64_url::d3
+                           : tables::base64::base64_default::d3;
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
+
+  const char_type *srcend = src + length;
+  const char_type *srcinit = src;
+  const char *dstinit = dst;
+  const char *dstend = dst + outlen;
+
+  uint32_t x;
+  size_t idx;
+  uint8_t buffer[4];
+  while (true) {
+    while (src + 4 <= srcend && is_eight_byte(src[0]) &&
+           is_eight_byte(src[1]) && is_eight_byte(src[2]) &&
+           is_eight_byte(src[3]) &&
+           (x = d0[uint8_t(src[0])] | d1[uint8_t(src[1])] |
+                d2[uint8_t(src[2])] | d3[uint8_t(src[3])]) < 0x01FFFFFF) {
+      if (dstend - dst < 3) {
+        outlen = size_t(dst - dstinit);
+        srcr = src;
+        return {OUTPUT_BUFFER_TOO_SMALL, size_t(src - srcinit)};
+      }
+      if (match_system(endianness::BIG)) {
+        x = scalar::u32_swap_bytes(x);
+      }
+      std::memcpy(dst, &x, 3); // optimization opportunity: copy 4 bytes
+      dst += 3;
+      src += 4;
+    }
+    idx = 0;
+    const char_type *srccur = src;
+    // We need at least four characters.
+#ifdef __clang__
+    // If possible, we read four characters at a time. (It is an optimization.)
+    if (ignore_garbage && src + 4 <= srcend) {
+      char_type c0 = src[0];
+      char_type c1 = src[1];
+      char_type c2 = src[2];
+      char_type c3 = src[3];
+      uint8_t code0 = to_base64[uint8_t(c0)];
+      uint8_t code1 = to_base64[uint8_t(c1)];
+      uint8_t code2 = to_base64[uint8_t(c2)];
+      uint8_t code3 = to_base64[uint8_t(c3)];
+      buffer[idx] = code0;
+      idx += (is_eight_byte(c0) && code0 <= 63);
+      buffer[idx] = code1;
+      idx += (is_eight_byte(c1) && code1 <= 63);
+      buffer[idx] = code2;
+      idx += (is_eight_byte(c2) && code2 <= 63);
+      buffer[idx] = code3;
+      idx += (is_eight_byte(c3) && code3 <= 63);
+      src += 4;
+    }
+#endif
+    while (idx < 4 && src < srcend) {
+      char_type c = *src;
+      uint8_t code = to_base64[uint8_t(c)];
+
+      buffer[idx] = uint8_t(code);
+      if (is_eight_byte(c) && code <= 63) {
+        idx++;
+      } else if (!ignore_garbage &&
+                 (code > 64 || !scalar::base64::is_eight_byte(c))) {
+        outlen = size_t(dst - dstinit);
+        srcr = src;
+        return {INVALID_BASE64_CHARACTER, size_t(src - srcinit)};
+      } else {
+        // We have a space or a newline or garbage. We ignore it.
+      }
+      src++;
+    }
+    if (idx != 4) {
+      if (!ignore_garbage &&
+          last_chunk_options == last_chunk_handling_options::strict &&
+          ((idx + padded_characters) & 3) != 0) {
+        outlen = size_t(dst - dstinit);
+        srcr = src;
+        return {BASE64_INPUT_REMAINDER, size_t(src - srcinit)};
+      } else if (!ignore_garbage &&
+                 last_chunk_options ==
+                     last_chunk_handling_options::stop_before_partial &&
+                 ((idx + padded_characters) & 3) != 0) {
+        // Rewind src to before partial chunk
+        srcr = srccur;
+        outlen = size_t(dst - dstinit);
+        return {SUCCESS, size_t(dst - dstinit)};
+      } else { // loose mode
+        if (idx == 0) {
+          // No data left; return success
+          outlen = size_t(dst - dstinit);
+          srcr = src;
+          return {SUCCESS, size_t(dst - dstinit)};
+        } else if (!ignore_garbage && idx == 1) {
+          // Error: Incomplete chunk of length 1 is invalid in loose mode
+          outlen = size_t(dst - dstinit);
+          srcr = src;
+          return {BASE64_INPUT_REMAINDER, size_t(src - srcinit)};
+        } else if (idx == 2 || idx == 3) {
+          // Check if there's enough space in the destination buffer
+          size_t required_space = (idx == 2) ? 1 : 2;
+          if (size_t(dstend - dst) < required_space) {
+            outlen = size_t(dst - dstinit);
+            srcr = src;
+            return {OUTPUT_BUFFER_TOO_SMALL, size_t(srccur - srcinit)};
+          }
+          uint32_t triple = 0;
+          if (idx == 2) {
+            triple = (uint32_t(buffer[0]) << 18) + (uint32_t(buffer[1]) << 12);
+            if (!ignore_garbage &&
+                (last_chunk_options == last_chunk_handling_options::strict) &&
+                (triple & 0xffff)) {
+              srcr = src;
+              return {BASE64_EXTRA_BITS, size_t(src - srcinit)};
+            }
+            // Extract the first byte
+            triple >>= 16;
+            dst[0] = static_cast<char>(triple & 0xFF);
+            dst += 1;
+          } else if (idx == 3) {
+            triple = (uint32_t(buffer[0]) << 18) + (uint32_t(buffer[1]) << 12) +
+                     (uint32_t(buffer[2]) << 6);
+            if (!ignore_garbage &&
+                (last_chunk_options == last_chunk_handling_options::strict) &&
+                (triple & 0xff)) {
+              srcr = src;
+              return {BASE64_EXTRA_BITS, size_t(src - srcinit)};
+            }
+            // Extract the first two bytes
+            triple >>= 8;
+            dst[0] = static_cast<char>((triple >> 8) & 0xFF);
+            dst[1] = static_cast<char>(triple & 0xFF);
+            dst += 2;
+          }
+          outlen = size_t(dst - dstinit);
+          srcr = src;
+          return {SUCCESS, size_t(dst - dstinit)};
+        }
+      }
+    }
+
+    if (dstend - dst < 3) {
+      outlen = size_t(dst - dstinit);
+      srcr = src;
+      return {OUTPUT_BUFFER_TOO_SMALL, size_t(srccur - srcinit)};
+    }
+    uint32_t triple = (uint32_t(buffer[0]) << 18) +
+                      (uint32_t(buffer[1]) << 12) + (uint32_t(buffer[2]) << 6) +
+                      (uint32_t(buffer[3]));
+    if (match_system(endianness::BIG)) {
+      triple <<= 8;
+      std::memcpy(dst, &triple, 3);
+    } else {
+      triple = scalar::u32_swap_bytes(triple);
+      triple >>= 8;
+      std::memcpy(dst, &triple, 3);
+    }
+    dst += 3;
+  }
+}
+
+// Returns the number of bytes written. The destination buffer must be large
+// enough. It will add padding (=) if needed.
+size_t tail_encode_base64(char *dst, const char *src, size_t srclen,
+                          base64_options options) {
+  // By default, we use padding if we are not using the URL variant.
+  // This is check with ((options & base64_url) == 0) which returns true if we
+  // are not using the URL variant. However, we also allow 'inversion' of the
+  // convention with the base64_reverse_padding option. If the
+  // base64_reverse_padding option is set, we use padding if we are using the
+  // URL variant, and we omit it if we are not using the URL variant. This is
+  // checked with
+  // ((options & base64_reverse_padding) == base64_reverse_padding).
+  bool use_padding =
+      ((options & base64_url) == 0) ^
+      ((options & base64_reverse_padding) == base64_reverse_padding);
+  // This looks like 3 branches, but we expect the compiler to resolve this to
+  // a single branch:
+  const char *e0 = (options & base64_url) ? tables::base64::base64_url::e0
+                                          : tables::base64::base64_default::e0;
+  const char *e1 = (options & base64_url) ? tables::base64::base64_url::e1
+                                          : tables::base64::base64_default::e1;
+  const char *e2 = (options & base64_url) ? tables::base64::base64_url::e2
+                                          : tables::base64::base64_default::e2;
+  char *out = dst;
+  size_t i = 0;
+  uint8_t t1, t2, t3;
+  for (; i + 2 < srclen; i += 3) {
+    t1 = uint8_t(src[i]);
+    t2 = uint8_t(src[i + 1]);
+    t3 = uint8_t(src[i + 2]);
+    *out++ = e0[t1];
+    *out++ = e1[((t1 & 0x03) << 4) | ((t2 >> 4) & 0x0F)];
+    *out++ = e1[((t2 & 0x0F) << 2) | ((t3 >> 6) & 0x03)];
+    *out++ = e2[t3];
+  }
+  switch (srclen - i) {
+  case 0:
+    break;
+  case 1:
+    t1 = uint8_t(src[i]);
+    *out++ = e0[t1];
+    *out++ = e1[(t1 & 0x03) << 4];
+    if (use_padding) {
+      *out++ = '=';
+      *out++ = '=';
+    }
+    break;
+  default: /* case 2 */
+    t1 = uint8_t(src[i]);
+    t2 = uint8_t(src[i + 1]);
+    *out++ = e0[t1];
+    *out++ = e1[((t1 & 0x03) << 4) | ((t2 >> 4) & 0x0F)];
+    *out++ = e2[(t2 & 0x0F) << 2];
+    if (use_padding) {
+      *out++ = '=';
+    }
+  }
+  return (size_t)(out - dst);
+}
+
+template <class char_type>
+simdutf_warn_unused size_t maximal_binary_length_from_base64(
+    const char_type *input, size_t length) noexcept {
+  // We follow https://infra.spec.whatwg.org/#forgiving-base64-decode
+  size_t padding = 0;
+  if (length > 0) {
+    if (input[length - 1] == '=') {
+      padding++;
+      if (length > 1 && input[length - 2] == '=') {
+        padding++;
+      }
+    }
+  }
+  size_t actual_length = length - padding;
+  if (actual_length % 4 <= 1) {
+    return actual_length / 4 * 3;
+  }
+  // if we have a valid input, then the remainder must be 2 or 3 adding one or
+  // two extra bytes.
+  return actual_length / 4 * 3 + (actual_length % 4) - 1;
+}
+
+simdutf_warn_unused size_t
+base64_length_from_binary(size_t length, base64_options options) noexcept {
+  // By default, we use padding if we are not using the URL variant.
+  // This is check with ((options & base64_url) == 0) which returns true if we
+  // are not using the URL variant. However, we also allow 'inversion' of the
+  // convention with the base64_reverse_padding option. If the
+  // base64_reverse_padding option is set, we use padding if we are using the
+  // URL variant, and we omit it if we are not using the URL variant. This is
+  // checked with
+  // ((options & base64_reverse_padding) == base64_reverse_padding).
+  bool use_padding =
+      ((options & base64_url) == 0) ^
+      ((options & base64_reverse_padding) == base64_reverse_padding);
+  if (!use_padding) {
+    return length / 3 * 4 + ((length % 3) ? (length % 3) + 1 : 0);
+  }
+  return (length + 2) / 3 *
+         4; // We use padding to make the length a multiple of 4.
+}
+
+} // namespace base64
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/base64.h */
+#endif // SIMDUTF_FEATURE_BASE64
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+/* begin file src/scalar/utf32_to_utf8/valid_utf32_to_utf8.h */
+#ifndef SIMDUTF_VALID_UTF32_TO_UTF8_H
+#define SIMDUTF_VALID_UTF32_TO_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32_to_utf8 {
+
+#if SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_PPC64
+// only used by the fallback and POWER kernel
+inline size_t convert_valid(const char32_t *buf, size_t len,
+                            char *utf8_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 2 ASCII characters
+    if (pos + 2 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
+        *utf8_output++ = char(buf[pos]);
+        *utf8_output++ = char(buf[pos + 1]);
+        pos += 2;
+        continue;
+      }
+    }
+    uint32_t word = data[pos];
+    if ((word & 0xFFFFFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xFFFFF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xFFFF0000) == 0) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 18) | 0b11110000);
+      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    }
+  }
+  return utf8_output - start;
+}
+#endif // SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_PPC64
+
+} // namespace utf32_to_utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_utf8/valid_utf32_to_utf8.h */
+/* begin file src/scalar/utf32_to_utf8/utf32_to_utf8.h */
+#ifndef SIMDUTF_UTF32_TO_UTF8_H
+#define SIMDUTF_UTF32_TO_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32_to_utf8 {
+
+inline size_t convert(const char32_t *buf, size_t len, char *utf8_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 2 ASCII characters
+    if (pos + 2 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
+        *utf8_output++ = char(buf[pos]);
+        *utf8_output++ = char(buf[pos + 1]);
+        pos += 2;
+        continue;
+      }
+    }
+    uint32_t word = data[pos];
+    if ((word & 0xFFFFFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xFFFFF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xFFFF0000) == 0) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      if (word >= 0xD800 && word <= 0xDFFF) {
+        return 0;
+      }
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      if (word > 0x10FFFF) {
+        return 0;
+      }
+      *utf8_output++ = char((word >> 18) | 0b11110000);
+      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    }
+  }
+  return utf8_output - start;
+}
+
+inline result convert_with_errors(const char32_t *buf, size_t len,
+                                  char *utf8_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 2 ASCII characters
+    if (pos + 2 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
+        *utf8_output++ = char(buf[pos]);
+        *utf8_output++ = char(buf[pos + 1]);
+        pos += 2;
+        continue;
+      }
+    }
+    uint32_t word = data[pos];
+    if ((word & 0xFFFFFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xFFFFF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xFFFF0000) == 0) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      if (word >= 0xD800 && word <= 0xDFFF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      if (word > 0x10FFFF) {
+        return result(error_code::TOO_LARGE, pos);
+      }
+      *utf8_output++ = char((word >> 18) | 0b11110000);
+      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    }
+  }
+  return result(error_code::SUCCESS, utf8_output - start);
+}
+
+} // namespace utf32_to_utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_utf8/utf32_to_utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+/* begin file src/scalar/utf32_to_utf16/valid_utf32_to_utf16.h */
+#ifndef SIMDUTF_VALID_UTF32_TO_UTF16_H
+#define SIMDUTF_VALID_UTF32_TO_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32_to_utf16 {
+
+template <endianness big_endian>
+inline size_t convert_valid(const char32_t *buf, size_t len,
+                            char16_t *utf16_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    uint32_t word = data[pos];
+    if ((word & 0xFFFF0000) == 0) {
+      // will not generate a surrogate pair
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(uint16_t(word)))
+                            : char16_t(word);
+      pos++;
+    } else {
+      // will generate a surrogate pair
+      word -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+      pos++;
+    }
+  }
+  return utf16_output - start;
+}
+
+} // namespace utf32_to_utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_utf16/valid_utf32_to_utf16.h */
+/* begin file src/scalar/utf32_to_utf16/utf32_to_utf16.h */
+#ifndef SIMDUTF_UTF32_TO_UTF16_H
+#define SIMDUTF_UTF32_TO_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32_to_utf16 {
+
+template <endianness big_endian>
+inline size_t convert(const char32_t *buf, size_t len, char16_t *utf16_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    uint32_t word = data[pos];
+    if ((word & 0xFFFF0000) == 0) {
+      if (word >= 0xD800 && word <= 0xDFFF) {
+        return 0;
+      }
+      // will not generate a surrogate pair
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(uint16_t(word)))
+                            : char16_t(word);
+    } else {
+      // will generate a surrogate pair
+      if (word > 0x10FFFF) {
+        return 0;
+      }
+      word -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+    }
+    pos++;
+  }
+  return utf16_output - start;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char32_t *buf, size_t len,
+                                  char16_t *utf16_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    uint32_t word = data[pos];
+    if ((word & 0xFFFF0000) == 0) {
+      if (word >= 0xD800 && word <= 0xDFFF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      // will not generate a surrogate pair
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(uint16_t(word)))
+                            : char16_t(word);
+    } else {
+      // will generate a surrogate pair
+      if (word > 0x10FFFF) {
+        return result(error_code::TOO_LARGE, pos);
+      }
+      word -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+    }
+    pos++;
+  }
+  return result(error_code::SUCCESS, utf16_output - start);
+}
+
+} // namespace utf32_to_utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_utf16/utf32_to_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+/* begin file src/scalar/utf16_to_utf8/valid_utf16_to_utf8.h */
+#ifndef SIMDUTF_VALID_UTF16_TO_UTF8_H
+#define SIMDUTF_VALID_UTF16_TO_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_utf8 {
+
+template <endianness big_endian>
+inline size_t convert_valid(const char16_t *buf, size_t len,
+                            char *utf8_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 4 ASCII characters
+    if (pos + 4 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if (!match_system(big_endian)) {
+        v = (v >> 8) | (v << (64 - 8));
+      }
+      if ((v & 0xFF80FF80FF80FF80) == 0) {
+        size_t final_pos = pos + 4;
+        while (pos < final_pos) {
+          *utf8_output++ = !match_system(big_endian)
+                               ? char(u16_swap_bytes(buf[pos]))
+                               : char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xF800) != 0xD800) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((value >> 18) | 0b11110000);
+      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((value & 0b111111) | 0b10000000);
+      pos += 2;
+    }
+  }
+  return utf8_output - start;
+}
+
+} // namespace utf16_to_utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16_to_utf8/valid_utf16_to_utf8.h */
+/* begin file src/scalar/utf16_to_utf8/utf16_to_utf8.h */
+#ifndef SIMDUTF_UTF16_TO_UTF8_H
+#define SIMDUTF_UTF16_TO_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_utf8 {
+
+template <endianness big_endian>
+inline size_t convert(const char16_t *buf, size_t len, char *utf8_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 8 bytes
+    if (pos + 4 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if (!match_system(big_endian)) {
+        v = (v >> 8) | (v << (64 - 8));
+      }
+      if ((v & 0xFF80FF80FF80FF80) == 0) {
+        size_t final_pos = pos + 4;
+        while (pos < final_pos) {
+          *utf8_output++ = !match_system(big_endian)
+                               ? char(u16_swap_bytes(buf[pos]))
+                               : char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xF800) != 0xD800) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      if (pos + 1 >= len) {
+        return 0;
+      }
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return 0;
+      }
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return 0;
+      }
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((value >> 18) | 0b11110000);
+      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((value & 0b111111) | 0b10000000);
+      pos += 2;
+    }
+  }
+  return utf8_output - start;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char16_t *buf, size_t len,
+                                  char *utf8_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *start{utf8_output};
+  while (pos < len) {
+    // try to convert the next block of 8 bytes
+    if (pos + 4 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if (!match_system(big_endian))
+        v = (v >> 8) | (v << (64 - 8));
+      if ((v & 0xFF80FF80FF80FF80) == 0) {
+        size_t final_pos = pos + 4;
+        while (pos < final_pos) {
+          *utf8_output++ = !match_system(big_endian)
+                               ? char(u16_swap_bytes(buf[pos]))
+                               : char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xFF80) == 0) {
+      // will generate one UTF-8 bytes
+      *utf8_output++ = char(word);
+      pos++;
+    } else if ((word & 0xF800) == 0) {
+      // will generate two UTF-8 bytes
+      // we have 0b110XXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 6) | 0b11000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else if ((word & 0xF800) != 0xD800) {
+      // will generate three UTF-8 bytes
+      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((word >> 12) | 0b11100000);
+      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((word & 0b111111) | 0b10000000);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      if (pos + 1 >= len) {
+        return result(error_code::SURROGATE, pos);
+      }
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      // will generate four UTF-8 bytes
+      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
+      *utf8_output++ = char((value >> 18) | 0b11110000);
+      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
+      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
+      *utf8_output++ = char((value & 0b111111) | 0b10000000);
+      pos += 2;
+    }
+  }
+  return result(error_code::SUCCESS, utf8_output - start);
+}
+
+} // namespace utf16_to_utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16_to_utf8/utf16_to_utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+/* begin file src/scalar/utf16_to_utf32/valid_utf16_to_utf32.h */
+#ifndef SIMDUTF_VALID_UTF16_TO_UTF32_H
+#define SIMDUTF_VALID_UTF16_TO_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_utf32 {
+
+template <endianness big_endian>
+inline size_t convert_valid(const char16_t *buf, size_t len,
+                            char32_t *utf32_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xF800) != 0xD800) {
+      // No surrogate pair, extend 16-bit word to 32-bit word
+      *utf32_output++ = char32_t(word);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      *utf32_output++ = char32_t(value);
+      pos += 2;
+    }
+  }
+  return utf32_output - start;
+}
+
+} // namespace utf16_to_utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16_to_utf32/valid_utf16_to_utf32.h */
+/* begin file src/scalar/utf16_to_utf32/utf16_to_utf32.h */
+#ifndef SIMDUTF_UTF16_TO_UTF32_H
+#define SIMDUTF_UTF16_TO_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_utf32 {
+
+template <endianness big_endian>
+inline size_t convert(const char16_t *buf, size_t len, char32_t *utf32_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xF800) != 0xD800) {
+      // No surrogate pair, extend 16-bit word to 32-bit word
+      *utf32_output++ = char32_t(word);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return 0;
+      }
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return 0;
+      }
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      *utf32_output++ = char32_t(value);
+      pos += 2;
+    }
+  }
+  return utf32_output - start;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char16_t *buf, size_t len,
+                                  char32_t *utf32_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    uint16_t word =
+        !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xF800) != 0xD800) {
+      // No surrogate pair, extend 16-bit word to 32-bit word
+      *utf32_output++ = char32_t(word);
+      pos++;
+    } else {
+      // must be a surrogate pair
+      uint16_t diff = uint16_t(word - 0xD800);
+      if (diff > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      if (pos + 1 >= len) {
+        return result(error_code::SURROGATE, pos);
+      } // minimal bound checking
+      uint16_t next_word = !match_system(big_endian)
+                               ? u16_swap_bytes(data[pos + 1])
+                               : data[pos + 1];
+      uint16_t diff2 = uint16_t(next_word - 0xDC00);
+      if (diff2 > 0x3FF) {
+        return result(error_code::SURROGATE, pos);
+      }
+      uint32_t value = (diff << 10) + diff2 + 0x10000;
+      *utf32_output++ = char32_t(value);
+      pos += 2;
+    }
+  }
+  return result(error_code::SUCCESS, utf32_output - start);
+}
+
+} // namespace utf16_to_utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16_to_utf32/utf16_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 &&                                                    \
+    (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_LATIN1)
+/* begin file src/scalar/utf8_to_utf16/valid_utf8_to_utf16.h */
+#ifndef SIMDUTF_VALID_UTF8_TO_UTF16_H
+#define SIMDUTF_VALID_UTF8_TO_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_utf16 {
+
+template <endianness big_endian>
+inline size_t convert_valid(const char *buf, size_t len,
+                            char16_t *utf16_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    // try to convert the next block of 8 ASCII bytes
+    if (pos + 8 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 8;
+        while (pos < final_pos) {
+          *utf16_output++ = !match_system(big_endian)
+                                ? char16_t(u16_swap_bytes(buf[pos]))
+                                : char16_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(leading_byte))
+                            : char16_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 1 >= len) {
+        break;
+      } // minimal bound checking
+      uint16_t code_point = uint16_t(((leading_byte & 0b00011111) << 6) |
+                                     (data[pos + 1] & 0b00111111));
+      if (!match_system(big_endian)) {
+        code_point = u16_swap_bytes(uint16_t(code_point));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 2 >= len) {
+        break;
+      } // minimal bound checking
+      uint16_t code_point = uint16_t(((leading_byte & 0b00001111) << 12) |
+                                     ((data[pos + 1] & 0b00111111) << 6) |
+                                     (data[pos + 2] & 0b00111111));
+      if (!match_system(big_endian)) {
+        code_point = u16_swap_bytes(uint16_t(code_point));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        break;
+      } // minimal bound checking
+      uint32_t code_point = ((leading_byte & 0b00000111) << 18) |
+                            ((data[pos + 1] & 0b00111111) << 12) |
+                            ((data[pos + 2] & 0b00111111) << 6) |
+                            (data[pos + 3] & 0b00111111);
+      code_point -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+      pos += 4;
+    } else {
+      // we may have a continuation but we do not do error checking
+      return 0;
+    }
+  }
+  return utf16_output - start;
+}
+
+} // namespace utf8_to_utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_utf16/valid_utf8_to_utf16.h */
+/* begin file src/scalar/utf8_to_utf16/utf8_to_utf16.h */
+#ifndef SIMDUTF_UTF8_TO_UTF16_H
+#define SIMDUTF_UTF8_TO_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_utf16 {
+
+template <endianness big_endian>
+inline size_t convert(const char *buf, size_t len, char16_t *utf16_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *utf16_output++ = !match_system(big_endian)
+                                ? char16_t(u16_swap_bytes(buf[pos]))
+                                : char16_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(leading_byte))
+                            : char16_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      // range check
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if (code_point < 0x80 || 0x7ff < code_point) {
+        return 0;
+      }
+      if (!match_system(big_endian)) {
+        code_point = uint32_t(u16_swap_bytes(uint16_t(code_point)));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 2 >= len) {
+        return 0;
+      } // minimal bound checking
+
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      // range check
+      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
+                            (data[pos + 1] & 0b00111111) << 6 |
+                            (data[pos + 2] & 0b00111111);
+      if (code_point < 0x800 || 0xffff < code_point ||
+          (0xd7ff < code_point && code_point < 0xe000)) {
+        return 0;
+      }
+      if (!match_system(big_endian)) {
+        code_point = uint32_t(u16_swap_bytes(uint16_t(code_point)));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        return 0;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+
+      // range check
+      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
+                            (data[pos + 1] & 0b00111111) << 12 |
+                            (data[pos + 2] & 0b00111111) << 6 |
+                            (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff || 0x10ffff < code_point) {
+        return 0;
+      }
+      code_point -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+      pos += 4;
+    } else {
+      return 0;
+    }
+  }
+  return utf16_output - start;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char *buf, size_t len,
+                                  char16_t *utf16_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *utf16_output++ = !match_system(big_endian)
+                                ? char16_t(u16_swap_bytes(buf[pos]))
+                                : char16_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf16_output++ = !match_system(big_endian)
+                            ? char16_t(u16_swap_bytes(leading_byte))
+                            : char16_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 1 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if (code_point < 0x80 || 0x7ff < code_point) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (!match_system(big_endian)) {
+        code_point = uint32_t(u16_swap_bytes(uint16_t(code_point)));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8, it should become
+      // a single UTF-16 word.
+      if (pos + 2 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
+                            (data[pos + 1] & 0b00111111) << 6 |
+                            (data[pos + 2] & 0b00111111);
+      if ((code_point < 0x800) || (0xffff < code_point)) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0xd7ff < code_point && code_point < 0xe000) {
+        return result(error_code::SURROGATE, pos);
+      }
+      if (!match_system(big_endian)) {
+        code_point = uint32_t(u16_swap_bytes(uint16_t(code_point)));
+      }
+      *utf16_output++ = char16_t(code_point);
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+
+      // range check
+      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
+                            (data[pos + 1] & 0b00111111) << 12 |
+                            (data[pos + 2] & 0b00111111) << 6 |
+                            (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0x10ffff < code_point) {
+        return result(error_code::TOO_LARGE, pos);
+      }
+      code_point -= 0x10000;
+      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
+      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
+      if (!match_system(big_endian)) {
+        high_surrogate = u16_swap_bytes(high_surrogate);
+        low_surrogate = u16_swap_bytes(low_surrogate);
+      }
+      *utf16_output++ = char16_t(high_surrogate);
+      *utf16_output++ = char16_t(low_surrogate);
+      pos += 4;
+    } else {
+      // we either have too many continuation bytes or an invalid leading byte
+      if ((leading_byte & 0b11000000) == 0b10000000) {
+        return result(error_code::TOO_LONG, pos);
+      } else {
+        return result(error_code::HEADER_BITS, pos);
+      }
+    }
+  }
+  return result(error_code::SUCCESS, utf16_output - start);
+}
+
+/**
+ * When rewind_and_convert_with_errors is called, we are pointing at 'buf' and
+ * we have up to len input bytes left, and we encountered some error. It is
+ * possible that the error is at 'buf' exactly, but it could also be in the
+ * previous bytes  (up to 3 bytes back).
+ *
+ * prior_bytes indicates how many bytes, prior to 'buf' may belong to the
+ * current memory section and can be safely accessed. We prior_bytes to access
+ * safely up to three bytes before 'buf'.
+ *
+ * The caller is responsible to ensure that len > 0.
+ *
+ * If the error is believed to have occurred prior to 'buf', the count value
+ * contain in the result will be SIZE_T - 1, SIZE_T - 2, or SIZE_T - 3.
+ */
+template <endianness endian>
+inline result rewind_and_convert_with_errors(size_t prior_bytes,
+                                             const char *buf, size_t len,
+                                             char16_t *utf16_output) {
+  size_t extra_len{0};
+  // We potentially need to go back in time and find a leading byte.
+  // In theory '3' would be sufficient, but sometimes the error can go back
+  // quite far.
+  size_t how_far_back = prior_bytes;
+  // size_t how_far_back = 3; // 3 bytes in the past + current position
+  // if(how_far_back >= prior_bytes) { how_far_back = prior_bytes; }
+  bool found_leading_bytes{false};
+  // important: it is i <= how_far_back and not 'i < how_far_back'.
+  for (size_t i = 0; i <= how_far_back; i++) {
+    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
+    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
+    if (found_leading_bytes) {
+      if (i > 0 && byte < 128) {
+        // If we had to go back and the leading byte is ascii
+        // then we can stop right away.
+        return result(error_code::TOO_LONG, 0 - i + 1);
+      }
+      buf -= i;
+      extra_len = i;
+      break;
+    }
+  }
+  //
+  // It is possible for this function to return a negative count in its result.
+  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
+  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
+  // unsigned integral type of the result of the sizeof operator
+  //
+  // An unsigned type will simply wrap round arithmetically (well defined).
+  //
+  if (!found_leading_bytes) {
+    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
+    // [....] [continuation] [continuation] [continuation] | [buf is
+    // continuation] Or we possibly have a stream that does not start with a
+    // leading byte.
+    return result(error_code::TOO_LONG, 0 - how_far_back);
+  }
+  result res = convert_with_errors<endian>(buf, len + extra_len, utf16_output);
+  if (res.error) {
+    res.count -= extra_len;
+  }
+  return res;
+}
+
+} // namespace utf8_to_utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_utf16/utf8_to_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_LATIN1)
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
+/* begin file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
+#ifndef SIMDUTF_VALID_UTF8_TO_UTF32_H
+#define SIMDUTF_VALID_UTF8_TO_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_utf32 {
+
+inline size_t convert_valid(const char *buf, size_t len,
+                            char32_t *utf32_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    // try to convert the next block of 8 ASCII bytes
+    if (pos + 8 <=
+        len) { // if it is safe to read 8 more bytes, check that they are ascii
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 8;
+        while (pos < final_pos) {
+          *utf32_output++ = char32_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf32_output++ = char32_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        break;
+      } // minimal bound checking
+      *utf32_output++ = char32_t(((leading_byte & 0b00011111) << 6) |
+                                 (data[pos + 1] & 0b00111111));
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8
+      if (pos + 2 >= len) {
+        break;
+      } // minimal bound checking
+      *utf32_output++ = char32_t(((leading_byte & 0b00001111) << 12) |
+                                 ((data[pos + 1] & 0b00111111) << 6) |
+                                 (data[pos + 2] & 0b00111111));
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        break;
+      } // minimal bound checking
+      uint32_t code_word = ((leading_byte & 0b00000111) << 18) |
+                           ((data[pos + 1] & 0b00111111) << 12) |
+                           ((data[pos + 2] & 0b00111111) << 6) |
+                           (data[pos + 3] & 0b00111111);
+      *utf32_output++ = char32_t(code_word);
+      pos += 4;
+    } else {
+      // we may have a continuation but we do not do error checking
+      return 0;
+    }
+  }
+  return utf32_output - start;
+}
+
+} // namespace utf8_to_utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
+/* begin file src/scalar/utf8_to_utf32/utf8_to_utf32.h */
+#ifndef SIMDUTF_UTF8_TO_UTF32_H
+#define SIMDUTF_UTF8_TO_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_utf32 {
+
+inline size_t convert(const char *buf, size_t len, char32_t *utf32_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *utf32_output++ = char32_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf32_output++ = char32_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      // range check
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if (code_point < 0x80 || 0x7ff < code_point) {
+        return 0;
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8
+      if (pos + 2 >= len) {
+        return 0;
+      } // minimal bound checking
+
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      // range check
+      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
+                            (data[pos + 1] & 0b00111111) << 6 |
+                            (data[pos + 2] & 0b00111111);
+      if (code_point < 0x800 || 0xffff < code_point ||
+          (0xd7ff < code_point && code_point < 0xe000)) {
+        return 0;
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        return 0;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return 0;
+      }
+
+      // range check
+      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
+                            (data[pos + 1] & 0b00111111) << 12 |
+                            (data[pos + 2] & 0b00111111) << 6 |
+                            (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff || 0x10ffff < code_point) {
+        return 0;
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 4;
+    } else {
+      return 0;
+    }
+  }
+  return utf32_output - start;
+}
+
+inline result convert_with_errors(const char *buf, size_t len,
+                                  char32_t *utf32_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char32_t *start{utf32_output};
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2};
+      if ((v & 0x8080808080808080) == 0) {
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *utf32_output++ = char32_t(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *utf32_output++ = char32_t(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) == 0b11000000) {
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
+      if (code_point < 0x80 || 0x7ff < code_point) {
+        return result(error_code::OVERLONG, pos);
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8
+      if (pos + 2 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      // range check
+      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
+                            (data[pos + 1] & 0b00111111) << 6 |
+                            (data[pos + 2] & 0b00111111);
+      if (code_point < 0x800 || 0xffff < code_point) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0xd7ff < code_point && code_point < 0xe000) {
+        return result(error_code::SURROGATE, pos);
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 3;
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      if (pos + 3 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      }
+
+      // range check
+      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
+                            (data[pos + 1] & 0b00111111) << 12 |
+                            (data[pos + 2] & 0b00111111) << 6 |
+                            (data[pos + 3] & 0b00111111);
+      if (code_point <= 0xffff) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0x10ffff < code_point) {
+        return result(error_code::TOO_LARGE, pos);
+      }
+      *utf32_output++ = char32_t(code_point);
+      pos += 4;
+    } else {
+      // we either have too many continuation bytes or an invalid leading byte
+      if ((leading_byte & 0b11000000) == 0b10000000) {
+        return result(error_code::TOO_LONG, pos);
+      } else {
+        return result(error_code::HEADER_BITS, pos);
+      }
+    }
+  }
+  return result(error_code::SUCCESS, utf32_output - start);
+}
+
+/**
+ * When rewind_and_convert_with_errors is called, we are pointing at 'buf' and
+ * we have up to len input bytes left, and we encountered some error. It is
+ * possible that the error is at 'buf' exactly, but it could also be in the
+ * previous bytes location (up to 3 bytes back).
+ *
+ * prior_bytes indicates how many bytes, prior to 'buf' may belong to the
+ * current memory section and can be safely accessed. We prior_bytes to access
+ * safely up to three bytes before 'buf'.
+ *
+ * The caller is responsible to ensure that len > 0.
+ *
+ * If the error is believed to have occurred prior to 'buf', the count value
+ * contain in the result will be SIZE_T - 1, SIZE_T - 2, or SIZE_T - 3.
+ */
+inline result rewind_and_convert_with_errors(size_t prior_bytes,
+                                             const char *buf, size_t len,
+                                             char32_t *utf32_output) {
+  size_t extra_len{0};
+  // We potentially need to go back in time and find a leading byte.
+  size_t how_far_back = 3; // 3 bytes in the past + current position
+  if (how_far_back > prior_bytes) {
+    how_far_back = prior_bytes;
+  }
+  bool found_leading_bytes{false};
+  // important: it is i <= how_far_back and not 'i < how_far_back'.
+  for (size_t i = 0; i <= how_far_back; i++) {
+    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
+    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
+    if (found_leading_bytes) {
+      if (i > 0 && byte < 128) {
+        // If we had to go back and the leading byte is ascii
+        // then we can stop right away.
+        return result(error_code::TOO_LONG, 0 - i + 1);
+      }
+      buf -= i;
+      extra_len = i;
+      break;
+    }
+  }
+  //
+  // It is possible for this function to return a negative count in its result.
+  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
+  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
+  // unsigned integral type of the result of the sizeof operator
+  //
+  // An unsigned type will simply wrap round arithmetically (well defined).
+  //
+  if (!found_leading_bytes) {
+    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
+    // [....] [continuation] [continuation] [continuation] | [buf is
+    // continuation] Or we possibly have a stream that does not start with a
+    // leading byte.
+    return result(error_code::TOO_LONG, 0 - how_far_back);
+  }
+
+  result res = convert_with_errors(buf, len + extra_len, utf32_output);
+  if (res.error) {
+    res.count -= extra_len;
+  }
+  return res;
+}
+
+} // namespace utf8_to_utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_utf32/utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/latin1_to_utf8/latin1_to_utf8.h */
+#ifndef SIMDUTF_LATIN1_TO_UTF8_H
+#define SIMDUTF_LATIN1_TO_UTF8_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace latin1_to_utf8 {
+
+inline size_t convert(const char *buf, size_t len, char *utf8_output) {
+  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
+  size_t pos = 0;
+  size_t utf8_pos = 0;
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 |
+                 v2}; // We are only interested in these bits: 1000 1000 1000
+                      // 1000, so it makes sense to concatenate everything
+      if ((v & 0x8080808080808080) ==
+          0) { // if NONE of these are set, e.g. all of them are zero, then
+               // everything is ASCII
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          utf8_output[utf8_pos++] = char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+
+    unsigned char byte = data[pos];
+    if ((byte & 0x80) == 0) { // if ASCII
+      // will generate one UTF-8 bytes
+      utf8_output[utf8_pos++] = char(byte);
+      pos++;
+    } else {
+      // will generate two UTF-8 bytes
+      utf8_output[utf8_pos++] = char((byte >> 6) | 0b11000000);
+      utf8_output[utf8_pos++] = char((byte & 0b111111) | 0b10000000);
+      pos++;
+    }
+  }
+  return utf8_pos;
+}
+
+inline size_t convert_safe(const char *buf, size_t len, char *utf8_output,
+                           size_t utf8_len) {
+  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
+  size_t pos = 0;
+  size_t skip_pos = 0;
+  size_t utf8_pos = 0;
+  while (pos < len && utf8_pos < utf8_len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos >= skip_pos && pos + 16 <= len &&
+        utf8_pos + 16 <= utf8_len) { // if it is safe to read 16 more bytes,
+                                     // check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 |
+                 v2}; // We are only interested in these bits: 1000 1000 1000
+                      // 1000, so it makes sense to concatenate everything
+      if ((v & 0x8080808080808080) ==
+          0) { // if NONE of these are set, e.g. all of them are zero, then
+               // everything is ASCII
+        ::memcpy(utf8_output + utf8_pos, buf + pos, 16);
+        utf8_pos += 16;
+        pos += 16;
+      } else {
+        // At least one of the next 16 bytes are not ASCII, we will process them
+        // one by one
+        skip_pos = pos + 16;
+      }
+    } else {
+      const auto byte = data[pos];
+      if ((byte & 0x80) == 0) { // if ASCII
+        // will generate one UTF-8 bytes
+        utf8_output[utf8_pos++] = char(byte);
+        pos++;
+      } else if (utf8_pos + 2 <= utf8_len) {
+        // will generate two UTF-8 bytes
+        utf8_output[utf8_pos++] = char((byte >> 6) | 0b11000000);
+        utf8_output[utf8_pos++] = char((byte & 0b111111) | 0b10000000);
+        pos++;
+      } else {
+        break;
+      }
+    }
+  }
+  return utf8_pos;
+}
+
+} // namespace latin1_to_utf8
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/latin1_to_utf8/latin1_to_utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/latin1_to_utf16/latin1_to_utf16.h */
+#ifndef SIMDUTF_LATIN1_TO_UTF16_H
+#define SIMDUTF_LATIN1_TO_UTF16_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace latin1_to_utf16 {
+
+template <endianness big_endian>
+inline size_t convert(const char *buf, size_t len, char16_t *utf16_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+
+  while (pos < len) {
+    uint16_t word =
+        uint16_t(data[pos]); // extend Latin-1 char to 16-bit Unicode code point
+    *utf16_output++ =
+        char16_t(match_system(big_endian) ? word : u16_swap_bytes(word));
+    pos++;
+  }
+
+  return utf16_output - start;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char *buf, size_t len,
+                                  char16_t *utf16_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char16_t *start{utf16_output};
+
+  while (pos < len) {
+    uint16_t word =
+        uint16_t(data[pos]); // extend Latin-1 char to 16-bit Unicode code point
+    *utf16_output++ =
+        char16_t(match_system(big_endian) ? word : u16_swap_bytes(word));
+    pos++;
+  }
+
+  return result(error_code::SUCCESS, utf16_output - start);
+}
+
+} // namespace latin1_to_utf16
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/latin1_to_utf16/latin1_to_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/latin1_to_utf32/latin1_to_utf32.h */
+#ifndef SIMDUTF_LATIN1_TO_UTF32_H
+#define SIMDUTF_LATIN1_TO_UTF32_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace latin1_to_utf32 {
+
+inline size_t convert(const char *buf, size_t len, char32_t *utf32_output) {
+  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
+  char32_t *start{utf32_output};
+  for (size_t i = 0; i < len; i++) {
+    *utf32_output++ = (char32_t)data[i];
+  }
+  return utf32_output - start;
+}
+
+} // namespace latin1_to_utf32
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/latin1_to_utf32/latin1_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf8_to_latin1/utf8_to_latin1.h */
+#ifndef SIMDUTF_UTF8_TO_LATIN1_H
+#define SIMDUTF_UTF8_TO_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_latin1 {
+
+inline size_t convert(const char *buf, size_t len, char *latin_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char *start{latin_output};
+
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2}; // We are only interested in these bits: 1000 1000
+                           // 1000 1000 .... etc
+      if ((v & 0x8080808080808080) ==
+          0) { // if NONE of these are set, e.g. all of them are zero, then
+               // everything is ASCII
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *latin_output++ = char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+
+    // suppose it is not an all ASCII byte sequence
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *latin_output++ = char(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) ==
+               0b11000000) { // the first three bits indicate:
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        return 0;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      } // checks if the next byte is a valid continuation byte in UTF-8. A
+        // valid continuation byte starts with 10.
+      // range check -
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 |
+          (data[pos + 1] &
+           0b00111111); // assembles the Unicode code point from the two bytes.
+                        // It does this by discarding the leading 110 and 10
+                        // bits from the two bytes, shifting the remaining bits
+                        // of the first byte, and then combining the results
+                        // with a bitwise OR operation.
+      if (code_point < 0x80 || 0xFF < code_point) {
+        return 0; // We only care about the range 129-255 which is Non-ASCII
+                  // latin1 characters. A code_point beneath 0x80 is invalid as
+                  // it is already covered by bytes whose leading bit is zero.
+      }
+      *latin_output++ = char(code_point);
+      pos += 2;
+    } else {
+      return 0;
+    }
+  }
+  return latin_output - start;
+}
+
+inline result convert_with_errors(const char *buf, size_t len,
+                                  char *latin_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+  size_t pos = 0;
+  char *start{latin_output};
+
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 | v2}; // We are only interested in these bits: 1000 1000
+                           // 1000 1000...etc
+      if ((v & 0x8080808080808080) ==
+          0) { // if NONE of these are set, e.g. all of them are zero, then
+               // everything is ASCII
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *latin_output++ = char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    // suppose it is not an all ASCII byte sequence
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *latin_output++ = char(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) ==
+               0b11000000) { // the first three bits indicate:
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        return result(error_code::TOO_SHORT, pos);
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return result(error_code::TOO_SHORT, pos);
+      } // checks if the next byte is a valid continuation byte in UTF-8. A
+        // valid continuation byte starts with 10.
+      // range check -
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 |
+          (data[pos + 1] &
+           0b00111111); // assembles the Unicode code point from the two bytes.
+                        // It does this by discarding the leading 110 and 10
+                        // bits from the two bytes, shifting the remaining bits
+                        // of the first byte, and then combining the results
+                        // with a bitwise OR operation.
+      if (code_point < 0x80) {
+        return result(error_code::OVERLONG, pos);
+      }
+      if (0xFF < code_point) {
+        return result(error_code::TOO_LARGE, pos);
+      } // We only care about the range 129-255 which is Non-ASCII latin1
+        // characters
+      *latin_output++ = char(code_point);
+      pos += 2;
+    } else if ((leading_byte & 0b11110000) == 0b11100000) {
+      // We have a three-byte UTF-8
+      return result(error_code::TOO_LARGE, pos);
+    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
+      // we have a 4-byte UTF-8 word.
+      return result(error_code::TOO_LARGE, pos);
+    } else {
+      // we either have too many continuation bytes or an invalid leading byte
+      if ((leading_byte & 0b11000000) == 0b10000000) {
+        return result(error_code::TOO_LONG, pos);
+      }
+
+      return result(error_code::HEADER_BITS, pos);
+    }
+  }
+  return result(error_code::SUCCESS, latin_output - start);
+}
+
+inline result rewind_and_convert_with_errors(size_t prior_bytes,
+                                             const char *buf, size_t len,
+                                             char *latin1_output) {
+  size_t extra_len{0};
+  // We potentially need to go back in time and find a leading byte.
+  // In theory '3' would be sufficient, but sometimes the error can go back
+  // quite far.
+  size_t how_far_back = prior_bytes;
+  // size_t how_far_back = 3; // 3 bytes in the past + current position
+  // if(how_far_back >= prior_bytes) { how_far_back = prior_bytes; }
+  bool found_leading_bytes{false};
+  // important: it is i <= how_far_back and not 'i < how_far_back'.
+  for (size_t i = 0; i <= how_far_back; i++) {
+    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
+    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
+    if (found_leading_bytes) {
+      if (i > 0 && byte < 128) {
+        // If we had to go back and the leading byte is ascii
+        // then we can stop right away.
+        return result(error_code::TOO_LONG, 0 - i + 1);
+      }
+      buf -= i;
+      extra_len = i;
+      break;
+    }
+  }
+  //
+  // It is possible for this function to return a negative count in its result.
+  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
+  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
+  // unsigned integral type of the result of the sizeof operator
+  //
+  // An unsigned type will simply wrap round arithmetically (well defined).
+  //
+  if (!found_leading_bytes) {
+    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
+    // [....] [continuation] [continuation] [continuation] | [buf is
+    // continuation] Or we possibly have a stream that does not start with a
+    // leading byte.
+    return result(error_code::TOO_LONG, 0 - how_far_back);
+  }
+  result res = convert_with_errors(buf, len + extra_len, latin1_output);
+  if (res.error) {
+    res.count -= extra_len;
+  }
+  return res;
+}
+
+} // namespace utf8_to_latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_latin1/utf8_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf16_to_latin1/utf16_to_latin1.h */
+#ifndef SIMDUTF_UTF16_TO_LATIN1_H
+#define SIMDUTF_UTF16_TO_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_latin1 {
+
+#include <cstring> // for std::memcpy
+
+template <endianness big_endian>
+inline size_t convert(const char16_t *buf, size_t len, char *latin_output) {
+  if (len == 0) {
+    return 0;
+  }
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *current_write = latin_output;
+  uint16_t word = 0;
+  uint16_t too_large = 0;
+
+  while (pos < len) {
+    word = !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    too_large |= word;
+    *current_write++ = char(word & 0xFF);
+    pos++;
+  }
+  if ((too_large & 0xFF00) != 0) {
+    return 0;
+  }
+
+  return current_write - latin_output;
+}
+
+template <endianness big_endian>
+inline result convert_with_errors(const char16_t *buf, size_t len,
+                                  char *latin_output) {
+  if (len == 0) {
+    return result(error_code::SUCCESS, 0);
+  }
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *start{latin_output};
+  uint16_t word;
+
+  while (pos < len) {
+    if (pos + 16 <= len) { // if it is safe to read 32 more bytes, check that
+                           // they are Latin1
+      uint64_t v1, v2, v3, v4;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      ::memcpy(&v2, data + pos + 4, sizeof(uint64_t));
+      ::memcpy(&v3, data + pos + 8, sizeof(uint64_t));
+      ::memcpy(&v4, data + pos + 12, sizeof(uint64_t));
+
+      if (!match_system(big_endian)) {
+        v1 = (v1 >> 8) | (v1 << (64 - 8));
+      }
+      if (!match_system(big_endian)) {
+        v2 = (v2 >> 8) | (v2 << (64 - 8));
+      }
+      if (!match_system(big_endian)) {
+        v3 = (v3 >> 8) | (v3 << (64 - 8));
+      }
+      if (!match_system(big_endian)) {
+        v4 = (v4 >> 8) | (v4 << (64 - 8));
+      }
+
+      if (((v1 | v2 | v3 | v4) & 0xFF00FF00FF00FF00) == 0) {
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *latin_output++ = !match_system(big_endian)
+                                ? char(u16_swap_bytes(data[pos]))
+                                : char(data[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+    word = !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    if ((word & 0xFF00) == 0) {
+      *latin_output++ = char(word & 0xFF);
+      pos++;
+    } else {
+      return result(error_code::TOO_LARGE, pos);
+    }
+  }
+  return result(error_code::SUCCESS, latin_output - start);
+}
+
+} // namespace utf16_to_latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf16_to_latin1/utf16_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf32_to_latin1/utf32_to_latin1.h */
+#ifndef SIMDUTF_UTF32_TO_LATIN1_H
+#define SIMDUTF_UTF32_TO_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf32_to_latin1 {
+
+inline size_t convert(const char32_t *buf, size_t len, char *latin1_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  char *start = latin1_output;
+  uint32_t utf32_char;
+  size_t pos = 0;
+  uint32_t too_large = 0;
+
+  while (pos < len) {
+    utf32_char = (uint32_t)data[pos];
+    too_large |= utf32_char;
+    *latin1_output++ = (char)(utf32_char & 0xFF);
+    pos++;
+  }
+  if ((too_large & 0xFFFFFF00) != 0) {
+    return 0;
+  }
+  return latin1_output - start;
+}
+
+inline result convert_with_errors(const char32_t *buf, size_t len,
+                                  char *latin1_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  char *start{latin1_output};
+  size_t pos = 0;
+  while (pos < len) {
+    if (pos + 2 <=
+        len) { // if it is safe to read 8 more bytes, check that they are Latin1
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0xFFFFFF00FFFFFF00) == 0) {
+        *latin1_output++ = char(buf[pos]);
+        *latin1_output++ = char(buf[pos + 1]);
+        pos += 2;
+        continue;
+      }
+    }
+    uint32_t utf32_char = data[pos];
+    if ((utf32_char & 0xFFFFFF00) ==
+        0) { // Check if the character can be represented in Latin-1
+      *latin1_output++ = (char)(utf32_char & 0xFF);
+      pos++;
+    } else {
+      return result(error_code::TOO_LARGE, pos);
+    };
+  }
+  return result(error_code::SUCCESS, latin1_output - start);
+}
+
+} // namespace utf32_to_latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_latin1/utf32_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf8_to_latin1/valid_utf8_to_latin1.h */
+#ifndef SIMDUTF_VALID_UTF8_TO_LATIN1_H
+#define SIMDUTF_VALID_UTF8_TO_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf8_to_latin1 {
+
+inline size_t convert_valid(const char *buf, size_t len, char *latin_output) {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+
+  size_t pos = 0;
+  char *start{latin_output};
+
+  while (pos < len) {
+    // try to convert the next block of 16 ASCII bytes
+    if (pos + 16 <=
+        len) { // if it is safe to read 16 more bytes, check that they are ascii
+      uint64_t v1;
+      ::memcpy(&v1, data + pos, sizeof(uint64_t));
+      uint64_t v2;
+      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
+      uint64_t v{v1 |
+                 v2}; // We are only interested in these bits: 1000 1000 1000
+                      // 1000, so it makes sense to concatenate everything
+      if ((v & 0x8080808080808080) ==
+          0) { // if NONE of these are set, e.g. all of them are zero, then
+               // everything is ASCII
+        size_t final_pos = pos + 16;
+        while (pos < final_pos) {
+          *latin_output++ = char(buf[pos]);
+          pos++;
+        }
+        continue;
+      }
+    }
+
+    // suppose it is not an all ASCII byte sequence
+    uint8_t leading_byte = data[pos]; // leading byte
+    if (leading_byte < 0b10000000) {
+      // converting one ASCII byte !!!
+      *latin_output++ = char(leading_byte);
+      pos++;
+    } else if ((leading_byte & 0b11100000) ==
+               0b11000000) { // the first three bits indicate:
+      // We have a two-byte UTF-8
+      if (pos + 1 >= len) {
+        break;
+      } // minimal bound checking
+      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
+        return 0;
+      } // checks if the next byte is a valid continuation byte in UTF-8. A
+        // valid continuation byte starts with 10.
+      // range check -
+      uint32_t code_point =
+          (leading_byte & 0b00011111) << 6 |
+          (data[pos + 1] &
+           0b00111111); // assembles the Unicode code point from the two bytes.
+                        // It does this by discarding the leading 110 and 10
+                        // bits from the two bytes, shifting the remaining bits
+                        // of the first byte, and then combining the results
+                        // with a bitwise OR operation.
+      *latin_output++ = char(code_point);
+      pos += 2;
+    } else {
+      // we may have a continuation but we do not do error checking
+      return 0;
+    }
+  }
+  return latin_output - start;
+}
+
+} // namespace utf8_to_latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf8_to_latin1/valid_utf8_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf16_to_latin1/valid_utf16_to_latin1.h */
+#ifndef SIMDUTF_VALID_UTF16_TO_LATIN1_H
+#define SIMDUTF_VALID_UTF16_TO_LATIN1_H
+
+namespace simdutf {
+namespace scalar {
+namespace {
+namespace utf16_to_latin1 {
+
+template <endianness big_endian>
+inline size_t convert_valid(const char16_t *buf, size_t len,
+                            char *latin_output) {
+  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
+  size_t pos = 0;
+  char *start{latin_output};
+  uint16_t word = 0;
+
+  while (pos < len) {
+    word = !match_system(big_endian) ? u16_swap_bytes(data[pos]) : data[pos];
+    *latin_output++ = char(word);
+    pos++;
+  }
+
+  return latin_output - start;
+}
+
+} // namespace utf16_to_latin1
 } // unnamed namespace
+} // namespace scalar
 } // namespace simdutf
 
-#endif // SIMDUTF_UTF8_TO_UTF16_TABLES_H
-/* end file src/tables/utf8_to_utf16_tables.h */
-/* begin file src/tables/utf16_to_utf8_tables.h */
-// file generated by scripts/sse_convert_utf16_to_utf8.py
-#ifndef SIMDUTF_UTF16_TO_UTF8_TABLES_H
-#define SIMDUTF_UTF16_TO_UTF8_TABLES_H
+#endif
+/* end file src/scalar/utf16_to_latin1/valid_utf16_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/scalar/utf32_to_latin1/valid_utf32_to_latin1.h */
+#ifndef SIMDUTF_VALID_UTF32_TO_LATIN1_H
+#define SIMDUTF_VALID_UTF32_TO_LATIN1_H
 
 namespace simdutf {
+namespace scalar {
 namespace {
-namespace tables {
-namespace utf16_to_utf8 {
+namespace utf32_to_latin1 {
 
-// 1 byte for length, 16 bytes for mask
-const uint8_t pack_1_2_utf8_bytes[256][17] = {
-    {16, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14},
-    {15, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
-    {15, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80},
-    {14, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {15, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
-    {14, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {14, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80},
-    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {15, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
-    {14, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {14, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80},
-    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {15, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80},
-    {14, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {14, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80},
-    {14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
-    {13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80},
-    {13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80},
-    {12, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {12, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80},
-    {11, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {11, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {11, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 1, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 1, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80}};
+inline size_t convert_valid(const char32_t *buf, size_t len,
+                            char *latin1_output) {
+  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
+  char *start = latin1_output;
+  uint32_t utf32_char;
+  size_t pos = 0;
+
+  while (pos < len) {
+    utf32_char = (uint32_t)data[pos];
+
+    if (pos + 2 <=
+        len) { // if it is safe to read 8 more bytes, check that they are Latin1
+      uint64_t v;
+      ::memcpy(&v, data + pos, sizeof(uint64_t));
+      if ((v & 0xFFFFFF00FFFFFF00) == 0) {
+        *latin1_output++ = char(buf[pos]);
+        *latin1_output++ = char(buf[pos + 1]);
+        pos += 2;
+        continue;
+      } else {
+        // output can not be represented in latin1
+        return 0;
+      }
+    }
+    if ((utf32_char & 0xFFFFFF00) == 0) {
+      *latin1_output++ = char(utf32_char);
+    } else {
+      // output can not be represented in latin1
+      return 0;
+    }
+    pos++;
+  }
+  return latin1_output - start;
+}
+
+} // namespace utf32_to_latin1
+} // unnamed namespace
+} // namespace scalar
+} // namespace simdutf
+
+#endif
+/* end file src/scalar/utf32_to_latin1/valid_utf32_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+/* begin file src/implementation.cpp */
+#include <initializer_list>
+#include <climits>
+#include <type_traits>
+
+static_assert(sizeof(uint8_t) == sizeof(char),
+              "simdutf requires that uint8_t be a char");
+static_assert(sizeof(uint16_t) == sizeof(char16_t),
+              "simdutf requires that char16_t be 16 bits");
+static_assert(sizeof(uint32_t) == sizeof(char32_t),
+              "simdutf requires that char32_t be 32 bits");
+// next line is redundant, but it is kept to catch defective systems.
+static_assert(CHAR_BIT == 8, "simdutf requires 8-bit bytes");
+
+// Useful for debugging purposes
+namespace simdutf {
+namespace {
+
+template <typename T> std::string toBinaryString(T b) {
+  std::string binary = "";
+  T mask = T(1) << (sizeof(T) * CHAR_BIT - 1);
+  while (mask > 0) {
+    binary += ((b & mask) == 0) ? '0' : '1';
+    mask >>= 1;
+  }
+  return binary;
+}
+} // namespace
+} // namespace simdutf
+
+namespace simdutf {
+bool implementation::supported_by_runtime_system() const {
+  uint32_t required_instruction_sets = this->required_instruction_sets();
+  uint32_t supported_instruction_sets =
+      internal::detect_supported_architectures();
+  return ((supported_instruction_sets & required_instruction_sets) ==
+          required_instruction_sets);
+}
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+simdutf_warn_unused encoding_type implementation::autodetect_encoding(
+    const char *input, size_t length) const noexcept {
+  // If there is a BOM, then we trust it.
+  auto bom_encoding = simdutf::BOM::check_bom(input, length);
+  if (bom_encoding != encoding_type::unspecified) {
+    return bom_encoding;
+  }
+  // UTF8 is common, it includes ASCII, and is commonly represented
+  // without a BOM, so if it fits, go with that. Note that it is still
+  // possible to get it wrong, we are only 'guessing'. If some has UTF-16
+  // data without a BOM, it could pass as UTF-8.
+  //
+  // An interesting twist might be to check for UTF-16 ASCII first (every
+  // other byte is zero).
+  if (validate_utf8(input, length)) {
+    return encoding_type::UTF8;
+  }
+  // The next most common encoding that might appear without BOM is probably
+  // UTF-16LE, so try that next.
+  if ((length % 2) == 0) {
+    // important: we need to divide by two
+    if (validate_utf16le(reinterpret_cast<const char16_t *>(input),
+                         length / 2)) {
+      return encoding_type::UTF16_LE;
+    }
+  }
+  if ((length % 4) == 0) {
+    if (validate_utf32(reinterpret_cast<const char32_t *>(input), length / 4)) {
+      return encoding_type::UTF32_LE;
+    }
+  }
+  return encoding_type::unspecified;
+}
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_BASE64
+simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
+    const char *input, size_t length) const noexcept {
+  return scalar::base64::maximal_binary_length_from_base64(input, length);
+}
+
+simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
+    const char16_t *input, size_t length) const noexcept {
+  return scalar::base64::maximal_binary_length_from_base64(input, length);
+}
+
+simdutf_warn_unused size_t implementation::base64_length_from_binary(
+    size_t length, base64_options options) const noexcept {
+  return scalar::base64::base64_length_from_binary(length, options);
+}
+#endif // SIMDUTF_FEATURE_BASE64
+
+namespace internal {
+// When there is a single implementation, we should not pay a price
+// for dispatching to the best implementation. We should just use the
+// one we have. This is a compile-time check.
+#define SIMDUTF_SINGLE_IMPLEMENTATION                                          \
+  (SIMDUTF_IMPLEMENTATION_ICELAKE + SIMDUTF_IMPLEMENTATION_HASWELL +           \
+       SIMDUTF_IMPLEMENTATION_WESTMERE + SIMDUTF_IMPLEMENTATION_ARM64 +        \
+       SIMDUTF_IMPLEMENTATION_PPC64 + SIMDUTF_IMPLEMENTATION_LSX +             \
+       SIMDUTF_IMPLEMENTATION_LASX + SIMDUTF_IMPLEMENTATION_FALLBACK ==        \
+   1)
+
+// Static array of known implementations. We are hoping these get baked into the
+// executable without requiring a static initializer.
+
+#if SIMDUTF_IMPLEMENTATION_ICELAKE
+static const icelake::implementation *get_icelake_singleton() {
+  static const icelake::implementation icelake_singleton{};
+  return &icelake_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_HASWELL
+static const haswell::implementation *get_haswell_singleton() {
+  static const haswell::implementation haswell_singleton{};
+  return &haswell_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_WESTMERE
+static const westmere::implementation *get_westmere_singleton() {
+  static const westmere::implementation westmere_singleton{};
+  return &westmere_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_ARM64
+static const arm64::implementation *get_arm64_singleton() {
+  static const arm64::implementation arm64_singleton{};
+  return &arm64_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_PPC64
+static const ppc64::implementation *get_ppc64_singleton() {
+  static const ppc64::implementation ppc64_singleton{};
+  return &ppc64_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_RVV
+static const rvv::implementation *get_rvv_singleton() {
+  static const rvv::implementation rvv_singleton{};
+  return &rvv_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_LSX
+static const lsx::implementation *get_lsx_singleton() {
+  static const lsx::implementation lsx_singleton{};
+  return &lsx_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_LASX
+static const lasx::implementation *get_lasx_singleton() {
+  static const lasx::implementation lasx_singleton{};
+  return &lasx_singleton;
+}
+#endif
+#if SIMDUTF_IMPLEMENTATION_FALLBACK
+static const fallback::implementation *get_fallback_singleton() {
+  static const fallback::implementation fallback_singleton{};
+  return &fallback_singleton;
+}
+#endif
+
+#if SIMDUTF_SINGLE_IMPLEMENTATION
+static const implementation *get_single_implementation() {
+  return
+  #if SIMDUTF_IMPLEMENTATION_ICELAKE
+      get_icelake_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_HASWELL
+  get_haswell_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_WESTMERE
+  get_westmere_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_ARM64
+  get_arm64_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_PPC64
+  get_ppc64_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_LSX
+  get_lsx_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_LASX
+  get_lasx_singleton();
+  #endif
+  #if SIMDUTF_IMPLEMENTATION_FALLBACK
+  get_fallback_singleton();
+  #endif
+}
+#endif
+
+/**
+ * @private Detects best supported implementation on first use, and sets it
+ */
+class detect_best_supported_implementation_on_first_use final
+    : public implementation {
+public:
+  std::string name() const noexcept final { return set_best()->name(); }
+  std::string description() const noexcept final {
+    return set_best()->description();
+  }
+  uint32_t required_instruction_sets() const noexcept final {
+    return set_best()->required_instruction_sets();
+  }
 
-// 1 byte for length, 16 bytes for mask
-const uint8_t pack_1_2_3_utf8_bytes[256][17] = {
-    {12, 2, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80},
-    {9, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {11, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {10, 0, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 2, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {11, 2, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {10, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {10, 2, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 0, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 2, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 2, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {8, 2, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {11, 2, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {10, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {10, 2, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 0, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 2, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {10, 2, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 0, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 2, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 2, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 2, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 2, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {8, 2, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 2, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {3, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {1, 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {5, 2, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 0, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 2, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {3, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {2, 0, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {8, 2, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 2, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 0, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {7, 2, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 0, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 2, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {3, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 0, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 2, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {3, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {2, 0, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 2, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {3, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 2, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 0, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {11, 2, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {10, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {9, 0, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {10, 2, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 0, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 2, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 2, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {4, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {3, 0, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {7, 2, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 2, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {10, 2, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 0, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 2, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 2, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 2, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 2, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {8, 2, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {10, 2, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {7, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {9, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {8, 0, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 2, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {9, 2, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {8, 2, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 0, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 2, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80, 0x80},
-    {3, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {2, 0, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 2, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {3, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 2, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 0, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {9, 2, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},
-    {6, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {7, 0, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 2, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {8, 2, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 2, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {6, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {5, 0, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {8, 2, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {7, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {6, 0, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 2, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {2, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {4, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {3, 0, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {7, 2, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {4, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {5, 0, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {6, 2, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80},
-    {3, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80, 0x80},
-    {5, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80},
-    {4, 0, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-     0x80, 0x80}};
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int
+  detect_encodings(const char *input, size_t length) const noexcept override {
+    return set_best()->detect_encodings(input, length);
+  }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool
+  validate_utf8(const char *buf, size_t len) const noexcept final override {
+    return set_best()->validate_utf8(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result validate_utf8_with_errors(
+      const char *buf, size_t len) const noexcept final override {
+    return set_best()->validate_utf8_with_errors(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool
+  validate_ascii(const char *buf, size_t len) const noexcept final override {
+    return set_best()->validate_ascii(buf, len);
+  }
 
-} // namespace utf16_to_utf8
-} // namespace tables
-} // unnamed namespace
-} // namespace simdutf
+  simdutf_warn_unused result validate_ascii_with_errors(
+      const char *buf, size_t len) const noexcept final override {
+    return set_best()->validate_ascii_with_errors(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_ASCII
 
-#endif // SIMDUTF_UTF16_TO_UTF8_TABLES_H
-/* end file src/tables/utf16_to_utf8_tables.h */
-// End of tables.
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool
+  validate_utf16le(const char16_t *buf,
+                   size_t len) const noexcept final override {
+    return set_best()->validate_utf16le(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
-// The scalar routines should be included once.
-/* begin file src/scalar/ascii.h */
-#ifndef SIMDUTF_ASCII_H
-#define SIMDUTF_ASCII_H
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool
+  validate_utf16be(const char16_t *buf,
+                   size_t len) const noexcept final override {
+    return set_best()->validate_utf16be(buf, len);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace ascii {
-#if SIMDUTF_IMPLEMENTATION_FALLBACK
-// Only used by the fallback kernel.
-inline simdutf_warn_unused bool validate(const char *buf, size_t len) noexcept {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  uint64_t pos = 0;
-  // process in blocks of 16 bytes when possible
-  for (; pos + 16 <= len; pos += 16) {
-    uint64_t v1;
-    std::memcpy(&v1, data + pos, sizeof(uint64_t));
-    uint64_t v2;
-    std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-    uint64_t v{v1 | v2};
-    if ((v & 0x8080808080808080) != 0) {
-      return false;
-    }
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *buf, size_t len) const noexcept final override {
+    return set_best()->validate_utf16le_with_errors(buf, len);
   }
-  // process the tail byte-by-byte
-  for (; pos < len; pos++) {
-    if (data[pos] >= 0b10000000) {
-      return false;
-    }
+
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *buf, size_t len) const noexcept final override {
+    return set_best()->validate_utf16be_with_errors(buf, len);
   }
-  return true;
-}
-#endif
+#endif // SIMDUTF_FEATURE_UTF16
 
-inline simdutf_warn_unused result validate_with_errors(const char *buf,
-                                                       size_t len) noexcept {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  // process in blocks of 16 bytes when possible
-  for (; pos + 16 <= len; pos += 16) {
-    uint64_t v1;
-    std::memcpy(&v1, data + pos, sizeof(uint64_t));
-    uint64_t v2;
-    std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-    uint64_t v{v1 | v2};
-    if ((v & 0x8080808080808080) != 0) {
-      for (; pos < len; pos++) {
-        if (data[pos] >= 0b10000000) {
-          return result(error_code::TOO_LARGE, pos);
-        }
-      }
-    }
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool
+  validate_utf32(const char32_t *buf,
+                 size_t len) const noexcept final override {
+    return set_best()->validate_utf32(buf, len);
   }
-  // process the tail byte-by-byte
-  for (; pos < len; pos++) {
-    if (data[pos] >= 0b10000000) {
-      return result(error_code::TOO_LARGE, pos);
-    }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *buf, size_t len) const noexcept final override {
+    return set_best()->validate_utf32_with_errors(buf, len);
   }
-  return result(error_code::SUCCESS, pos);
-}
+#endif // SIMDUTF_FEATURE_UTF32
 
-} // namespace ascii
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_latin1_to_utf8(const char *buf, size_t len,
+                         char *utf8_output) const noexcept final override {
+    return set_best()->convert_latin1_to_utf8(buf, len, utf8_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-#endif
-/* end file src/scalar/ascii.h */
-/* begin file src/scalar/latin1.h */
-#ifndef SIMDUTF_LATIN1_H
-#define SIMDUTF_LATIN1_H
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_latin1_to_utf16le(buf, len, utf16_output);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace latin1 {
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_latin1_to_utf16be(buf, len, utf16_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-inline size_t utf32_length_from_latin1(size_t len) {
-  // We are not BOM aware.
-  return len; // a utf32 unit will always represent 1 latin1 character
-}
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *buf, size_t len,
+      char32_t *latin1_output) const noexcept final override {
+    return set_best()->convert_latin1_to_utf32(buf, len, latin1_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-inline size_t utf8_length_from_latin1(const char *buf, size_t len) {
-  const uint8_t *c = reinterpret_cast<const uint8_t *>(buf);
-  size_t answer = 0;
-  for (size_t i = 0; i < len; i++) {
-    if ((c[i] >> 7)) {
-      answer++;
-    }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf8_to_latin1(const char *buf, size_t len,
+                         char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf8_to_latin1(buf, len, latin1_output);
   }
-  return answer + len;
-}
 
-inline size_t utf16_length_from_latin1(size_t len) { return len; }
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf8_to_latin1_with_errors(buf, len,
+                                                          latin1_output);
+  }
 
-} // namespace latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_valid_utf8_to_latin1(buf, len, latin1_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-#endif
-/* end file src/scalar/latin1.h */
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf16le(buf, len, utf16_output);
+  }
 
-/* begin file src/scalar/utf32_to_utf8/valid_utf32_to_utf8.h */
-#ifndef SIMDUTF_VALID_UTF32_TO_UTF8_H
-#define SIMDUTF_VALID_UTF32_TO_UTF8_H
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf16be(buf, len, utf16_output);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_utf8 {
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf16le_with_errors(buf, len,
+                                                           utf16_output);
+  }
 
-#if SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_PPC64
-// only used by the fallback and POWER kernel
-inline size_t convert_valid(const char32_t *buf, size_t len,
-                            char *utf8_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 2 ASCII characters
-    if (pos + 2 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
-        *utf8_output++ = char(buf[pos]);
-        *utf8_output++ = char(buf[pos + 1]);
-        pos += 2;
-        continue;
-      }
-    }
-    uint32_t word = data[pos];
-    if ((word & 0xFFFFFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xFFFFF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xFFFF0000) == 0) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 18) | 0b11110000);
-      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    }
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf16be_with_errors(buf, len,
+                                                           utf16_output);
   }
-  return utf8_output - start;
-}
-#endif // SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_PPC64
 
-} // namespace utf32_to_utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_valid_utf8_to_utf16le(buf, len, utf16_output);
+  }
 
-#endif
-/* end file src/scalar/utf32_to_utf8/valid_utf32_to_utf8.h */
-/* begin file src/scalar/utf32_to_utf8/utf32_to_utf8.h */
-#ifndef SIMDUTF_UTF32_TO_UTF8_H
-#define SIMDUTF_UTF32_TO_UTF8_H
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_valid_utf8_to_utf16be(buf, len, utf16_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_utf8 {
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf8_to_utf32(const char *buf, size_t len,
+                        char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf32(buf, len, utf32_output);
+  }
 
-inline size_t convert(const char32_t *buf, size_t len, char *utf8_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 2 ASCII characters
-    if (pos + 2 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
-        *utf8_output++ = char(buf[pos]);
-        *utf8_output++ = char(buf[pos + 1]);
-        pos += 2;
-        continue;
-      }
-    }
-    uint32_t word = data[pos];
-    if ((word & 0xFFFFFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xFFFFF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xFFFF0000) == 0) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      if (word >= 0xD800 && word <= 0xDFFF) {
-        return 0;
-      }
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      if (word > 0x10FFFF) {
-        return 0;
-      }
-      *utf8_output++ = char((word >> 18) | 0b11110000);
-      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    }
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf8_to_utf32_with_errors(buf, len,
+                                                         utf32_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_valid_utf8_to_utf32(buf, len, utf32_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf16le_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_latin1(buf, len, latin1_output);
+  }
+
+  simdutf_warn_unused size_t
+  convert_utf16be_to_latin1(const char16_t *buf, size_t len,
+                            char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_latin1(buf, len, latin1_output);
+  }
+
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_latin1_with_errors(buf, len,
+                                                             latin1_output);
+  }
+
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_latin1_with_errors(buf, len,
+                                                             latin1_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
+      const char16_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_valid_utf16le_to_latin1(buf, len, latin1_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
+      const char16_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_valid_utf16be_to_latin1(buf, len, latin1_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  convert_utf16le_to_utf8(const char16_t *buf, size_t len,
+                          char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_utf8(buf, len, utf8_output);
+  }
+
+  simdutf_warn_unused size_t
+  convert_utf16be_to_utf8(const char16_t *buf, size_t len,
+                          char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_utf8(buf, len, utf8_output);
+  }
+
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *buf, size_t len,
+      char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_utf8_with_errors(buf, len,
+                                                           utf8_output);
+  }
+
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *buf, size_t len,
+      char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_utf8_with_errors(buf, len,
+                                                           utf8_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *buf, size_t len,
+      char *utf8_output) const noexcept final override {
+    return set_best()->convert_valid_utf16le_to_utf8(buf, len, utf8_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *buf, size_t len,
+      char *utf8_output) const noexcept final override {
+    return set_best()->convert_valid_utf16be_to_utf8(buf, len, utf8_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  convert_utf32_to_latin1(const char32_t *buf, size_t len,
+                          char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf32_to_latin1(buf, len, latin1_output);
+  }
+
+  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
+      const char32_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf32_to_latin1_with_errors(buf, len,
+                                                           latin1_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
+      const char32_t *buf, size_t len,
+      char *latin1_output) const noexcept final override {
+    return set_best()->convert_utf32_to_latin1(buf, len, latin1_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  convert_utf32_to_utf8(const char32_t *buf, size_t len,
+                        char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf8(buf, len, utf8_output);
+  }
+
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *buf, size_t len,
+      char *utf8_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf8_with_errors(buf, len, utf8_output);
+  }
+
+  simdutf_warn_unused size_t
+  convert_valid_utf32_to_utf8(const char32_t *buf, size_t len,
+                              char *utf8_output) const noexcept final override {
+    return set_best()->convert_valid_utf32_to_utf8(buf, len, utf8_output);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf16le(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf16le(buf, len, utf16_output);
+  }
+
+  simdutf_warn_unused size_t convert_utf32_to_utf16be(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf16be(buf, len, utf16_output);
+  }
+
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf16le_with_errors(buf, len,
+                                                            utf16_output);
+  }
+
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_utf32_to_utf16be_with_errors(buf, len,
+                                                            utf16_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_valid_utf32_to_utf16le(buf, len, utf16_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
+      const char32_t *buf, size_t len,
+      char16_t *utf16_output) const noexcept final override {
+    return set_best()->convert_valid_utf32_to_utf16be(buf, len, utf16_output);
+  }
+
+  simdutf_warn_unused size_t convert_utf16le_to_utf32(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_utf32(buf, len, utf32_output);
+  }
+
+  simdutf_warn_unused size_t convert_utf16be_to_utf32(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_utf32(buf, len, utf32_output);
+  }
+
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf16le_to_utf32_with_errors(buf, len,
+                                                            utf32_output);
+  }
+
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_utf16be_to_utf32_with_errors(buf, len,
+                                                            utf32_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_valid_utf16le_to_utf32(buf, len, utf32_output);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
+      const char16_t *buf, size_t len,
+      char32_t *utf32_output) const noexcept final override {
+    return set_best()->convert_valid_utf16be_to_utf32(buf, len, utf32_output);
   }
-  return utf8_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-inline result convert_with_errors(const char32_t *buf, size_t len,
-                                  char *utf8_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 2 ASCII characters
-    if (pos + 2 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0xFFFFFF80FFFFFF80) == 0) {
-        *utf8_output++ = char(buf[pos]);
-        *utf8_output++ = char(buf[pos + 1]);
-        pos += 2;
-        continue;
-      }
-    }
-    uint32_t word = data[pos];
-    if ((word & 0xFFFFFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xFFFFF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xFFFF0000) == 0) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      if (word >= 0xD800 && word <= 0xDFFF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      if (word > 0x10FFFF) {
-        return result(error_code::TOO_LARGE, pos);
-      }
-      *utf8_output++ = char((word >> 18) | 0b11110000);
-      *utf8_output++ = char(((word >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    }
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *buf, size_t len,
+                               char16_t *output) const noexcept final override {
+    set_best()->change_endianness_utf16(buf, len, output);
   }
-  return result(error_code::SUCCESS, utf8_output - start);
-}
 
-} // namespace utf32_to_utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused size_t
+  count_utf16le(const char16_t *buf, size_t len) const noexcept final override {
+    return set_best()->count_utf16le(buf, len);
+  }
 
-#endif
-/* end file src/scalar/utf32_to_utf8/utf32_to_utf8.h */
+  simdutf_warn_unused size_t
+  count_utf16be(const char16_t *buf, size_t len) const noexcept final override {
+    return set_best()->count_utf16be(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF16
 
-/* begin file src/scalar/utf32_to_utf16/valid_utf32_to_utf16.h */
-#ifndef SIMDUTF_VALID_UTF32_TO_UTF16_H
-#define SIMDUTF_VALID_UTF32_TO_UTF16_H
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t
+  count_utf8(const char *buf, size_t len) const noexcept final override {
+    return set_best()->count_utf8(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_utf16 {
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *buf, size_t len) const noexcept override {
+    return set_best()->latin1_length_from_utf8(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-template <endianness big_endian>
-inline size_t convert_valid(const char32_t *buf, size_t len,
-                            char16_t *utf16_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    uint32_t word = data[pos];
-    if ((word & 0xFFFF0000) == 0) {
-      // will not generate a surrogate pair
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(uint16_t(word)))
-                            : char16_t(word);
-      pos++;
-    } else {
-      // will generate a surrogate pair
-      word -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-      pos++;
-    }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *buf, size_t len) const noexcept override {
+    return set_best()->utf8_length_from_latin1(buf, len);
   }
-  return utf16_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-} // namespace utf32_to_utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t utf8_length_from_utf16le(
+      const char16_t *buf, size_t len) const noexcept override {
+    return set_best()->utf8_length_from_utf16le(buf, len);
+  }
 
-#endif
-/* end file src/scalar/utf32_to_utf16/valid_utf32_to_utf16.h */
-/* begin file src/scalar/utf32_to_utf16/utf32_to_utf16.h */
-#ifndef SIMDUTF_UTF32_TO_UTF16_H
-#define SIMDUTF_UTF32_TO_UTF16_H
+  simdutf_warn_unused size_t utf8_length_from_utf16be(
+      const char16_t *buf, size_t len) const noexcept override {
+    return set_best()->utf8_length_from_utf16be(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_utf16 {
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf32_length_from_utf16le(
+      const char16_t *buf, size_t len) const noexcept override {
+    return set_best()->utf32_length_from_utf16le(buf, len);
+  }
 
-template <endianness big_endian>
-inline size_t convert(const char32_t *buf, size_t len, char16_t *utf16_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    uint32_t word = data[pos];
-    if ((word & 0xFFFF0000) == 0) {
-      if (word >= 0xD800 && word <= 0xDFFF) {
-        return 0;
-      }
-      // will not generate a surrogate pair
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(uint16_t(word)))
-                            : char16_t(word);
-    } else {
-      // will generate a surrogate pair
-      if (word > 0x10FFFF) {
-        return 0;
-      }
-      word -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-    }
-    pos++;
+  simdutf_warn_unused size_t utf32_length_from_utf16be(
+      const char16_t *buf, size_t len) const noexcept override {
+    return set_best()->utf32_length_from_utf16be(buf, len);
   }
-  return utf16_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-template <endianness big_endian>
-inline result convert_with_errors(const char32_t *buf, size_t len,
-                                  char16_t *utf16_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    uint32_t word = data[pos];
-    if ((word & 0xFFFF0000) == 0) {
-      if (word >= 0xD800 && word <= 0xDFFF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      // will not generate a surrogate pair
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(uint16_t(word)))
-                            : char16_t(word);
-    } else {
-      // will generate a surrogate pair
-      if (word > 0x10FFFF) {
-        return result(error_code::TOO_LARGE, pos);
-      }
-      word -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-    }
-    pos++;
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *buf, size_t len) const noexcept override {
+    return set_best()->utf16_length_from_utf8(buf, len);
   }
-  return result(error_code::SUCCESS, utf16_output - start);
-}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-} // namespace utf32_to_utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf8_length_from_utf32(
+      const char32_t *buf, size_t len) const noexcept override {
+    return set_best()->utf8_length_from_utf32(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-#endif
-/* end file src/scalar/utf32_to_utf16/utf32_to_utf16.h */
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t utf16_length_from_utf32(
+      const char32_t *buf, size_t len) const noexcept override {
+    return set_best()->utf16_length_from_utf32(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-/* begin file src/scalar/utf16_to_utf8/valid_utf16_to_utf8.h */
-#ifndef SIMDUTF_VALID_UTF16_TO_UTF8_H
-#define SIMDUTF_VALID_UTF16_TO_UTF8_H
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *buf, size_t len) const noexcept override {
+    return set_best()->utf32_length_from_utf8(buf, len);
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_utf8 {
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result base64_to_binary(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_handling_options =
+          last_chunk_handling_options::loose) const noexcept override {
+    return set_best()->base64_to_binary(input, length, output, options,
+                                        last_chunk_handling_options);
+  }
 
-template <endianness big_endian>
-inline size_t convert_valid(const char16_t *buf, size_t len,
-                            char *utf8_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 4 ASCII characters
-    if (pos + 4 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if (!match_system(big_endian)) {
-        v = (v >> 8) | (v << (64 - 8));
-      }
-      if ((v & 0xFF80FF80FF80FF80) == 0) {
-        size_t final_pos = pos + 4;
-        while (pos < final_pos) {
-          *utf8_output++ = !match_system(big_endian)
-                               ? char(utf16::swap_bytes(buf[pos]))
-                               : char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *input, size_t length, char *output, base64_options options,
+      last_chunk_handling_options last_chunk_handling_options =
+          last_chunk_handling_options::loose) const noexcept override {
+    return set_best()->base64_to_binary_details(input, length, output, options,
+                                                last_chunk_handling_options);
+  }
 
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xF800) != 0xD800) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((value >> 18) | 0b11110000);
-      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((value & 0b111111) | 0b10000000);
-      pos += 2;
-    }
+  simdutf_warn_unused result base64_to_binary(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_handling_options =
+          last_chunk_handling_options::loose) const noexcept override {
+    return set_best()->base64_to_binary(input, length, output, options,
+                                        last_chunk_handling_options);
   }
-  return utf8_output - start;
-}
 
-} // namespace utf16_to_utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *input, size_t length, char *output,
+      base64_options options,
+      last_chunk_handling_options last_chunk_handling_options =
+          last_chunk_handling_options::loose) const noexcept override {
+    return set_best()->base64_to_binary_details(input, length, output, options,
+                                                last_chunk_handling_options);
+  }
+
+  size_t binary_to_base64(const char *input, size_t length, char *output,
+                          base64_options options) const noexcept override {
+    return set_best()->binary_to_base64(input, length, output, options);
+  }
+#endif // SIMDUTF_FEATURE_BASE64
 
+  simdutf_really_inline
+  detect_best_supported_implementation_on_first_use() noexcept
+      : implementation("best_supported_detector",
+                       "Detects the best supported implementation and sets it",
+                       0) {}
+
+private:
+  const implementation *set_best() const noexcept;
+};
+
+static_assert(std::is_trivially_destructible<
+                  detect_best_supported_implementation_on_first_use>::value,
+              "detect_best_supported_implementation_on_first_use should be "
+              "trivially destructible");
+
+static const std::initializer_list<const implementation *> &
+get_available_implementation_pointers() {
+  static const std::initializer_list<const implementation *>
+      available_implementation_pointers{
+#if SIMDUTF_IMPLEMENTATION_ICELAKE
+          get_icelake_singleton(),
 #endif
-/* end file src/scalar/utf16_to_utf8/valid_utf16_to_utf8.h */
-/* begin file src/scalar/utf16_to_utf8/utf16_to_utf8.h */
-#ifndef SIMDUTF_UTF16_TO_UTF8_H
-#define SIMDUTF_UTF16_TO_UTF8_H
+#if SIMDUTF_IMPLEMENTATION_HASWELL
+          get_haswell_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_WESTMERE
+          get_westmere_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_ARM64
+          get_arm64_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_PPC64
+          get_ppc64_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_RVV
+          get_rvv_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_LSX
+          get_lsx_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_LASX
+          get_lasx_singleton(),
+#endif
+#if SIMDUTF_IMPLEMENTATION_FALLBACK
+          get_fallback_singleton(),
+#endif
+      }; // available_implementation_pointers
+  return available_implementation_pointers;
+}
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_utf8 {
+// So we can return UNSUPPORTED_ARCHITECTURE from the parser when there is no
+// support
+class unsupported_implementation final : public implementation {
+public:
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused int detect_encodings(const char *,
+                                           size_t) const noexcept override {
+    return encoding_type::unspecified;
+  }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
-template <endianness big_endian>
-inline size_t convert(const char16_t *buf, size_t len, char *utf8_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 8 bytes
-    if (pos + 4 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if (!match_system(big_endian)) {
-        v = (v >> 8) | (v << (64 - 8));
-      }
-      if ((v & 0xFF80FF80FF80FF80) == 0) {
-        size_t final_pos = pos + 4;
-        while (pos < final_pos) {
-          *utf8_output++ = !match_system(big_endian)
-                               ? char(utf16::swap_bytes(buf[pos]))
-                               : char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xF800) != 0xD800) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      if (pos + 1 >= len) {
-        return 0;
-      }
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return 0;
-      }
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return 0;
-      }
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((value >> 18) | 0b11110000);
-      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((value & 0b111111) | 0b10000000);
-      pos += 2;
-    }
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool validate_utf8(const char *,
+                                         size_t) const noexcept final override {
+    return false; // Just refuse to validate. Given that we have a fallback
+                  // implementation
+    // it seems unlikely that unsupported_implementation will ever be used. If
+    // it is used, then it will flag all strings as invalid. The alternative is
+    // to return an error_code from which the user has to figure out whether the
+    // string is valid UTF-8... which seems like a lot of work just to handle
+    // the very unlikely case that we have an unsupported implementation. And,
+    // when it does happen (that we have an unsupported implementation), what
+    // are the chances that the programmer has a fallback? Given that *we*
+    // provide the fallback, it implies that the programmer would need a
+    // fallback for our fallback.
+  }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused result validate_utf8_with_errors(
+      const char *, size_t) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_ASCII
+  simdutf_warn_unused bool
+  validate_ascii(const char *, size_t) const noexcept final override {
+    return false;
+  }
+
+  simdutf_warn_unused result validate_ascii_with_errors(
+      const char *, size_t) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+#endif // SIMDUTF_FEATURE_ASCII
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool
+  validate_utf16le(const char16_t *, size_t) const noexcept final override {
+    return false;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused bool
+  validate_utf16be(const char16_t *, size_t) const noexcept final override {
+    return false;
+  }
+
+  simdutf_warn_unused result validate_utf16le_with_errors(
+      const char16_t *, size_t) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+
+  simdutf_warn_unused result validate_utf16be_with_errors(
+      const char16_t *, size_t) const noexcept final override {
+    return result(error_code::OTHER, 0);
   }
-  return utf8_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF16
 
-template <endianness big_endian>
-inline result convert_with_errors(const char16_t *buf, size_t len,
-                                  char *utf8_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *start{utf8_output};
-  while (pos < len) {
-    // try to convert the next block of 8 bytes
-    if (pos + 4 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if (!match_system(big_endian))
-        v = (v >> 8) | (v << (64 - 8));
-      if ((v & 0xFF80FF80FF80FF80) == 0) {
-        size_t final_pos = pos + 4;
-        while (pos < final_pos) {
-          *utf8_output++ = !match_system(big_endian)
-                               ? char(utf16::swap_bytes(buf[pos]))
-                               : char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xFF80) == 0) {
-      // will generate one UTF-8 bytes
-      *utf8_output++ = char(word);
-      pos++;
-    } else if ((word & 0xF800) == 0) {
-      // will generate two UTF-8 bytes
-      // we have 0b110XXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 6) | 0b11000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else if ((word & 0xF800) != 0xD800) {
-      // will generate three UTF-8 bytes
-      // we have 0b1110XXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((word >> 12) | 0b11100000);
-      *utf8_output++ = char(((word >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((word & 0b111111) | 0b10000000);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      if (pos + 1 >= len) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      // will generate four UTF-8 bytes
-      // we have 0b11110XXX 0b10XXXXXX 0b10XXXXXX 0b10XXXXXX
-      *utf8_output++ = char((value >> 18) | 0b11110000);
-      *utf8_output++ = char(((value >> 12) & 0b111111) | 0b10000000);
-      *utf8_output++ = char(((value >> 6) & 0b111111) | 0b10000000);
-      *utf8_output++ = char((value & 0b111111) | 0b10000000);
-      pos += 2;
-    }
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+  simdutf_warn_unused bool
+  validate_utf32(const char32_t *, size_t) const noexcept final override {
+    return false;
   }
-  return result(error_code::SUCCESS, utf8_output - start);
-}
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
-} // namespace utf16_to_utf8
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused result validate_utf32_with_errors(
+      const char32_t *, size_t) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+#endif // SIMDUTF_FEATURE_UTF32
 
-#endif
-/* end file src/scalar/utf16_to_utf8/utf16_to_utf8.h */
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf8(
+      const char *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-/* begin file src/scalar/utf16_to_utf32/valid_utf16_to_utf32.h */
-#ifndef SIMDUTF_VALID_UTF16_TO_UTF32_H
-#define SIMDUTF_VALID_UTF16_TO_UTF32_H
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf16le(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_utf32 {
+  simdutf_warn_unused size_t convert_latin1_to_utf16be(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-template <endianness big_endian>
-inline size_t convert_valid(const char16_t *buf, size_t len,
-                            char32_t *utf32_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xF800) != 0xD800) {
-      // No surrogate pair, extend 16-bit word to 32-bit word
-      *utf32_output++ = char32_t(word);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      *utf32_output++ = char32_t(value);
-      pos += 2;
-    }
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_latin1_to_utf32(
+      const char *, size_t, char32_t *) const noexcept final override {
+    return 0;
   }
-  return utf32_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-} // namespace utf16_to_utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf8_to_latin1(
+      const char *, size_t, char *) const noexcept final override {
+    return 0;
+  }
 
-#endif
-/* end file src/scalar/utf16_to_utf32/valid_utf16_to_utf32.h */
-/* begin file src/scalar/utf16_to_utf32/utf16_to_utf32.h */
-#ifndef SIMDUTF_UTF16_TO_UTF32_H
-#define SIMDUTF_UTF16_TO_UTF32_H
+  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+      const char *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_utf32 {
+  simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+      const char *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-template <endianness big_endian>
-inline size_t convert(const char16_t *buf, size_t len, char32_t *utf32_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xF800) != 0xD800) {
-      // No surrogate pair, extend 16-bit word to 32-bit word
-      *utf32_output++ = char32_t(word);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return 0;
-      }
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return 0;
-      }
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      *utf32_output++ = char32_t(value);
-      pos += 2;
-    }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf8_to_utf16le(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
   }
-  return utf32_output - start;
-}
 
-template <endianness big_endian>
-inline result convert_with_errors(const char16_t *buf, size_t len,
-                                  char32_t *utf32_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    uint16_t word =
-        !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xF800) != 0xD800) {
-      // No surrogate pair, extend 16-bit word to 32-bit word
-      *utf32_output++ = char32_t(word);
-      pos++;
-    } else {
-      // must be a surrogate pair
-      uint16_t diff = uint16_t(word - 0xD800);
-      if (diff > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      if (pos + 1 >= len) {
-        return result(error_code::SURROGATE, pos);
-      } // minimal bound checking
-      uint16_t next_word = !match_system(big_endian)
-                               ? utf16::swap_bytes(data[pos + 1])
-                               : data[pos + 1];
-      uint16_t diff2 = uint16_t(next_word - 0xDC00);
-      if (diff2 > 0x3FF) {
-        return result(error_code::SURROGATE, pos);
-      }
-      uint32_t value = (diff << 10) + diff2 + 0x10000;
-      *utf32_output++ = char32_t(value);
-      pos += 2;
-    }
+  simdutf_warn_unused size_t convert_utf8_to_utf16be(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
   }
-  return result(error_code::SUCCESS, utf32_output - start);
-}
 
-} // namespace utf16_to_utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-#endif
-/* end file src/scalar/utf16_to_utf32/utf16_to_utf32.h */
+  simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-/* begin file src/scalar/utf8_to_utf16/valid_utf8_to_utf16.h */
-#ifndef SIMDUTF_VALID_UTF8_TO_UTF16_H
-#define SIMDUTF_VALID_UTF8_TO_UTF16_H
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_utf16 {
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+      const char *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-template <endianness big_endian>
-inline size_t convert_valid(const char *buf, size_t len,
-                            char16_t *utf16_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    // try to convert the next block of 8 ASCII bytes
-    if (pos + 8 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 8;
-        while (pos < final_pos) {
-          *utf16_output++ = !match_system(big_endian)
-                                ? char16_t(utf16::swap_bytes(buf[pos]))
-                                : char16_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(leading_byte))
-                            : char16_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 1 >= len) {
-        break;
-      } // minimal bound checking
-      uint16_t code_point = uint16_t(((leading_byte & 0b00011111) << 6) |
-                                     (data[pos + 1] & 0b00111111));
-      if (!match_system(big_endian)) {
-        code_point = utf16::swap_bytes(uint16_t(code_point));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 2 >= len) {
-        break;
-      } // minimal bound checking
-      uint16_t code_point = uint16_t(((leading_byte & 0b00001111) << 12) |
-                                     ((data[pos + 1] & 0b00111111) << 6) |
-                                     (data[pos + 2] & 0b00111111));
-      if (!match_system(big_endian)) {
-        code_point = utf16::swap_bytes(uint16_t(code_point));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        break;
-      } // minimal bound checking
-      uint32_t code_point = ((leading_byte & 0b00000111) << 18) |
-                            ((data[pos + 1] & 0b00111111) << 12) |
-                            ((data[pos + 2] & 0b00111111) << 6) |
-                            (data[pos + 3] & 0b00111111);
-      code_point -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-      pos += 4;
-    } else {
-      // we may have a continuation but we do not do error checking
-      return 0;
-    }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf8_to_utf32(
+      const char *, size_t, char32_t *) const noexcept final override {
+    return 0;
   }
-  return utf16_output - start;
-}
 
-} // namespace utf8_to_utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+      const char *, size_t, char32_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-#endif
-/* end file src/scalar/utf8_to_utf16/valid_utf8_to_utf16.h */
-/* begin file src/scalar/utf8_to_utf16/utf8_to_utf16.h */
-#ifndef SIMDUTF_UTF8_TO_UTF16_H
-#define SIMDUTF_UTF8_TO_UTF16_H
+  simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+      const char *, size_t, char32_t *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_utf16 {
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf16le_to_latin1(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
 
-template <endianness big_endian>
-inline size_t convert(const char *buf, size_t len, char16_t *utf16_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *utf16_output++ = !match_system(big_endian)
-                                ? char16_t(utf16::swap_bytes(buf[pos]))
-                                : char16_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
+  simdutf_warn_unused size_t convert_utf16be_to_latin1(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
 
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(leading_byte))
-                            : char16_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      // range check
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if (code_point < 0x80 || 0x7ff < code_point) {
-        return 0;
-      }
-      if (!match_system(big_endian)) {
-        code_point = uint32_t(utf16::swap_bytes(uint16_t(code_point)));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 2 >= len) {
-        return 0;
-      } // minimal bound checking
+  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      // range check
-      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
-                            (data[pos + 1] & 0b00111111) << 6 |
-                            (data[pos + 2] & 0b00111111);
-      if (code_point < 0x800 || 0xffff < code_point ||
-          (0xd7ff < code_point && code_point < 0xe000)) {
-        return 0;
-      }
-      if (!match_system(big_endian)) {
-        code_point = uint32_t(utf16::swap_bytes(uint16_t(code_point)));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        return 0;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
+  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t convert_utf16le_to_utf8(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+
+  simdutf_warn_unused size_t convert_utf16be_to_utf8(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+
+  simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+
+  simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+      const char16_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t convert_utf32_to_latin1(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
+
+  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-      // range check
-      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
-                            (data[pos + 1] & 0b00111111) << 12 |
-                            (data[pos + 2] & 0b00111111) << 6 |
-                            (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff || 0x10ffff < code_point) {
-        return 0;
-      }
-      code_point -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-      pos += 4;
-    } else {
-      return 0;
-    }
+  simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return 0;
   }
-  return utf16_output - start;
-}
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-template <endianness big_endian>
-inline result convert_with_errors(const char *buf, size_t len,
-                                  char16_t *utf16_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *utf16_output++ = !match_system(big_endian)
-                                ? char16_t(utf16::swap_bytes(buf[pos]))
-                                : char16_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf16_output++ = !match_system(big_endian)
-                            ? char16_t(utf16::swap_bytes(leading_byte))
-                            : char16_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 1 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if (code_point < 0x80 || 0x7ff < code_point) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (!match_system(big_endian)) {
-        code_point = uint32_t(utf16::swap_bytes(uint16_t(code_point)));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8, it should become
-      // a single UTF-16 word.
-      if (pos + 2 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf8(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return 0;
+  }
 
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
-                            (data[pos + 1] & 0b00111111) << 6 |
-                            (data[pos + 2] & 0b00111111);
-      if ((code_point < 0x800) || (0xffff < code_point)) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0xd7ff < code_point && code_point < 0xe000) {
-        return result(error_code::SURROGATE, pos);
-      }
-      if (!match_system(big_endian)) {
-        code_point = uint32_t(utf16::swap_bytes(uint16_t(code_point)));
-      }
-      *utf16_output++ = char16_t(code_point);
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
+  simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-      // range check
-      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
-                            (data[pos + 1] & 0b00111111) << 12 |
-                            (data[pos + 2] & 0b00111111) << 6 |
-                            (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0x10ffff < code_point) {
-        return result(error_code::TOO_LARGE, pos);
-      }
-      code_point -= 0x10000;
-      uint16_t high_surrogate = uint16_t(0xD800 + (code_point >> 10));
-      uint16_t low_surrogate = uint16_t(0xDC00 + (code_point & 0x3FF));
-      if (!match_system(big_endian)) {
-        high_surrogate = utf16::swap_bytes(high_surrogate);
-        low_surrogate = utf16::swap_bytes(low_surrogate);
-      }
-      *utf16_output++ = char16_t(high_surrogate);
-      *utf16_output++ = char16_t(low_surrogate);
-      pos += 4;
-    } else {
-      // we either have too many continuation bytes or an invalid leading byte
-      if ((leading_byte & 0b11000000) == 0b10000000) {
-        return result(error_code::TOO_LONG, pos);
-      } else {
-        return result(error_code::HEADER_BITS, pos);
-      }
-    }
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+      const char32_t *, size_t, char *) const noexcept final override {
+    return 0;
   }
-  return result(error_code::SUCCESS, utf16_output - start);
-}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-/**
- * When rewind_and_convert_with_errors is called, we are pointing at 'buf' and
- * we have up to len input bytes left, and we encountered some error. It is
- * possible that the error is at 'buf' exactly, but it could also be in the
- * previous bytes  (up to 3 bytes back).
- *
- * prior_bytes indicates how many bytes, prior to 'buf' may belong to the
- * current memory section and can be safely accessed. We prior_bytes to access
- * safely up to three bytes before 'buf'.
- *
- * The caller is responsible to ensure that len > 0.
- *
- * If the error is believed to have occurred prior to 'buf', the count value
- * contain in the result will be SIZE_T - 1, SIZE_T - 2, or SIZE_T - 3.
- */
-template <endianness endian>
-inline result rewind_and_convert_with_errors(size_t prior_bytes,
-                                             const char *buf, size_t len,
-                                             char16_t *utf16_output) {
-  size_t extra_len{0};
-  // We potentially need to go back in time and find a leading byte.
-  // In theory '3' would be sufficient, but sometimes the error can go back
-  // quite far.
-  size_t how_far_back = prior_bytes;
-  // size_t how_far_back = 3; // 3 bytes in the past + current position
-  // if(how_far_back >= prior_bytes) { how_far_back = prior_bytes; }
-  bool found_leading_bytes{false};
-  // important: it is i <= how_far_back and not 'i < how_far_back'.
-  for (size_t i = 0; i <= how_far_back; i++) {
-    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
-    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
-    if (found_leading_bytes) {
-      if (i > 0 && byte < 128) {
-        // If we had to go back and the leading byte is ascii
-        // then we can stop right away.
-        return result(error_code::TOO_LONG, 0 - i + 1);
-      }
-      buf -= i;
-      extra_len = i;
-      break;
-    }
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t convert_utf32_to_utf16le(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return 0;
   }
-  //
-  // It is possible for this function to return a negative count in its result.
-  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
-  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
-  // unsigned integral type of the result of the sizeof operator
-  //
-  // An unsigned type will simply wrap round arithmetically (well defined).
-  //
-  if (!found_leading_bytes) {
-    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
-    // [....] [continuation] [continuation] [continuation] | [buf is
-    // continuation] Or we possibly have a stream that does not start with a
-    // leading byte.
-    return result(error_code::TOO_LONG, 0 - how_far_back);
+
+  simdutf_warn_unused size_t convert_utf32_to_utf16be(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return 0;
   }
-  result res = convert_with_errors<endian>(buf, len + extra_len, utf16_output);
-  if (res.error) {
-    res.count -= extra_len;
+
+  simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
   }
-  return res;
-}
 
-} // namespace utf8_to_utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-#endif
-/* end file src/scalar/utf8_to_utf16/utf8_to_utf16.h */
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
 
-/* begin file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
-#ifndef SIMDUTF_VALID_UTF8_TO_UTF32_H
-#define SIMDUTF_VALID_UTF8_TO_UTF32_H
+  simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
+      const char32_t *, size_t, char16_t *) const noexcept final override {
+    return 0;
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_utf32 {
+  simdutf_warn_unused size_t convert_utf16le_to_utf32(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return 0;
+  }
 
-inline size_t convert_valid(const char *buf, size_t len,
-                            char32_t *utf32_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    // try to convert the next block of 8 ASCII bytes
-    if (pos + 8 <=
-        len) { // if it is safe to read 8 more bytes, check that they are ascii
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 8;
-        while (pos < final_pos) {
-          *utf32_output++ = char32_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf32_output++ = char32_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        break;
-      } // minimal bound checking
-      *utf32_output++ = char32_t(((leading_byte & 0b00011111) << 6) |
-                                 (data[pos + 1] & 0b00111111));
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8
-      if (pos + 2 >= len) {
-        break;
-      } // minimal bound checking
-      *utf32_output++ = char32_t(((leading_byte & 0b00001111) << 12) |
-                                 ((data[pos + 1] & 0b00111111) << 6) |
-                                 (data[pos + 2] & 0b00111111));
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        break;
-      } // minimal bound checking
-      uint32_t code_word = ((leading_byte & 0b00000111) << 18) |
-                           ((data[pos + 1] & 0b00111111) << 12) |
-                           ((data[pos + 2] & 0b00111111) << 6) |
-                           (data[pos + 3] & 0b00111111);
-      *utf32_output++ = char32_t(code_word);
-      pos += 4;
-    } else {
-      // we may have a continuation but we do not do error checking
-      return 0;
-    }
+  simdutf_warn_unused size_t convert_utf16be_to_utf32(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return 0;
   }
-  return utf32_output - start;
-}
 
-} // namespace utf8_to_utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+  simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-#endif
-/* end file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
-/* begin file src/scalar/utf8_to_utf32/utf8_to_utf32.h */
-#ifndef SIMDUTF_UTF8_TO_UTF32_H
-#define SIMDUTF_UTF8_TO_UTF32_H
+  simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return result(error_code::OTHER, 0);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_utf32 {
+  simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return 0;
+  }
 
-inline size_t convert(const char *buf, size_t len, char32_t *utf32_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *utf32_output++ = char32_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf32_output++ = char32_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      // range check
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if (code_point < 0x80 || 0x7ff < code_point) {
-        return 0;
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8
-      if (pos + 2 >= len) {
-        return 0;
-      } // minimal bound checking
+  simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
+      const char16_t *, size_t, char32_t *) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      // range check
-      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
-                            (data[pos + 1] & 0b00111111) << 6 |
-                            (data[pos + 2] & 0b00111111);
-      if (code_point < 0x800 || 0xffff < code_point ||
-          (0xd7ff < code_point && code_point < 0xe000)) {
-        return 0;
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        return 0;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return 0;
-      }
+#if SIMDUTF_FEATURE_UTF16
+  void change_endianness_utf16(const char16_t *, size_t,
+                               char16_t *) const noexcept final override {}
 
-      // range check
-      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
-                            (data[pos + 1] & 0b00111111) << 12 |
-                            (data[pos + 2] & 0b00111111) << 6 |
-                            (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff || 0x10ffff < code_point) {
-        return 0;
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 4;
-    } else {
-      return 0;
-    }
+  simdutf_warn_unused size_t
+  count_utf16le(const char16_t *, size_t) const noexcept final override {
+    return 0;
   }
-  return utf32_output - start;
-}
 
-inline result convert_with_errors(const char *buf, size_t len,
-                                  char32_t *utf32_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char32_t *start{utf32_output};
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2};
-      if ((v & 0x8080808080808080) == 0) {
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *utf32_output++ = char32_t(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *utf32_output++ = char32_t(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) == 0b11000000) {
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
-      if (code_point < 0x80 || 0x7ff < code_point) {
-        return result(error_code::OVERLONG, pos);
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8
-      if (pos + 2 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
+  simdutf_warn_unused size_t
+  count_utf16be(const char16_t *, size_t) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8
+  simdutf_warn_unused size_t count_utf8(const char *,
+                                        size_t) const noexcept final override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  latin1_length_from_utf8(const char *, size_t) const noexcept override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  simdutf_warn_unused size_t
+  utf8_length_from_latin1(const char *, size_t) const noexcept override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16le(const char16_t *, size_t) const noexcept override {
+    return 0;
+  }
 
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      // range check
-      uint32_t code_point = (leading_byte & 0b00001111) << 12 |
-                            (data[pos + 1] & 0b00111111) << 6 |
-                            (data[pos + 2] & 0b00111111);
-      if (code_point < 0x800 || 0xffff < code_point) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0xd7ff < code_point && code_point < 0xe000) {
-        return result(error_code::SURROGATE, pos);
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 3;
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      if (pos + 3 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 2] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
-      if ((data[pos + 3] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      }
+  simdutf_warn_unused size_t
+  utf8_length_from_utf16be(const char16_t *, size_t) const noexcept override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-      // range check
-      uint32_t code_point = (leading_byte & 0b00000111) << 18 |
-                            (data[pos + 1] & 0b00111111) << 12 |
-                            (data[pos + 2] & 0b00111111) << 6 |
-                            (data[pos + 3] & 0b00111111);
-      if (code_point <= 0xffff) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0x10ffff < code_point) {
-        return result(error_code::TOO_LARGE, pos);
-      }
-      *utf32_output++ = char32_t(code_point);
-      pos += 4;
-    } else {
-      // we either have too many continuation bytes or an invalid leading byte
-      if ((leading_byte & 0b11000000) == 0b10000000) {
-        return result(error_code::TOO_LONG, pos);
-      } else {
-        return result(error_code::HEADER_BITS, pos);
-      }
-    }
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf16le(const char16_t *, size_t) const noexcept override {
+    return 0;
   }
-  return result(error_code::SUCCESS, utf32_output - start);
-}
 
-/**
- * When rewind_and_convert_with_errors is called, we are pointing at 'buf' and
- * we have up to len input bytes left, and we encountered some error. It is
- * possible that the error is at 'buf' exactly, but it could also be in the
- * previous bytes location (up to 3 bytes back).
- *
- * prior_bytes indicates how many bytes, prior to 'buf' may belong to the
- * current memory section and can be safely accessed. We prior_bytes to access
- * safely up to three bytes before 'buf'.
- *
- * The caller is responsible to ensure that len > 0.
- *
- * If the error is believed to have occurred prior to 'buf', the count value
- * contain in the result will be SIZE_T - 1, SIZE_T - 2, or SIZE_T - 3.
- */
-inline result rewind_and_convert_with_errors(size_t prior_bytes,
-                                             const char *buf, size_t len,
-                                             char32_t *utf32_output) {
-  size_t extra_len{0};
-  // We potentially need to go back in time and find a leading byte.
-  size_t how_far_back = 3; // 3 bytes in the past + current position
-  if (how_far_back > prior_bytes) {
-    how_far_back = prior_bytes;
+  simdutf_warn_unused size_t
+  utf32_length_from_utf16be(const char16_t *, size_t) const noexcept override {
+    return 0;
   }
-  bool found_leading_bytes{false};
-  // important: it is i <= how_far_back and not 'i < how_far_back'.
-  for (size_t i = 0; i <= how_far_back; i++) {
-    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
-    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
-    if (found_leading_bytes) {
-      if (i > 0 && byte < 128) {
-        // If we had to go back and the leading byte is ascii
-        // then we can stop right away.
-        return result(error_code::TOO_LONG, 0 - i + 1);
-      }
-      buf -= i;
-      extra_len = i;
-      break;
-    }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  simdutf_warn_unused size_t
+  utf16_length_from_utf8(const char *, size_t) const noexcept override {
+    return 0;
   }
-  //
-  // It is possible for this function to return a negative count in its result.
-  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
-  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
-  // unsigned integral type of the result of the sizeof operator
-  //
-  // An unsigned type will simply wrap round arithmetically (well defined).
-  //
-  if (!found_leading_bytes) {
-    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
-    // [....] [continuation] [continuation] [continuation] | [buf is
-    // continuation] Or we possibly have a stream that does not start with a
-    // leading byte.
-    return result(error_code::TOO_LONG, 0 - how_far_back);
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf8_length_from_utf32(const char32_t *, size_t) const noexcept override {
+    return 0;
   }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-  result res = convert_with_errors(buf, len + extra_len, utf32_output);
-  if (res.error) {
-    res.count -= extra_len;
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf16_length_from_utf32(const char32_t *, size_t) const noexcept override {
+    return 0;
   }
-  return res;
-}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-} // namespace utf8_to_utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  simdutf_warn_unused size_t
+  utf32_length_from_utf8(const char *, size_t) const noexcept override {
+    return 0;
+  }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-#endif
-/* end file src/scalar/utf8_to_utf32/utf8_to_utf32.h */
+#if SIMDUTF_FEATURE_BASE64
+  simdutf_warn_unused result
+  base64_to_binary(const char *, size_t, char *, base64_options,
+                   last_chunk_handling_options) const noexcept override {
+    return result(error_code::OTHER, 0);
+  }
 
-/* begin file src/scalar/latin1_to_utf16/latin1_to_utf16.h */
-#ifndef SIMDUTF_LATIN1_TO_UTF16_H
-#define SIMDUTF_LATIN1_TO_UTF16_H
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char *, size_t, char *, base64_options,
+      last_chunk_handling_options) const noexcept override {
+    return full_result(error_code::OTHER, 0, 0);
+  }
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace latin1_to_utf16 {
+  simdutf_warn_unused result
+  base64_to_binary(const char16_t *, size_t, char *, base64_options,
+                   last_chunk_handling_options) const noexcept override {
+    return result(error_code::OTHER, 0);
+  }
 
-template <endianness big_endian>
-inline size_t convert(const char *buf, size_t len, char16_t *utf16_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
+  simdutf_warn_unused full_result base64_to_binary_details(
+      const char16_t *, size_t, char *, base64_options,
+      last_chunk_handling_options) const noexcept override {
+    return full_result(error_code::OTHER, 0, 0);
+  }
 
-  while (pos < len) {
-    uint16_t word =
-        uint16_t(data[pos]); // extend Latin-1 char to 16-bit Unicode code point
-    *utf16_output++ =
-        char16_t(match_system(big_endian) ? word : utf16::swap_bytes(word));
-    pos++;
+  size_t binary_to_base64(const char *, size_t, char *,
+                          base64_options) const noexcept override {
+    return 0;
   }
+#endif // SIMDUTF_FEATURE_BASE64
 
-  return utf16_output - start;
+  unsupported_implementation()
+      : implementation("unsupported",
+                       "Unsupported CPU (no detected SIMD instructions)", 0) {}
+};
+
+const unsupported_implementation *get_unsupported_singleton() {
+  static const unsupported_implementation unsupported_singleton{};
+  return &unsupported_singleton;
 }
+static_assert(std::is_trivially_destructible<unsupported_implementation>::value,
+              "unsupported_singleton should be trivially destructible");
 
-template <endianness big_endian>
-inline result convert_with_errors(const char *buf, size_t len,
-                                  char16_t *utf16_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char16_t *start{utf16_output};
+size_t available_implementation_list::size() const noexcept {
+  return internal::get_available_implementation_pointers().size();
+}
+const implementation *const *
+available_implementation_list::begin() const noexcept {
+  return internal::get_available_implementation_pointers().begin();
+}
+const implementation *const *
+available_implementation_list::end() const noexcept {
+  return internal::get_available_implementation_pointers().end();
+}
+const implementation *
+available_implementation_list::detect_best_supported() const noexcept {
+  // They are prelisted in priority order, so we just go down the list
+  uint32_t supported_instruction_sets =
+      internal::detect_supported_architectures();
+  for (const implementation *impl :
+       internal::get_available_implementation_pointers()) {
+    uint32_t required_instruction_sets = impl->required_instruction_sets();
+    if ((supported_instruction_sets & required_instruction_sets) ==
+        required_instruction_sets) {
+      return impl;
+    }
+  }
+  return get_unsupported_singleton(); // this should never happen?
+}
 
-  while (pos < len) {
-    uint16_t word =
-        uint16_t(data[pos]); // extend Latin-1 char to 16-bit Unicode code point
-    *utf16_output++ =
-        char16_t(match_system(big_endian) ? word : utf16::swap_bytes(word));
-    pos++;
+const implementation *
+detect_best_supported_implementation_on_first_use::set_best() const noexcept {
+  SIMDUTF_PUSH_DISABLE_WARNINGS
+  SIMDUTF_DISABLE_DEPRECATED_WARNING // Disable CRT_SECURE warning on MSVC:
+                                     // manually verified this is safe
+      char *force_implementation_name = getenv("SIMDUTF_FORCE_IMPLEMENTATION");
+  SIMDUTF_POP_DISABLE_WARNINGS
+
+  if (force_implementation_name) {
+    auto force_implementation =
+        get_available_implementations()[force_implementation_name];
+    if (force_implementation) {
+      return get_active_implementation() = force_implementation;
+    } else {
+      // Note: abort() and stderr usage within the library is forbidden.
+      return get_active_implementation() = get_unsupported_singleton();
+    }
   }
+  return get_active_implementation() =
+             get_available_implementations().detect_best_supported();
+}
 
-  return result(error_code::SUCCESS, utf16_output - start);
+} // namespace internal
+
+/**
+ * The list of available implementations compiled into simdutf.
+ */
+SIMDUTF_DLLIMPORTEXPORT const internal::available_implementation_list &
+get_available_implementations() {
+  static const internal::available_implementation_list
+      available_implementations{};
+  return available_implementations;
 }
 
-} // namespace latin1_to_utf16
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+/**
+ * The active implementation.
+ */
+SIMDUTF_DLLIMPORTEXPORT internal::atomic_ptr<const implementation> &
+get_active_implementation() {
+#if SIMDUTF_SINGLE_IMPLEMENTATION
+  // skip runtime detection
+  static internal::atomic_ptr<const implementation> active_implementation{
+      internal::get_single_implementation()};
+  return active_implementation;
+#else
+  static const internal::detect_best_supported_implementation_on_first_use
+      detect_best_supported_implementation_on_first_use_singleton;
+  static internal::atomic_ptr<const implementation> active_implementation{
+      &detect_best_supported_implementation_on_first_use_singleton};
+  return active_implementation;
+#endif
+}
 
+#if SIMDUTF_SINGLE_IMPLEMENTATION
+const implementation *get_default_implementation() {
+  return internal::get_single_implementation();
+}
+#else
+internal::atomic_ptr<const implementation> &get_default_implementation() {
+  return get_active_implementation();
+}
 #endif
-/* end file src/scalar/latin1_to_utf16/latin1_to_utf16.h */
-/* begin file src/scalar/latin1_to_utf32/latin1_to_utf32.h */
-#ifndef SIMDUTF_LATIN1_TO_UTF32_H
-#define SIMDUTF_LATIN1_TO_UTF32_H
+#define SIMDUTF_GET_CURRENT_IMPLEMENTION
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace latin1_to_utf32 {
+#if SIMDUTF_FEATURE_UTF8
+simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept {
+  return get_default_implementation()->validate_utf8(buf, len);
+}
+simdutf_warn_unused result validate_utf8_with_errors(const char *buf,
+                                                     size_t len) noexcept {
+  return get_default_implementation()->validate_utf8_with_errors(buf, len);
+}
+#endif // SIMDUTF_FEATURE_UTF8
 
-inline size_t convert(const char *buf, size_t len, char32_t *utf32_output) {
-  const unsigned char *data = reinterpret_cast<const unsigned char *>(buf);
-  char32_t *start{utf32_output};
-  for (size_t i = 0; i < len; i++) {
-    *utf32_output++ = (char32_t)data[i];
-  }
-  return utf32_output - start;
+#if SIMDUTF_FEATURE_ASCII
+simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept {
+  return get_default_implementation()->validate_ascii(buf, len);
+}
+simdutf_warn_unused result validate_ascii_with_errors(const char *buf,
+                                                      size_t len) noexcept {
+  return get_default_implementation()->validate_ascii_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
-} // namespace latin1_to_utf32
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_utf8_to_utf16(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf8_to_utf16be(input, length, utf16_output);
+  #else
+  return convert_utf8_to_utf16le(input, length, utf16_output);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-#endif
-/* end file src/scalar/latin1_to_utf32/latin1_to_utf32.h */
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_latin1_to_utf8(const char *buf, size_t len,
+                                                  char *utf8_output) noexcept {
+  return get_default_implementation()->convert_latin1_to_utf8(buf, len,
+                                                              utf8_output);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-/* begin file src/scalar/utf8_to_latin1/utf8_to_latin1.h */
-#ifndef SIMDUTF_UTF8_TO_LATIN1_H
-#define SIMDUTF_UTF8_TO_LATIN1_H
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_latin1_to_utf16le(
+    const char *buf, size_t len, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_latin1_to_utf16le(buf, len,
+                                                                 utf16_output);
+}
+simdutf_warn_unused size_t convert_latin1_to_utf16be(
+    const char *buf, size_t len, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_latin1_to_utf16be(buf, len,
+                                                                 utf16_output);
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_latin1 {
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_latin1_to_utf32(
+    const char *buf, size_t len, char32_t *latin1_output) noexcept {
+  return get_default_implementation()->convert_latin1_to_utf32(buf, len,
+                                                               latin1_output);
+}
+simdutf_warn_unused size_t latin1_length_from_utf32(size_t length) noexcept {
+  return length;
+}
+simdutf_warn_unused size_t utf32_length_from_latin1(size_t length) noexcept {
+  return length;
+}
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-inline size_t convert(const char *buf, size_t len, char *latin_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char *start{latin_output};
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_utf8_to_latin1(
+    const char *buf, size_t len, char *latin1_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_latin1(buf, len,
+                                                              latin1_output);
+}
+simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
+    const char *buf, size_t len, char *latin1_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_latin1_with_errors(
+      buf, len, latin1_output);
+}
+simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+    const char *buf, size_t len, char *latin1_output) noexcept {
+  return get_default_implementation()->convert_valid_utf8_to_latin1(
+      buf, len, latin1_output);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2}; // We are only interested in these bits: 1000 1000
-                           // 1000 1000 .... etc
-      if ((v & 0x8080808080808080) ==
-          0) { // if NONE of these are set, e.g. all of them are zero, then
-               // everything is ASCII
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *latin_output++ = char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_utf8_to_utf16le(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf16le(input, length,
+                                                               utf16_output);
+}
+simdutf_warn_unused size_t convert_utf8_to_utf16be(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf16be(input, length,
+                                                               utf16_output);
+}
+simdutf_warn_unused result convert_utf8_to_utf16_with_errors(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf8_to_utf16be_with_errors(input, length, utf16_output);
+  #else
+  return convert_utf8_to_utf16le_with_errors(input, length, utf16_output);
+  #endif
+}
+simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf16le_with_errors(
+      input, length, utf16_output);
+}
+simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
+    const char *input, size_t length, char16_t *utf16_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf16be_with_errors(
+      input, length, utf16_output);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-    // suppose it is not an all ASCII byte sequence
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *latin_output++ = char(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) ==
-               0b11000000) { // the first three bits indicate:
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        return 0;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      } // checks if the next byte is a valid continuation byte in UTF-8. A
-        // valid continuation byte starts with 10.
-      // range check -
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 |
-          (data[pos + 1] &
-           0b00111111); // assembles the Unicode code point from the two bytes.
-                        // It does this by discarding the leading 110 and 10
-                        // bits from the two bytes, shifting the remaining bits
-                        // of the first byte, and then combining the results
-                        // with a bitwise OR operation.
-      if (code_point < 0x80 || 0xFF < code_point) {
-        return 0; // We only care about the range 129-255 which is Non-ASCII
-                  // latin1 characters. A code_point beneath 0x80 is invalid as
-                  // it is already covered by bytes whose leading bit is zero.
-      }
-      *latin_output++ = char(code_point);
-      pos += 2;
-    } else {
-      return 0;
-    }
-  }
-  return latin_output - start;
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t convert_utf8_to_utf32(
+    const char *input, size_t length, char32_t *utf32_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf32(input, length,
+                                                             utf32_output);
+}
+simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
+    const char *input, size_t length, char32_t *utf32_output) noexcept {
+  return get_default_implementation()->convert_utf8_to_utf32_with_errors(
+      input, length, utf32_output);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused bool validate_utf16(const char16_t *buf,
+                                        size_t len) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return validate_utf16be(buf, len);
+  #else
+  return validate_utf16le(buf, len);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
+                                          size_t len) noexcept {
+  return get_default_implementation()->validate_utf16le(buf, len);
+}
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
+                                          size_t len) noexcept {
+  return get_default_implementation()->validate_utf16be(buf, len);
+}
+simdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf,
+                                                      size_t len) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return validate_utf16be_with_errors(buf, len);
+  #else
+  return validate_utf16le_with_errors(buf, len);
+  #endif
+}
+simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf,
+                                                        size_t len) noexcept {
+  return get_default_implementation()->validate_utf16le_with_errors(buf, len);
+}
+simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf,
+                                                        size_t len) noexcept {
+  return get_default_implementation()->validate_utf16be_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
-inline result convert_with_errors(const char *buf, size_t len,
-                                  char *latin_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
-  size_t pos = 0;
-  char *start{latin_output};
+#if SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused bool validate_utf32(const char32_t *buf,
+                                        size_t len) noexcept {
+  return get_default_implementation()->validate_utf32(buf, len);
+}
+simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf,
+                                                      size_t len) noexcept {
+  return get_default_implementation()->validate_utf32_with_errors(buf, len);
+}
+#endif // SIMDUTF_FEATURE_UTF32
 
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 | v2}; // We are only interested in these bits: 1000 1000
-                           // 1000 1000...etc
-      if ((v & 0x8080808080808080) ==
-          0) { // if NONE of these are set, e.g. all of them are zero, then
-               // everything is ASCII
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *latin_output++ = char(buf[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    // suppose it is not an all ASCII byte sequence
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *latin_output++ = char(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) ==
-               0b11000000) { // the first three bits indicate:
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        return result(error_code::TOO_SHORT, pos);
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return result(error_code::TOO_SHORT, pos);
-      } // checks if the next byte is a valid continuation byte in UTF-8. A
-        // valid continuation byte starts with 10.
-      // range check -
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 |
-          (data[pos + 1] &
-           0b00111111); // assembles the Unicode code point from the two bytes.
-                        // It does this by discarding the leading 110 and 10
-                        // bits from the two bytes, shifting the remaining bits
-                        // of the first byte, and then combining the results
-                        // with a bitwise OR operation.
-      if (code_point < 0x80) {
-        return result(error_code::OVERLONG, pos);
-      }
-      if (0xFF < code_point) {
-        return result(error_code::TOO_LARGE, pos);
-      } // We only care about the range 129-255 which is Non-ASCII latin1
-        // characters
-      *latin_output++ = char(code_point);
-      pos += 2;
-    } else if ((leading_byte & 0b11110000) == 0b11100000) {
-      // We have a three-byte UTF-8
-      return result(error_code::TOO_LARGE, pos);
-    } else if ((leading_byte & 0b11111000) == 0b11110000) { // 0b11110000
-      // we have a 4-byte UTF-8 word.
-      return result(error_code::TOO_LARGE, pos);
-    } else {
-      // we either have too many continuation bytes or an invalid leading byte
-      if ((leading_byte & 0b11000000) == 0b10000000) {
-        return result(error_code::TOO_LONG, pos);
-      }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_valid_utf8_to_utf16(
+    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_valid_utf8_to_utf16be(input, length, utf16_buffer);
+  #else
+  return convert_valid_utf8_to_utf16le(input, length, utf16_buffer);
+  #endif
+}
+simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf8_to_utf16le(
+      input, length, utf16_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+    const char *input, size_t length, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf8_to_utf16be(
+      input, length, utf16_buffer);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-      return result(error_code::HEADER_BITS, pos);
-    }
-  }
-  return result(error_code::SUCCESS, latin_output - start);
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+    const char *input, size_t length, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf8_to_utf32(
+      input, length, utf32_buffer);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-inline result rewind_and_convert_with_errors(size_t prior_bytes,
-                                             const char *buf, size_t len,
-                                             char *latin1_output) {
-  size_t extra_len{0};
-  // We potentially need to go back in time and find a leading byte.
-  // In theory '3' would be sufficient, but sometimes the error can go back
-  // quite far.
-  size_t how_far_back = prior_bytes;
-  // size_t how_far_back = 3; // 3 bytes in the past + current position
-  // if(how_far_back >= prior_bytes) { how_far_back = prior_bytes; }
-  bool found_leading_bytes{false};
-  // important: it is i <= how_far_back and not 'i < how_far_back'.
-  for (size_t i = 0; i <= how_far_back; i++) {
-    unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
-    found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
-    if (found_leading_bytes) {
-      if (i > 0 && byte < 128) {
-        // If we had to go back and the leading byte is ascii
-        // then we can stop right away.
-        return result(error_code::TOO_LONG, 0 - i + 1);
-      }
-      buf -= i;
-      extra_len = i;
-      break;
-    }
-  }
-  //
-  // It is possible for this function to return a negative count in its result.
-  // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
-  // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
-  // unsigned integral type of the result of the sizeof operator
-  //
-  // An unsigned type will simply wrap round arithmetically (well defined).
-  //
-  if (!found_leading_bytes) {
-    // If how_far_back == 3, we may have four consecutive continuation bytes!!!
-    // [....] [continuation] [continuation] [continuation] | [buf is
-    // continuation] Or we possibly have a stream that does not start with a
-    // leading byte.
-    return result(error_code::TOO_LONG, 0 - how_far_back);
-  }
-  result res = convert_with_errors(buf, len + extra_len, latin1_output);
-  if (res.error) {
-    res.count -= extra_len;
-  }
-  return res;
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_utf16_to_utf8(const char16_t *buf,
+                                                 size_t len,
+                                                 char *utf8_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_utf8(buf, len, utf8_buffer);
+  #else
+  return convert_utf16le_to_utf8(buf, len, utf8_buffer);
+  #endif
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-} // namespace utf8_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_utf16_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_latin1(buf, len, latin1_buffer);
+  #else
+  return convert_utf16le_to_latin1(buf, len, latin1_buffer);
+  #endif
+}
+simdutf_warn_unused size_t convert_latin1_to_utf16(
+    const char *buf, size_t len, char16_t *utf16_output) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_latin1_to_utf16be(buf, len, utf16_output);
+  #else
+  return convert_latin1_to_utf16le(buf, len, utf16_output);
+  #endif
+}
+simdutf_warn_unused size_t convert_utf16be_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_latin1(buf, len,
+                                                                 latin1_buffer);
+}
+simdutf_warn_unused size_t convert_utf16le_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_latin1(buf, len,
+                                                                 latin1_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16be_to_latin1(
+      buf, len, latin1_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16le_to_latin1(
+      buf, len, latin1_buffer);
+}
+simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_latin1_with_errors(
+      buf, len, latin1_buffer);
+}
+simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_latin1_with_errors(
+      buf, len, latin1_buffer);
+}
+simdutf_warn_unused size_t latin1_length_from_utf16(size_t length) noexcept {
+  return length;
+}
+simdutf_warn_unused size_t utf16_length_from_latin1(size_t length) noexcept {
+  return length;
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-#endif
-/* end file src/scalar/utf8_to_latin1/utf8_to_latin1.h */
-/* begin file src/scalar/utf16_to_latin1/utf16_to_latin1.h */
-#ifndef SIMDUTF_UTF16_TO_LATIN1_H
-#define SIMDUTF_UTF16_TO_LATIN1_H
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t *buf,
+                                                   size_t len,
+                                                   char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_utf8(buf, len,
+                                                               utf8_buffer);
+}
+simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t *buf,
+                                                   size_t len,
+                                                   char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_utf8(buf, len,
+                                                               utf8_buffer);
+}
+simdutf_warn_unused result convert_utf16_to_utf8_with_errors(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_utf8_with_errors(buf, len, utf8_buffer);
+  #else
+  return convert_utf16le_to_utf8_with_errors(buf, len, utf8_buffer);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_latin1 {
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused result convert_utf16_to_latin1_with_errors(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_latin1_with_errors(buf, len, latin1_buffer);
+  #else
+  return convert_utf16le_to_latin1_with_errors(buf, len, latin1_buffer);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-#include <cstring> // for std::memcpy
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_utf8_with_errors(
+      buf, len, utf8_buffer);
+}
+simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_utf8_with_errors(
+      buf, len, utf8_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16_to_utf8(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_valid_utf16be_to_utf8(buf, len, utf8_buffer);
+  #else
+  return convert_valid_utf16le_to_utf8(buf, len, utf8_buffer);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-template <endianness big_endian>
-inline size_t convert(const char16_t *buf, size_t len, char *latin_output) {
-  if (len == 0) {
-    return 0;
-  }
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *current_write = latin_output;
-  uint16_t word = 0;
-  uint16_t too_large = 0;
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_valid_utf16_to_latin1(
+    const char16_t *buf, size_t len, char *latin1_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_valid_utf16be_to_latin1(buf, len, latin1_buffer);
+  #else
+  return convert_valid_utf16le_to_latin1(buf, len, latin1_buffer);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
-  while (pos < len) {
-    word = !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    too_large |= word;
-    *current_write++ = char(word & 0xFF);
-    pos++;
-  }
-  if ((too_large & 0xFF00) != 0) {
-    return 0;
-  }
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16le_to_utf8(
+      buf, len, utf8_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+    const char16_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16be_to_utf8(
+      buf, len, utf8_buffer);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-  return current_write - latin_output;
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t *buf,
+                                                 size_t len,
+                                                 char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf8(buf, len,
+                                                             utf8_buffer);
+}
+simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
+    const char32_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf8_with_errors(
+      buf, len, utf8_buffer);
 }
+simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+    const char32_t *buf, size_t len, char *utf8_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf32_to_utf8(buf, len,
+                                                                   utf8_buffer);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-template <endianness big_endian>
-inline result convert_with_errors(const char16_t *buf, size_t len,
-                                  char *latin_output) {
-  if (len == 0) {
-    return result(error_code::SUCCESS, 0);
-  }
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *start{latin_output};
-  uint16_t word;
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t convert_utf32_to_utf16(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf32_to_utf16be(buf, len, utf16_buffer);
+  #else
+  return convert_utf32_to_utf16le(buf, len, utf16_buffer);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-  while (pos < len) {
-    if (pos + 16 <= len) { // if it is safe to read 32 more bytes, check that
-                           // they are Latin1
-      uint64_t v1, v2, v3, v4;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      ::memcpy(&v2, data + pos + 4, sizeof(uint64_t));
-      ::memcpy(&v3, data + pos + 8, sizeof(uint64_t));
-      ::memcpy(&v4, data + pos + 12, sizeof(uint64_t));
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_utf32_to_latin1(
+    const char32_t *input, size_t length, char *latin1_output) noexcept {
+  return get_default_implementation()->convert_utf32_to_latin1(input, length,
+                                                               latin1_output);
+}
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-      if (!match_system(big_endian)) {
-        v1 = (v1 >> 8) | (v1 << (64 - 8));
-      }
-      if (!match_system(big_endian)) {
-        v2 = (v2 >> 8) | (v2 << (64 - 8));
-      }
-      if (!match_system(big_endian)) {
-        v3 = (v3 >> 8) | (v3 << (64 - 8));
-      }
-      if (!match_system(big_endian)) {
-        v4 = (v4 >> 8) | (v4 << (64 - 8));
-      }
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t convert_utf32_to_utf16le(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf16le(buf, len,
+                                                                utf16_buffer);
+}
+simdutf_warn_unused size_t convert_utf32_to_utf16be(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf16be(buf, len,
+                                                                utf16_buffer);
+}
+simdutf_warn_unused result convert_utf32_to_utf16_with_errors(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf32_to_utf16be_with_errors(buf, len, utf16_buffer);
+  #else
+  return convert_utf32_to_utf16le_with_errors(buf, len, utf16_buffer);
+  #endif
+}
+simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf16le_with_errors(
+      buf, len, utf16_buffer);
+}
+simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_utf32_to_utf16be_with_errors(
+      buf, len, utf16_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf32_to_utf16(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_valid_utf32_to_utf16be(buf, len, utf16_buffer);
+  #else
+  return convert_valid_utf32_to_utf16le(buf, len, utf16_buffer);
+  #endif
+}
+simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf32_to_utf16le(
+      buf, len, utf16_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
+    const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf32_to_utf16be(
+      buf, len, utf16_buffer);
+}
+simdutf_warn_unused size_t convert_utf16_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_utf32(buf, len, utf32_buffer);
+  #else
+  return convert_utf16le_to_utf32(buf, len, utf32_buffer);
+  #endif
+}
+simdutf_warn_unused size_t convert_utf16le_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_utf32(buf, len,
+                                                                utf32_buffer);
+}
+simdutf_warn_unused size_t convert_utf16be_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_utf32(buf, len,
+                                                                utf32_buffer);
+}
+simdutf_warn_unused result convert_utf16_to_utf32_with_errors(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_utf16be_to_utf32_with_errors(buf, len, utf32_buffer);
+  #else
+  return convert_utf16le_to_utf32_with_errors(buf, len, utf32_buffer);
+  #endif
+}
+simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_utf16le_to_utf32_with_errors(
+      buf, len, utf32_buffer);
+}
+simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_utf16be_to_utf32_with_errors(
+      buf, len, utf32_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return convert_valid_utf16be_to_utf32(buf, len, utf32_buffer);
+  #else
+  return convert_valid_utf16le_to_utf32(buf, len, utf32_buffer);
+  #endif
+}
+simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16le_to_utf32(
+      buf, len, utf32_buffer);
+}
+simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
+    const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept {
+  return get_default_implementation()->convert_valid_utf16be_to_utf32(
+      buf, len, utf32_buffer);
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-      if (((v1 | v2 | v3 | v4) & 0xFF00FF00FF00FF00) == 0) {
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *latin_output++ = !match_system(big_endian)
-                                ? char(utf16::swap_bytes(data[pos]))
-                                : char(data[pos]);
-          pos++;
-        }
-        continue;
-      }
-    }
-    word = !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    if ((word & 0xFF00) == 0) {
-      *latin_output++ = char(word & 0xFF);
-      pos++;
-    } else {
-      return result(error_code::TOO_LARGE, pos);
-    }
-  }
-  return result(error_code::SUCCESS, latin_output - start);
+#if SIMDUTF_FEATURE_UTF16
+void change_endianness_utf16(const char16_t *input, size_t length,
+                             char16_t *output) noexcept {
+  get_default_implementation()->change_endianness_utf16(input, length, output);
+}
+simdutf_warn_unused size_t count_utf16(const char16_t *input,
+                                       size_t length) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return count_utf16be(input, length);
+  #else
+  return count_utf16le(input, length);
+  #endif
+}
+simdutf_warn_unused size_t count_utf16le(const char16_t *input,
+                                         size_t length) noexcept {
+  return get_default_implementation()->count_utf16le(input, length);
+}
+simdutf_warn_unused size_t count_utf16be(const char16_t *input,
+                                         size_t length) noexcept {
+  return get_default_implementation()->count_utf16be(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
-} // namespace utf16_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t count_utf8(const char *input,
+                                      size_t length) noexcept {
+  return get_default_implementation()->count_utf8(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-#endif
-/* end file src/scalar/utf16_to_latin1/utf16_to_latin1.h */
-/* begin file src/scalar/utf32_to_latin1/utf32_to_latin1.h */
-#ifndef SIMDUTF_UTF32_TO_LATIN1_H
-#define SIMDUTF_UTF32_TO_LATIN1_H
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t latin1_length_from_utf8(const char *buf,
+                                                   size_t len) noexcept {
+  return get_default_implementation()->latin1_length_from_utf8(buf, len);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t utf8_length_from_latin1(const char *buf,
+                                                   size_t len) noexcept {
+  return get_default_implementation()->utf8_length_from_latin1(buf, len);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_latin1 {
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t utf8_length_from_utf16(const char16_t *input,
+                                                  size_t length) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return utf8_length_from_utf16be(input, length);
+  #else
+  return utf8_length_from_utf16le(input, length);
+  #endif
+}
+simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t *input,
+                                                    size_t length) noexcept {
+  return get_default_implementation()->utf8_length_from_utf16le(input, length);
+}
+simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t *input,
+                                                    size_t length) noexcept {
+  return get_default_implementation()->utf8_length_from_utf16be(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-inline size_t convert(const char32_t *buf, size_t len, char *latin1_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  char *start = latin1_output;
-  uint32_t utf32_char;
-  size_t pos = 0;
-  uint32_t too_large = 0;
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t utf32_length_from_utf16(const char16_t *input,
+                                                   size_t length) noexcept {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return utf32_length_from_utf16be(input, length);
+  #else
+  return utf32_length_from_utf16le(input, length);
+  #endif
+}
+simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t *input,
+                                                     size_t length) noexcept {
+  return get_default_implementation()->utf32_length_from_utf16le(input, length);
+}
+simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t *input,
+                                                     size_t length) noexcept {
+  return get_default_implementation()->utf32_length_from_utf16be(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-  while (pos < len) {
-    utf32_char = (uint32_t)data[pos];
-    too_large |= utf32_char;
-    *latin1_output++ = (char)(utf32_char & 0xFF);
-    pos++;
-  }
-  if ((too_large & 0xFFFFFF00) != 0) {
-    return 0;
-  }
-  return latin1_output - start;
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t utf16_length_from_utf8(const char *input,
+                                                  size_t length) noexcept {
+  return get_default_implementation()->utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-inline result convert_with_errors(const char32_t *buf, size_t len,
-                                  char *latin1_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  char *start{latin1_output};
-  size_t pos = 0;
-  while (pos < len) {
-    if (pos + 2 <=
-        len) { // if it is safe to read 8 more bytes, check that they are Latin1
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0xFFFFFF00FFFFFF00) == 0) {
-        *latin1_output++ = char(buf[pos]);
-        *latin1_output++ = char(buf[pos + 1]);
-        pos += 2;
-        continue;
-      }
-    }
-    uint32_t utf32_char = data[pos];
-    if ((utf32_char & 0xFFFFFF00) ==
-        0) { // Check if the character can be represented in Latin-1
-      *latin1_output++ = (char)(utf32_char & 0xFF);
-      pos++;
-    } else {
-      return result(error_code::TOO_LARGE, pos);
-    };
-  }
-  return result(error_code::SUCCESS, latin1_output - start);
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t *input,
+                                                  size_t length) noexcept {
+  return get_default_implementation()->utf8_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-} // namespace utf32_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t *input,
+                                                   size_t length) noexcept {
+  return get_default_implementation()->utf16_length_from_utf32(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-#endif
-/* end file src/scalar/utf32_to_latin1/utf32_to_latin1.h */
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+simdutf_warn_unused size_t utf32_length_from_utf8(const char *input,
+                                                  size_t length) noexcept {
+  return get_default_implementation()->utf32_length_from_utf8(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-/* begin file src/scalar/utf8_to_latin1/valid_utf8_to_latin1.h */
-#ifndef SIMDUTF_VALID_UTF8_TO_LATIN1_H
-#define SIMDUTF_VALID_UTF8_TO_LATIN1_H
+#if SIMDUTF_FEATURE_BASE64
+simdutf_warn_unused size_t
+maximal_binary_length_from_base64(const char *input, size_t length) noexcept {
+  return get_default_implementation()->maximal_binary_length_from_base64(
+      input, length);
+}
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf8_to_latin1 {
+simdutf_warn_unused result base64_to_binary(
+    const char *input, size_t length, char *output, base64_options options,
+    last_chunk_handling_options last_chunk_handling_options) noexcept {
+  return get_default_implementation()->base64_to_binary(
+      input, length, output, options, last_chunk_handling_options);
+}
 
-inline size_t convert_valid(const char *buf, size_t len, char *latin_output) {
-  const uint8_t *data = reinterpret_cast<const uint8_t *>(buf);
+simdutf_warn_unused size_t maximal_binary_length_from_base64(
+    const char16_t *input, size_t length) noexcept {
+  return get_default_implementation()->maximal_binary_length_from_base64(
+      input, length);
+}
 
-  size_t pos = 0;
-  char *start{latin_output};
+simdutf_warn_unused result base64_to_binary(
+    const char16_t *input, size_t length, char *output, base64_options options,
+    last_chunk_handling_options last_chunk_handling_options) noexcept {
+  return get_default_implementation()->base64_to_binary(
+      input, length, output, options, last_chunk_handling_options);
+}
 
-  while (pos < len) {
-    // try to convert the next block of 16 ASCII bytes
-    if (pos + 16 <=
-        len) { // if it is safe to read 16 more bytes, check that they are ascii
-      uint64_t v1;
-      ::memcpy(&v1, data + pos, sizeof(uint64_t));
-      uint64_t v2;
-      ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
-      uint64_t v{v1 |
-                 v2}; // We are only interested in these bits: 1000 1000 1000
-                      // 1000, so it makes sense to concatenate everything
-      if ((v & 0x8080808080808080) ==
-          0) { // if NONE of these are set, e.g. all of them are zero, then
-               // everything is ASCII
-        size_t final_pos = pos + 16;
-        while (pos < final_pos) {
-          *latin_output++ = char(buf[pos]);
-          pos++;
+template <typename chartype>
+simdutf_warn_unused result base64_to_binary_safe_impl(
+    const chartype *input, size_t length, char *output, size_t &outlen,
+    base64_options options,
+    last_chunk_handling_options last_chunk_handling_options) noexcept {
+  static_assert(std::is_same<chartype, char>::value ||
+                    std::is_same<chartype, char16_t>::value,
+                "Only char and char16_t are supported.");
+  // The implementation could be nicer, but we expect that most times, the user
+  // will provide us with a buffer that is large enough.
+  size_t max_length = maximal_binary_length_from_base64(input, length);
+  if (outlen >= max_length) {
+    // fast path
+    full_result r = get_default_implementation()->base64_to_binary_details(
+        input, length, output, options, last_chunk_handling_options);
+    if (r.error != error_code::INVALID_BASE64_CHARACTER &&
+        r.error != error_code::BASE64_EXTRA_BITS) {
+      outlen = r.output_count;
+      if (last_chunk_handling_options == stop_before_partial) {
+        if ((r.output_count % 3) != 0) {
+          bool empty_trail = true;
+          for (size_t i = r.input_count; i < length; i++) {
+            if (!scalar::base64::is_ascii_white_space_or_padding(input[i])) {
+              empty_trail = false;
+              break;
+            }
+          }
+          if (empty_trail) {
+            r.input_count = length;
+          }
         }
-        continue;
+        return {r.error, r.input_count};
       }
+      return {r.error, length};
     }
-
-    // suppose it is not an all ASCII byte sequence
-    uint8_t leading_byte = data[pos]; // leading byte
-    if (leading_byte < 0b10000000) {
-      // converting one ASCII byte !!!
-      *latin_output++ = char(leading_byte);
-      pos++;
-    } else if ((leading_byte & 0b11100000) ==
-               0b11000000) { // the first three bits indicate:
-      // We have a two-byte UTF-8
-      if (pos + 1 >= len) {
-        break;
-      } // minimal bound checking
-      if ((data[pos + 1] & 0b11000000) != 0b10000000) {
-        return 0;
-      } // checks if the next byte is a valid continuation byte in UTF-8. A
-        // valid continuation byte starts with 10.
-      // range check -
-      uint32_t code_point =
-          (leading_byte & 0b00011111) << 6 |
-          (data[pos + 1] &
-           0b00111111); // assembles the Unicode code point from the two bytes.
-                        // It does this by discarding the leading 110 and 10
-                        // bits from the two bytes, shifting the remaining bits
-                        // of the first byte, and then combining the results
-                        // with a bitwise OR operation.
-      *latin_output++ = char(code_point);
-      pos += 2;
+    return r;
+  }
+  // The output buffer is maybe too small. We will decode a truncated version of
+  // the input.
+  size_t outlen3 = outlen / 3 * 3; // round down to multiple of 3
+  size_t safe_input = base64_length_from_binary(outlen3, options);
+  full_result r = get_default_implementation()->base64_to_binary_details(
+      input, safe_input, output, options, loose);
+  if (r.error == error_code::INVALID_BASE64_CHARACTER) {
+    return r;
+  }
+  size_t offset =
+      (r.error == error_code::BASE64_INPUT_REMAINDER)
+          ? 1
+          : ((r.output_count % 3) == 0 ? 0 : (r.output_count % 3) + 1);
+  size_t output_index = r.output_count - (r.output_count % 3);
+  size_t input_index = safe_input;
+  // offset is a value that is no larger than 3. We backtrack
+  // by up to offset characters + an undetermined number of
+  // white space characters. It is expected that the next loop
+  // runs at most 3 times + the number of white space characters
+  // in between them, so we are not worried about performance.
+  while (offset > 0 && input_index > 0) {
+    chartype c = input[--input_index];
+    if (scalar::base64::is_ascii_white_space(c)) {
+      // skipping
     } else {
-      // we may have a continuation but we do not do error checking
-      return 0;
+      offset--;
     }
   }
-  return latin_output - start;
+  size_t remaining_out = outlen - output_index;
+  const chartype *tail_input = input + input_index;
+  size_t tail_length = length - input_index;
+  while (tail_length > 0 &&
+         scalar::base64::is_ascii_white_space(tail_input[tail_length - 1])) {
+    tail_length--;
+  }
+  size_t padding_characts = 0;
+  if (tail_length > 0 && tail_input[tail_length - 1] == '=') {
+    tail_length--;
+    padding_characts++;
+    while (tail_length > 0 &&
+           scalar::base64::is_ascii_white_space(tail_input[tail_length - 1])) {
+      tail_length--;
+    }
+    if (tail_length > 0 && tail_input[tail_length - 1] == '=') {
+      tail_length--;
+      padding_characts++;
+    }
+  }
+  // this will advance tail_input and tail_length
+  result rr = scalar::base64::base64_tail_decode_safe(
+      output + output_index, remaining_out, tail_input, tail_length,
+      padding_characts, options, last_chunk_handling_options);
+  outlen = output_index + remaining_out;
+  if (last_chunk_handling_options != stop_before_partial &&
+      rr.error == error_code::SUCCESS && padding_characts > 0) {
+    // additional checks
+    if ((outlen % 3 == 0) || ((outlen % 3) + 1 + padding_characts != 4)) {
+      rr.error = error_code::INVALID_BASE64_CHARACTER;
+    }
+  }
+  if (rr.error == error_code::SUCCESS &&
+      last_chunk_handling_options == stop_before_partial) {
+    if (tail_input > input + input_index) {
+      rr.count = tail_input - input;
+    } else if (r.input_count > 0) {
+      rr.count = r.input_count + rr.count;
+    }
+    return rr;
+  }
+  rr.count += input_index;
+  return rr;
 }
 
-} // namespace utf8_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
-
-#endif
-/* end file src/scalar/utf8_to_latin1/valid_utf8_to_latin1.h */
-/* begin file src/scalar/utf16_to_latin1/valid_utf16_to_latin1.h */
-#ifndef SIMDUTF_VALID_UTF16_TO_LATIN1_H
-#define SIMDUTF_VALID_UTF16_TO_LATIN1_H
+  #if SIMDUTF_ATOMIC_REF
+size_t atomic_binary_to_base64(const char *input, size_t length, char *output,
+                               base64_options options) noexcept {
+  static_assert(std::atomic_ref<char>::required_alignment == 1);
+  size_t retval = 0;
+  // Arbitrary block sizes: 3KB for input, 4KB for output. Total is 7KB.
+  constexpr size_t input_block_size = 1024 * 3;
+  constexpr size_t output_block_size = input_block_size * 4 / 3;
+  std::array<char, input_block_size> inbuf;
+  std::array<char, output_block_size> outbuf;
+
+  // std::atomic_ref<T> must not have a const T, see
+  // https://cplusplus.github.io/LWG/issue3508
+  // we instead provide a mutable input, which is ok since we are only reading
+  // from it.
+  char *mutable_input = const_cast<char *>(input);
+
+  for (size_t i = 0; i < length; i += input_block_size) {
+    const size_t current_block_size = std::min(input_block_size, length - i);
+    // This copy is inefficient.
+    // Under x64, we could use 16-byte aligned loads.
+    // Note that we warn users that the performance might be poor.
+    for (size_t j = 0; j < current_block_size; ++j) {
+      inbuf[j] = std::atomic_ref<char>(mutable_input[i + j])
+                     .load(std::memory_order_relaxed);
+    }
+    const size_t written = binary_to_base64(inbuf.data(), current_block_size,
+                                            outbuf.data(), options);
+    // This copy is inefficient.
+    // Under x64, we could use 16-byte aligned stores.
+    for (size_t j = 0; j < written; ++j) {
+      std::atomic_ref<char>(output[retval + j])
+          .store(outbuf[j], std::memory_order_relaxed);
+    }
+    retval += written;
+  }
+  return retval;
+}
+  #endif // SIMDUTF_ATOMIC_REF
+
+#endif // SIMDUTF_FEATURE_BASE64
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+simdutf_warn_unused size_t convert_latin1_to_utf8_safe(
+    const char *buf, size_t len, char *utf8_output, size_t utf8_len) noexcept {
+  const auto start{utf8_output};
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf16_to_latin1 {
+  while (true) {
+    // convert_latin1_to_utf8 will never write more than input length * 2
+    auto read_len = std::min(len, utf8_len >> 1);
+    if (read_len <= 16) {
+      break;
+    }
 
-template <endianness big_endian>
-inline size_t convert_valid(const char16_t *buf, size_t len,
-                            char *latin_output) {
-  const uint16_t *data = reinterpret_cast<const uint16_t *>(buf);
-  size_t pos = 0;
-  char *start{latin_output};
-  uint16_t word = 0;
+    const auto write_len =
+        simdutf::convert_latin1_to_utf8(buf, read_len, utf8_output);
 
-  while (pos < len) {
-    word = !match_system(big_endian) ? utf16::swap_bytes(data[pos]) : data[pos];
-    *latin_output++ = char(word);
-    pos++;
+    utf8_output += write_len;
+    utf8_len -= write_len;
+    buf += read_len;
+    len -= read_len;
   }
 
-  return latin_output - start;
+  utf8_output +=
+      scalar::latin1_to_utf8::convert_safe(buf, len, utf8_output, utf8_len);
+
+  return utf8_output - start;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-} // namespace utf16_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_BASE64
+simdutf_warn_unused result base64_to_binary_safe(
+    const char *input, size_t length, char *output, size_t &outlen,
+    base64_options options,
+    last_chunk_handling_options last_chunk_handling_options) noexcept {
+  return base64_to_binary_safe_impl<char>(input, length, output, outlen,
+                                          options, last_chunk_handling_options);
+}
+simdutf_warn_unused result base64_to_binary_safe(
+    const char16_t *input, size_t length, char *output, size_t &outlen,
+    base64_options options,
+    last_chunk_handling_options last_chunk_handling_options) noexcept {
+  return base64_to_binary_safe_impl<char16_t>(
+      input, length, output, outlen, options, last_chunk_handling_options);
+}
 
-#endif
-/* end file src/scalar/utf16_to_latin1/valid_utf16_to_latin1.h */
-/* begin file src/scalar/utf32_to_latin1/valid_utf32_to_latin1.h */
-#ifndef SIMDUTF_VALID_UTF32_TO_LATIN1_H
-#define SIMDUTF_VALID_UTF32_TO_LATIN1_H
+simdutf_warn_unused size_t
+base64_length_from_binary(size_t length, base64_options options) noexcept {
+  return get_default_implementation()->base64_length_from_binary(length,
+                                                                 options);
+}
 
-namespace simdutf {
-namespace scalar {
-namespace {
-namespace utf32_to_latin1 {
+size_t binary_to_base64(const char *input, size_t length, char *output,
+                        base64_options options) noexcept {
+  return get_default_implementation()->binary_to_base64(input, length, output,
+                                                        options);
+}
+#endif // SIMDUTF_FEATURE_BASE64
 
-inline size_t convert_valid(const char32_t *buf, size_t len,
-                            char *latin1_output) {
-  const uint32_t *data = reinterpret_cast<const uint32_t *>(buf);
-  char *start = latin1_output;
-  uint32_t utf32_char;
-  size_t pos = 0;
+#if SIMDUTF_FEATURE_DETECT_ENCODING
+simdutf_warn_unused simdutf::encoding_type
+autodetect_encoding(const char *buf, size_t length) noexcept {
+  return get_default_implementation()->autodetect_encoding(buf, length);
+}
 
-  while (pos < len) {
-    utf32_char = (uint32_t)data[pos];
+simdutf_warn_unused int detect_encodings(const char *buf,
+                                         size_t length) noexcept {
+  return get_default_implementation()->detect_encodings(buf, length);
+}
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
-    if (pos + 2 <=
-        len) { // if it is safe to read 8 more bytes, check that they are Latin1
-      uint64_t v;
-      ::memcpy(&v, data + pos, sizeof(uint64_t));
-      if ((v & 0xFFFFFF00FFFFFF00) == 0) {
-        *latin1_output++ = char(buf[pos]);
-        *latin1_output++ = char(buf[pos + 1]);
-        pos += 2;
-        continue;
-      } else {
-        // output can not be represented in latin1
-        return 0;
-      }
-    }
-    if ((utf32_char & 0xFFFFFF00) == 0) {
-      *latin1_output++ = char(utf32_char);
-    } else {
-      // output can not be represented in latin1
-      return 0;
-    }
-    pos++;
-  }
-  return latin1_output - start;
+const implementation *builtin_implementation() {
+  static const implementation *builtin_impl =
+      get_available_implementations()[SIMDUTF_STRINGIFY(
+          SIMDUTF_BUILTIN_IMPLEMENTATION)];
+  return builtin_impl;
 }
 
-} // namespace utf32_to_latin1
-} // unnamed namespace
-} // namespace scalar
-} // namespace simdutf
+#if SIMDUTF_FEATURE_UTF8
+simdutf_warn_unused size_t trim_partial_utf8(const char *input, size_t length) {
+  return scalar::utf8::trim_partial_utf8(input, length);
+}
+#endif // SIMDUTF_FEATURE_UTF8
 
-#endif
-/* end file src/scalar/utf32_to_latin1/valid_utf32_to_latin1.h */
+#if SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused size_t trim_partial_utf16be(const char16_t *input,
+                                                size_t length) {
+  return scalar::utf16::trim_partial_utf16<BIG>(input, length);
+}
+
+simdutf_warn_unused size_t trim_partial_utf16le(const char16_t *input,
+                                                size_t length) {
+  return scalar::utf16::trim_partial_utf16<LITTLE>(input, length);
+}
+
+simdutf_warn_unused size_t trim_partial_utf16(const char16_t *input,
+                                              size_t length) {
+  #if SIMDUTF_IS_BIG_ENDIAN
+  return trim_partial_utf16be(input, length);
+  #else
+  return trim_partial_utf16le(input, length);
+  #endif
+}
+#endif // SIMDUTF_FEATURE_UTF16
+
+} // namespace simdutf
+/* end file src/implementation.cpp */
 
 SIMDUTF_PUSH_DISABLE_WARNINGS
 SIMDUTF_DISABLE_UNDESIRED_WARNINGS
@@ -16378,26 +17397,16 @@ namespace {
 #endif
 using namespace simd;
 
+#if SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    SIMDUTF_FEATURE_UTF8
 simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   simd8<uint8_t> bits = input.reduce_or();
   return bits.max_val() < 0b10000000u;
 }
+#endif // SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // SIMDUTF_FEATURE_UTF8
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<bool> is_second_byte = prev1 >= uint8_t(0b11000000u);
-  simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
-  simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
-  // Use ^ instead of | for is_*_byte, because ^ is commutative, and the caller
-  // is using ^ as well. This will work fine because we only have to report
-  // errors for cases with 0-1 lead bytes. Multiple lead bytes implies 2
-  // overlapping multibyte characters, and if that happens, there is guaranteed
-  // to be at least *one* lead byte that is part of only 1 other multibyte
-  // character. The error will be detected there.
-  return is_second_byte ^ is_third_byte ^ is_fourth_byte;
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -16405,17 +17414,19 @@ must_be_2_3_continuation(const simd8<uint8_t> prev2,
   simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
   return is_third_byte ^ is_fourth_byte;
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32)
 // common functions for utf8 conversions
 simdutf_really_inline uint16x4_t convert_utf8_3_byte_to_utf16(uint8x16_t in) {
   // Low half contains  10cccccc|1110aaaa
   // High half contains 10bbbbbb|10bbbbbb
-#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+  #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
   const uint8x16_t sh = simdutf_make_uint8x16_t(0, 2, 3, 5, 6, 8, 9, 11, 1, 1,
                                                 4, 4, 7, 7, 10, 10);
-#else
+  #else
   const uint8x16_t sh = {0, 2, 3, 5, 6, 8, 9, 11, 1, 1, 4, 4, 7, 7, 10, 10};
-#endif
+  #endif
   uint8x16_t perm = vqtbl1q_u8(in, sh);
   // Split into half vectors.
   // 10cccccc|1110aaaa
@@ -16482,7 +17493,10 @@ convert_utf8_1_to_2_byte_to_utf16(uint8x16_t in, size_t shufutf8_idx) {
   uint16x8_t composed = vsraq_n_u16(ascii, highbyte, 2);
   return composed;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32)
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/arm64/arm_validate_utf16.cpp */
 template <endianness big_endian>
 const char16_t *arm_validate_utf16(const char16_t *input, size_t size) {
@@ -16628,6 +17642,8 @@ const result arm_validate_utf16_with_errors(const char16_t *input,
   return result(error_code::SUCCESS, input - start);
 }
 /* end file src/arm64/arm_validate_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/arm64/arm_validate_utf32le.cpp */
 
 const char32_t *arm_validate_utf32le(const char32_t *input, size_t size) {
@@ -16695,7 +17711,9 @@ const result arm_validate_utf32le_with_errors(const char32_t *input,
   return result(error_code::SUCCESS, input - start);
 }
 /* end file src/arm64/arm_validate_utf32le.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_latin1_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char *, char16_t *>
@@ -16722,6 +17740,8 @@ arm_convert_latin1_to_utf16(const char *buf, size_t len,
   return std::make_pair(buf, utf16_output);
 }
 /* end file src/arm64/arm_convert_latin1_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_latin1_to_utf32.cpp */
 std::pair<const char *, char32_t *>
 arm_convert_latin1_to_utf32(const char *buf, size_t len,
@@ -16748,6 +17768,8 @@ arm_convert_latin1_to_utf32(const char *buf, size_t len,
   return std::make_pair(buf, utf32_output);
 }
 /* end file src/arm64/arm_convert_latin1_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_latin1_to_utf8.cpp */
 /*
   Returns a pair: the first unprocessed byte from buf and utf8_output
@@ -16820,7 +17842,9 @@ arm_convert_latin1_to_utf8(const char *latin1_input, size_t len,
   return std::make_pair(latin1_input, reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/arm64/arm_convert_latin1_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_utf8_to_latin1.cpp */
 // Convert up to 16 bytes from utf8 to utf16 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -16892,6 +17916,8 @@ size_t convert_masked_utf8_to_latin1(const char *input,
   return consumed;
 }
 /* end file src/arm64/arm_convert_utf8_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/arm64/arm_convert_utf8_to_utf16.cpp */
 // Convert up to 16 bytes from utf8 to utf16 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -17080,8 +18106,33 @@ size_t convert_masked_utf8_to_utf16(const char *input,
       for (int k = 0; k < 6; k++) {
         utf16_output[k] = buffer[k];
       } // the loop might compiler to a couple of instructions.
-      utf16_output += 6; // We wrote 3 32-bit surrogate pairs.
-      return 12;         // We consumed 12 bytes.
+      // We need some validation. See
+      // https://github.com/simdutf/simdutf/pull/631
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+      uint8x16_t expected_mask = simdutf_make_uint8x16_t(
+          0xf8, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0,
+          0xc0, 0x0, 0x0, 0x0, 0x0);
+#else
+      uint8x16_t expected_mask = {0xf8, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0,
+                                  0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xc0,
+                                  0x0,  0x0,  0x0,  0x0};
+#endif
+#ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
+      uint8x16_t expected = simdutf_make_uint8x16_t(
+          0xf0, 0x80, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80, 0xf0, 0x80, 0x80,
+          0x80, 0x0, 0x0, 0x0, 0x0);
+#else
+      uint8x16_t expected = {0xf0, 0x80, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80,
+                             0xf0, 0x80, 0x80, 0x80, 0x0,  0x0,  0x0,  0x0};
+#endif
+      uint8x16_t check = vceqq_u8(vandq_u8(in, expected_mask), expected);
+      bool correct = (vminvq_u32(vreinterpretq_u32_u8(check)) == 0xFFFFFFFF);
+      // The validation is just three instructions and it is not on a critical
+      // path.
+      if (correct) {
+        utf16_output += 6; // We wrote 3 32-bit surrogate pairs.
+      }
+      return 12; // We consumed 12 bytes.
     }
     // 3 1-4 byte sequences
     uint8x16_t sh = vld1q_u8(reinterpret_cast<const uint8_t *>(
@@ -17182,6 +18233,8 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   }
 }
 /* end file src/arm64/arm_convert_utf8_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/arm64/arm_convert_utf8_to_utf32.cpp */
 // Convert up to 12 bytes from utf8 to utf32 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -17363,7 +18416,9 @@ size_t convert_masked_utf8_to_utf32(const char *input,
   }
 }
 /* end file src/arm64/arm_convert_utf8_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_utf16_to_latin1.cpp */
 
 template <endianness big_endian>
@@ -17413,9 +18468,8 @@ arm_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     } else {
       // Let us do a scalar fallback.
       for (int k = 0; k < 8; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if (word <= 0xff) {
           *latin1_output++ = char(word);
         } else {
@@ -17429,6 +18483,8 @@ arm_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/arm64/arm_convert_utf16_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/arm64/arm_convert_utf16_to_utf32.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -17520,16 +18576,15 @@ arm_convert_utf16_to_utf32(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -17593,16 +18648,15 @@ arm_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -17622,6 +18676,8 @@ arm_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char32_t *>(utf32_output));
 }
 /* end file src/arm64/arm_convert_utf16_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF8
 /* begin file src/arm64/arm_convert_utf16_to_utf8.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -17899,9 +18955,8 @@ arm_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -17915,7 +18970,7 @@ arm_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -18171,9 +19226,8 @@ arm_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -18187,7 +19241,7 @@ arm_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -18211,7 +19265,9 @@ arm_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/arm64/arm_convert_utf16_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/arm64/arm_base64.cpp */
 /**
  * References and further reading:
@@ -18540,7 +19596,7 @@ void base64_decode_block(char *out, const char *src) {
   vst3q_u8((uint8_t *)out, outvec);
 }
 
-template <bool base64_url, typename char_type>
+template <bool base64_url, bool ignore_garbage, typename char_type>
 full_result
 compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                        base64_options options,
@@ -18571,7 +19627,13 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -18592,7 +19654,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
       bool error = false;
       uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
       if (badcharmask) {
-        if (error) {
+        if (error && !ignore_garbage) {
           src -= 64;
           while (src < srcend && scalar::base64::is_eight_byte(*src) &&
                  to_base64[uint8_t(*src)] <= 64) {
@@ -18636,7 +19698,8 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     while ((bufferptr - buffer_start) % 64 != 0 && src < srcend) {
       uint8_t val = to_base64[uint8_t(*src)];
       *bufferptr = char(val);
-      if (!scalar::base64::is_eight_byte(*src) || val > 64) {
+      if ((!scalar::base64::is_eight_byte(*src) || val > 64) &&
+          !ignore_garbage) {
         return {error_code::INVALID_BASE64_CHARACTER, size_t(src - srcinit),
                 size_t(dst - dstinit)};
       }
@@ -18656,7 +19719,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 4);
 
       dst += 3;
@@ -18668,7 +19731,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 3);
 
       dst += 3;
@@ -18678,8 +19741,14 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     // backtrack
     int leftover = int(bufferptr - buffer_start);
     while (leftover > 0) {
-      while (to_base64[uint8_t(*(src - 1))] == 64) {
-        src--;
+      if (!ignore_garbage) {
+        while (to_base64[uint8_t(*(src - 1))] == 64) {
+          src--;
+        }
+      } else {
+        while (to_base64[uint8_t(*(src - 1))] >= 64) {
+          src--;
+        }
       }
       src--;
       leftover--;
@@ -18696,7 +19765,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
       r.output_count += size_t(dst - dstinit);
     }
     if (last_chunk_options != stop_before_partial &&
-        r.error == error_code::SUCCESS && equalsigns > 0) {
+        r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
       // additional checks
       if ((r.output_count % 3 == 0) ||
           ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -18706,7 +19775,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     }
     return r;
   }
-  if (equalsigns > 0) {
+  if (equalsigns > 0 && !ignore_garbage) {
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -18715,6 +19784,8 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/arm64/arm_base64.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/arm64/arm_convert_utf32_to_latin1.cpp */
 std::pair<const char32_t *, char *>
 arm_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -18777,6 +19848,8 @@ arm_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/arm64/arm_convert_utf32_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_UTF16
 /* begin file src/arm64/arm_convert_utf32_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
@@ -18930,6 +20003,8 @@ arm_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char16_t *>(utf16_output));
 }
 /* end file src/arm64/arm_convert_utf32_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_UTF8
 /* begin file src/arm64/arm_convert_utf32_to_utf8.cpp */
 std::pair<const char32_t *, char *>
 arm_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_out) {
@@ -19437,10 +20512,12 @@ arm_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/arm64/arm_convert_utf32_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_UTF8
 
 } // unnamed namespace
 } // namespace arm64
 } // namespace simdutf
+
 /* begin file src/generic/buf_block_reader.h */
 namespace simdutf {
 namespace arm64 {
@@ -19552,6 +20629,7 @@ simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance() {
 } // namespace arm64
 } // namespace simdutf
 /* end file src/generic/buf_block_reader.h */
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
 namespace simdutf {
 namespace arm64 {
@@ -19858,9 +20936,22 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+} // namespace utf8_validation
+} // unnamed namespace
+} // namespace arm64
+} // namespace simdutf
+/* end file src/generic/utf8_validation/utf8_validator.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/generic/ascii_validation.h */
+namespace simdutf {
+namespace arm64 {
+namespace {
+namespace ascii_validation {
+
+bool generic_validate_ascii(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   uint8_t blocks[64]{};
   simd::simd8x64<uint8_t> running_or(blocks);
   while (reader.has_full_block()) {
@@ -19875,14 +20966,8 @@ bool generic_validate_ascii(const uint8_t *input, size_t length) {
   return running_or.is_ascii();
 }
 
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+result generic_validate_ascii_with_errors(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   size_t count{0};
   while (reader.has_full_block()) {
     simd::simd8x64<uint8_t> in(reader.full_block());
@@ -19907,19 +20992,15 @@ result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
   }
 }
 
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-} // namespace utf8_validation
+} // namespace ascii_validation
 } // unnamed namespace
 } // namespace arm64
 } // namespace simdutf
-/* end file src/generic/utf8_validation/utf8_validator.h */
-// transcoding from UTF-8 to UTF-16
+/* end file src/generic/ascii_validation.h */
+#endif // SIMDUTF_FEATURE_ASCII
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  // transcoding from UTF-8 to UTF-16
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20254,7 +21335,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20330,9 +21410,10 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace arm64
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
-// transcoding from UTF-8 to UTF-32
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  // transcoding from UTF-8 to UTF-32
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20653,7 +21734,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20697,7 +21777,9 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace arm64
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 // other functions
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/generic/utf16.h */
 namespace simdutf {
 namespace arm64 {
@@ -20773,8 +21855,9 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace arm64
 } // namespace simdutf
 /* end file src/generic/utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/generic/utf8.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20814,9 +21897,10 @@ simdutf_really_inline size_t utf16_length_from_utf8(const char *in,
 } // namespace arm64
 } // namespace simdutf
 /* end file src/generic/utf8.h */
-// transcoding from UTF-8 to Latin 1
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  // transcoding from UTF-8 to Latin 1
 /* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -20975,6 +22059,9 @@ struct validating_transcoder {
         uint64_t utf8_continuation_mask =
             input.lt(-65 + 1); // -64 is 1100 0000 in twos complement. Note: in
                                // this case, we also have ASCII to account for.
+        if (utf8_continuation_mask & 1) {
+          return 0; // error
+        }
         uint64_t utf8_leading_mask = ~utf8_continuation_mask;
         uint64_t utf8_end_of_code_point_mask = utf8_leading_mask >> 1;
         // We process in blocks of up to 12 bytes except possibly
@@ -21132,7 +22219,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 /* begin file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
 namespace simdutf {
 namespace arm64 {
 namespace {
@@ -21212,8 +22298,7 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 } // namespace simdutf
   // namespace simdutf
 /* end file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
-// placeholder scalars
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
 //
 // Implementation-specific overrides
@@ -21221,6 +22306,7 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 namespace simdutf {
 namespace arm64 {
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -21247,27 +22333,35 @@ implementation::detect_encodings(const char *input,
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return arm64::utf8_validation::generic_validate_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return arm64::utf8_validation::generic_validate_utf8_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
-  return arm64::utf8_validation::generic_validate_ascii(buf, len);
+  return arm64::ascii_validation::generic_validate_ascii(buf, len);
 }
 
 simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
-  return arm64::utf8_validation::generic_validate_ascii_with_errors(buf, len);
+  return arm64::ascii_validation::generic_validate_ascii_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -21283,7 +22377,9 @@ implementation::validate_utf16le(const char16_t *buf,
     return false;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -21328,7 +22424,9 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -21342,7 +22440,9 @@ implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
     return false;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -21357,7 +22457,9 @@ simdutf_warn_unused result implementation::validate_utf32_with_errors(
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char *, char *> ret =
@@ -21371,7 +22473,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char *, char16_t *> ret =
@@ -21399,7 +22503,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char *, char32_t *> ret =
@@ -21412,7 +22518,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   utf8_to_latin1::validating_transcoder converter;
@@ -21429,13 +22537,17 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return arm64::utf8_to_latin1::convert_valid(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
   return converter.convert<endianness::LITTLE>(buf, len, utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16be(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
@@ -21466,7 +22578,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return utf8_to_utf16::convert_valid<endianness::BIG>(input, size,
                                                        utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   utf8_to_utf32::validating_transcoder converter;
@@ -21478,12 +22592,16 @@ simdutf_warn_unused result implementation::convert_utf8_to_utf32_with_errors(
   utf8_to_utf32::validating_transcoder converter;
   return converter.convert_with_errors(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -21591,7 +22709,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: implement a custom function.
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -21697,7 +22817,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -21744,7 +22866,9 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
       utf8_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char16_t *, char32_t *> ret =
@@ -21840,7 +22964,9 @@ simdutf_warn_unused result implementation::convert_utf16be_to_utf32_with_errors(
       utf32_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -21901,13 +23027,17 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
   }
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   // optimization opportunity: implement a custom function.
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -22015,7 +23145,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   return convert_utf16be_to_utf32(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -22031,27 +23163,23 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return scalar::utf16::latin1_length_from_utf16(length);
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return scalar::utf32::latin1_length_from_utf32(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t length) const noexcept {
   // See
@@ -22074,7 +23202,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return result + (length / lanes) * lanes +
          scalar::latin1::utf8_length_from_latin1((const char *)simd_end, rem);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::LITTLE>(input, length);
@@ -22084,17 +23214,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf16_length_from_latin1(length);
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf32_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::LITTLE>(input, length);
@@ -22104,12 +23226,16 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const uint32x4_t v_7f = vmovq_n_u32((uint32_t)0x7f);
@@ -22151,7 +23277,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
   return count +
          scalar::utf32::utf8_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const uint32x4_t v_ffff = vmovq_n_u32((uint32_t)0xffff);
@@ -22172,65 +23300,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -22238,6 +23403,7 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
                                         base64_options options) const noexcept {
   return encode_base64(output, input, length, options);
 }
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // namespace arm64
 } // namespace simdutf
@@ -22253,19 +23419,10 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
 // #define SIMDUTF_IMPLEMENTATION fallback
 /* end file src/simdutf/fallback/begin.h */
 
-
-
-
-
-
-
-
-#include <cstdint>
-#include <cstring>
-
 namespace simdutf {
 namespace fallback {
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -22274,8 +23431,8 @@ implementation::detect_encodings(const char *input,
   if (bom_encoding != encoding_type::unspecified) {
     return bom_encoding;
   }
-  // todo: reimplement as a one-pass algorithm.
   int out = 0;
+  // todo: reimplement as a one-pass algorithm.
   if (validate_utf8(input, length)) {
     out |= encoding_type::UTF8;
   }
@@ -22292,17 +23449,23 @@ implementation::detect_encodings(const char *input,
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return scalar::utf8::validate(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return scalar::utf8::validate_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
   return scalar::ascii::validate(buf, len);
@@ -22312,13 +23475,17 @@ simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
   return scalar::ascii::validate_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
   return scalar::utf16::validate<endianness::LITTLE>(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -22334,22 +23501,30 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
     const char16_t *buf, size_t len) const noexcept {
   return scalar::utf16::validate_with_errors<endianness::BIG>(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
   return scalar::utf32::validate(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
   return scalar::utf32::validate_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   return scalar::latin1_to_utf8::convert(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   return scalar::latin1_to_utf16::convert<endianness::LITTLE>(buf, len,
@@ -22361,12 +23536,16 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   return scalar::latin1_to_utf16::convert<endianness::BIG>(buf, len,
                                                            utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   return scalar::latin1_to_utf32::convert(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return scalar::utf8_to_latin1::convert(buf, len, latin1_output);
@@ -22381,7 +23560,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return scalar::utf8_to_latin1::convert_valid(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   return scalar::utf8_to_utf16::convert<endianness::LITTLE>(buf, len,
@@ -22417,7 +23598,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return scalar::utf8_to_utf16::convert_valid<endianness::BIG>(buf, len,
                                                                utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   return scalar::utf8_to_utf32::convert(buf, len, utf32_output);
@@ -22432,7 +23615,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return scalar::utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   return scalar::utf16_to_latin1::convert<endianness::LITTLE>(buf, len,
@@ -22470,7 +23655,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_latin1(
   return scalar::utf16_to_latin1::convert_valid<endianness::BIG>(buf, len,
                                                                  latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return scalar::utf16_to_utf8::convert<endianness::LITTLE>(buf, len,
@@ -22505,7 +23692,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
   return scalar::utf16_to_utf8::convert_valid<endianness::BIG>(buf, len,
                                                                utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   return scalar::utf32_to_latin1::convert(buf, len, latin1_output);
@@ -22520,7 +23709,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   return scalar::utf32_to_latin1::convert_valid(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   return scalar::utf32_to_utf8::convert(buf, len, utf8_output);
@@ -22535,7 +23726,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   return scalar::utf32_to_utf8::convert_valid(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   return scalar::utf32_to_utf16::convert<endianness::LITTLE>(buf, len,
@@ -22607,7 +23800,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
   return scalar::utf16_to_utf32::convert_valid<endianness::BIG>(buf, len,
                                                                 utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -22623,27 +23818,23 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return scalar::utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   return scalar::utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return scalar::utf8::count_code_points(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return scalar::utf16::latin1_length_from_utf16(length);
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return length;
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t length) const noexcept {
   size_t answer = length;
@@ -22674,7 +23865,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   }
   return answer;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return scalar::utf16::utf8_length_from_utf16<endianness::LITTLE>(input,
@@ -22685,7 +23878,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return scalar::utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return scalar::utf16::utf32_length_from_utf16<endianness::LITTLE>(input,
@@ -22696,45 +23891,43 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return scalar::utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf16_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return scalar::utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   return scalar::utf32::utf8_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   return scalar::utf32::utf16_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf32_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return scalar::utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -22757,7 +23950,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -22765,7 +23964,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -22777,6 +23976,9 @@ simdutf_warn_unused result implementation::base64_to_binary(
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -22799,7 +24001,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -22807,7 +24015,7 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   full_result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.output_count % 3 == 0) ||
         ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -22817,14 +24025,12 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -22847,7 +24053,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -22855,7 +24067,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -22867,6 +24079,9 @@ simdutf_warn_unused result implementation::base64_to_binary(
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -22889,7 +24104,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -22897,7 +24118,7 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   full_result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.output_count % 3 == 0) ||
         ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -22907,16 +24128,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
-}
-
 size_t implementation::binary_to_base64(const char *input, size_t length,
                                         char *output,
                                         base64_options options) const noexcept {
   return scalar::base64::tail_encode_base64(output, input, length, options);
 }
+#endif // SIMDUTF_FEATURE_BASE64
+
 } // namespace fallback
 } // namespace simdutf
 
@@ -22926,7 +24144,8 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
 #endif
 #if SIMDUTF_IMPLEMENTATION_ICELAKE
 /* begin file src/icelake/implementation.cpp */
-
+#include <tuple>
+#include <utility>
 
 /* begin file src/simdutf/icelake/begin.h */
 // redefining SIMDUTF_IMPLEMENTATION to "icelake"
@@ -22951,6 +24170,187 @@ namespace {
 #ifndef SIMDUTF_ICELAKE_H
   #error "icelake.h must be included"
 #endif
+using namespace simd;
+
+/* begin file src/icelake/icelake_macros.inl.cpp */
+
+/*
+    This upcoming macro (SIMDUTF_ICELAKE_TRANSCODE16) takes 16 + 4 bytes (of a
+   UTF-8 string) and loads all possible 4-byte substring into an AVX512
+   register.
+
+    For example if we have bytes abcdefgh... we create following 32-bit lanes
+
+    [abcd|bcde|cdef|defg|efgh|...]
+     ^                          ^
+     byte 0 of reg              byte 63 of reg
+*/
+/** pshufb
+        # lane{0,1,2} have got bytes: [  0,  1,  2,  3,  4,  5,  6,  8,  9, 10,
+   11, 12, 13, 14, 15] # lane3 has got bytes:        [ 16, 17, 18, 19,  4,  5,
+   6,  8,  9, 10, 11, 12, 13, 14, 15]
+
+        expand_ver2 = [
+            # lane 0:
+            0, 1, 2, 3,
+            1, 2, 3, 4,
+            2, 3, 4, 5,
+            3, 4, 5, 6,
+
+            # lane 1:
+            4, 5, 6, 7,
+            5, 6, 7, 8,
+            6, 7, 8, 9,
+            7, 8, 9, 10,
+
+            # lane 2:
+             8,  9, 10, 11,
+             9, 10, 11, 12,
+            10, 11, 12, 13,
+            11, 12, 13, 14,
+
+            # lane 3 order: 13, 14, 15, 16 14, 15, 16, 17, 15, 16, 17, 18, 16,
+   17, 18, 19 12, 13, 14, 15, 13, 14, 15,  0, 14, 15,  0,  1, 15,  0,  1,  2,
+        ]
+*/
+
+#define SIMDUTF_ICELAKE_TRANSCODE16(LANE0, LANE1, MASKED)                      \
+  {                                                                            \
+    const __m512i merged = _mm512_mask_mov_epi32(LANE0, 0x1000, LANE1);        \
+    const __m512i expand_ver2 = _mm512_setr_epi64(                             \
+        0x0403020103020100, 0x0605040305040302, 0x0807060507060504,            \
+        0x0a09080709080706, 0x0c0b0a090b0a0908, 0x0e0d0c0b0d0c0b0a,            \
+        0x000f0e0d0f0e0d0c, 0x0201000f01000f0e);                               \
+    const __m512i input = _mm512_shuffle_epi8(merged, expand_ver2);            \
+                                                                               \
+    __mmask16 leading_bytes;                                                   \
+    const __m512i v_0000_00c0 = _mm512_set1_epi32(0xc0);                       \
+    const __m512i t0 = _mm512_and_si512(input, v_0000_00c0);                   \
+    const __m512i v_0000_0080 = _mm512_set1_epi32(0x80);                       \
+    leading_bytes = _mm512_cmpneq_epu32_mask(t0, v_0000_0080);                 \
+                                                                               \
+    __m512i char_class;                                                        \
+    char_class = _mm512_srli_epi32(input, 4);                                  \
+    /*  char_class = ((input >> 4) & 0x0f) | 0x80808000 */                     \
+    const __m512i v_0000_000f = _mm512_set1_epi32(0x0f);                       \
+    const __m512i v_8080_8000 = _mm512_set1_epi32(0x80808000);                 \
+    char_class =                                                               \
+        _mm512_ternarylogic_epi32(char_class, v_0000_000f, v_8080_8000, 0xea); \
+                                                                               \
+    const int valid_count = static_cast<int>(count_ones(leading_bytes));       \
+    const __m512i utf32 = expanded_utf8_to_utf32(char_class, input);           \
+                                                                               \
+    const __m512i out = _mm512_mask_compress_epi32(_mm512_setzero_si512(),     \
+                                                   leading_bytes, utf32);      \
+                                                                               \
+    if (UTF32) {                                                               \
+      if (MASKED) {                                                            \
+        const __mmask16 valid = uint16_t((1 << valid_count) - 1);              \
+        _mm512_mask_storeu_epi32((__m512i *)output, valid, out);               \
+      } else {                                                                 \
+        _mm512_storeu_si512((__m512i *)output, out);                           \
+      }                                                                        \
+      output += valid_count;                                                   \
+    } else {                                                                   \
+      if (MASKED) {                                                            \
+        output += utf32_to_utf16_masked<big_endian>(                           \
+            byteflip, out, valid_count, reinterpret_cast<char16_t *>(output)); \
+      } else {                                                                 \
+        output += utf32_to_utf16<big_endian>(                                  \
+            byteflip, out, valid_count, reinterpret_cast<char16_t *>(output)); \
+      }                                                                        \
+    }                                                                          \
+  }
+
+#define SIMDUTF_ICELAKE_WRITE_UTF16_OR_UTF32(INPUT, VALID_COUNT, MASKED)       \
+  {                                                                            \
+    if (UTF32) {                                                               \
+      if (MASKED) {                                                            \
+        const __mmask16 valid_mask = uint16_t((1 << VALID_COUNT) - 1);         \
+        _mm512_mask_storeu_epi32((__m512i *)output, valid_mask, INPUT);        \
+      } else {                                                                 \
+        _mm512_storeu_si512((__m512i *)output, INPUT);                         \
+      }                                                                        \
+      output += VALID_COUNT;                                                   \
+    } else {                                                                   \
+      if (MASKED) {                                                            \
+        output += utf32_to_utf16_masked<big_endian>(                           \
+            byteflip, INPUT, VALID_COUNT,                                      \
+            reinterpret_cast<char16_t *>(output));                             \
+      } else {                                                                 \
+        output +=                                                              \
+            utf32_to_utf16<big_endian>(byteflip, INPUT, VALID_COUNT,           \
+                                       reinterpret_cast<char16_t *>(output));  \
+      }                                                                        \
+    }                                                                          \
+  }
+
+#define SIMDUTF_ICELAKE_STORE_ASCII(UTF32, utf8, output)                       \
+  if (UTF32) {                                                                 \
+    const __m128i t0 = _mm512_castsi512_si128(utf8);                           \
+    const __m128i t1 = _mm512_extracti32x4_epi32(utf8, 1);                     \
+    const __m128i t2 = _mm512_extracti32x4_epi32(utf8, 2);                     \
+    const __m128i t3 = _mm512_extracti32x4_epi32(utf8, 3);                     \
+    _mm512_storeu_si512((__m512i *)(output + 0 * 16),                          \
+                        _mm512_cvtepu8_epi32(t0));                             \
+    _mm512_storeu_si512((__m512i *)(output + 1 * 16),                          \
+                        _mm512_cvtepu8_epi32(t1));                             \
+    _mm512_storeu_si512((__m512i *)(output + 2 * 16),                          \
+                        _mm512_cvtepu8_epi32(t2));                             \
+    _mm512_storeu_si512((__m512i *)(output + 3 * 16),                          \
+                        _mm512_cvtepu8_epi32(t3));                             \
+  } else {                                                                     \
+    const __m256i h0 = _mm512_castsi512_si256(utf8);                           \
+    const __m256i h1 = _mm512_extracti64x4_epi64(utf8, 1);                     \
+    if (big_endian) {                                                          \
+      _mm512_storeu_si512(                                                     \
+          (__m512i *)(output + 0 * 16),                                        \
+          _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h0), byteflip));            \
+      _mm512_storeu_si512(                                                     \
+          (__m512i *)(output + 2 * 16),                                        \
+          _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h1), byteflip));            \
+    } else {                                                                   \
+      _mm512_storeu_si512((__m512i *)(output + 0 * 16),                        \
+                          _mm512_cvtepu8_epi16(h0));                           \
+      _mm512_storeu_si512((__m512i *)(output + 2 * 16),                        \
+                          _mm512_cvtepu8_epi16(h1));                           \
+    }                                                                          \
+  }
+/* end file src/icelake/icelake_macros.inl.cpp */
+/* begin file src/icelake/icelake_common.inl.cpp */
+// file included directly
+/**
+ * Store the last N bytes of previous followed by 512-N bytes from input.
+ */
+template <int N> __m512i prev(__m512i input, __m512i previous) {
+  static_assert(N <= 32, "N must be no larger than 32");
+  const __m512i movemask =
+      _mm512_setr_epi32(28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
+  const __m512i rotated = _mm512_permutex2var_epi32(input, movemask, previous);
+#if SIMDUTF_GCC8 || SIMDUTF_GCC9
+  constexpr int shift = 16 - N; // workaround for GCC8,9
+  return _mm512_alignr_epi8(input, rotated, shift);
+#else
+  return _mm512_alignr_epi8(input, rotated, 16 - N);
+#endif // SIMDUTF_GCC8 || SIMDUTF_GCC9
+}
+
+template <unsigned idx0, unsigned idx1, unsigned idx2, unsigned idx3>
+__m512i shuffle_epi128(__m512i v) {
+  static_assert((idx0 >= 0 && idx0 <= 3), "idx0 must be in range 0..3");
+  static_assert((idx1 >= 0 && idx1 <= 3), "idx1 must be in range 0..3");
+  static_assert((idx2 >= 0 && idx2 <= 3), "idx2 must be in range 0..3");
+  static_assert((idx3 >= 0 && idx3 <= 3), "idx3 must be in range 0..3");
+
+  constexpr unsigned shuffle = idx0 | (idx1 << 2) | (idx2 << 4) | (idx3 << 6);
+  return _mm512_shuffle_i32x4(v, v, shuffle);
+}
+
+template <unsigned idx> constexpr __m512i broadcast_epi128(__m512i v) {
+  return shuffle_epi128<idx, idx, idx, idx>(v);
+}
+/* end file src/icelake/icelake_common.inl.cpp */
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/icelake/icelake_utf8_common.inl.cpp */
 // Common procedures for both validating and non-validating conversions from
 // UTF-8.
@@ -23466,11 +24866,10 @@ simdutf_really_inline size_t utf32_to_utf16_masked(const __m512i byteflip,
       t5 = _mm512_shuffle_epi8(t5, byteflip);
     }
     // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
-    // (zen4)
+    // (AMD Zen4 has terrible performance with it, it is effectively broken)
     __m512i compressed = _mm512_maskz_compress_epi16(nonzero_masked, t5);
     _mm512_mask_storeu_epi16(
-        output,
-        (1 << (count + static_cast<unsigned int>(count_ones(sp_mask)))) - 1,
+        output, _bzhi_u32(0xFFFFFFFF, count + _mm_popcnt_u32(sp_mask)),
         compressed);
     //_mm512_mask_compressstoreu_epi16(output, nonzero_masked, t5);
   }
@@ -23562,48 +24961,6 @@ simdutf_really_inline size_t utf32_to_utf16(const __m512i byteflip,
   return count + static_cast<unsigned int>(count_ones(sp_mask));
 }
 
-/**
- * Store the last N bytes of previous followed by 512-N bytes from input.
- */
-template <int N> __m512i prev(__m512i input, __m512i previous) {
-  static_assert(N <= 32, "N must be no larger than 32");
-  const __m512i movemask =
-      _mm512_setr_epi32(28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
-  const __m512i rotated = _mm512_permutex2var_epi32(input, movemask, previous);
-#if SIMDUTF_GCC8 || SIMDUTF_GCC9
-  constexpr int shift = 16 - N; // workaround for GCC8,9
-  return _mm512_alignr_epi8(input, rotated, shift);
-#else
-  return _mm512_alignr_epi8(input, rotated, 16 - N);
-#endif // SIMDUTF_GCC8 || SIMDUTF_GCC9
-}
-
-template <unsigned idx0, unsigned idx1, unsigned idx2, unsigned idx3>
-__m512i shuffle_epi128(__m512i v) {
-  static_assert((idx0 >= 0 && idx0 <= 3), "idx0 must be in range 0..3");
-  static_assert((idx1 >= 0 && idx1 <= 3), "idx1 must be in range 0..3");
-  static_assert((idx2 >= 0 && idx2 <= 3), "idx2 must be in range 0..3");
-  static_assert((idx3 >= 0 && idx3 <= 3), "idx3 must be in range 0..3");
-
-  constexpr unsigned shuffle = idx0 | (idx1 << 2) | (idx2 << 4) | (idx3 << 6);
-  return _mm512_shuffle_i32x4(v, v, shuffle);
-}
-
-template <unsigned idx> constexpr __m512i broadcast_epi128(__m512i v) {
-  return shuffle_epi128<idx, idx, idx, idx>(v);
-}
-
-/**
- * Current unused.
- */
-template <int N> __m512i rotate_by_N_epi8(const __m512i input) {
-
-  // lanes order: 1, 2, 3, 0 => 0b00_11_10_01
-  const __m512i permuted = _mm512_shuffle_i32x4(input, input, 0x39);
-
-  return _mm512_alignr_epi8(permuted, input, N);
-}
-
 /*
     expanded_utf8_to_utf32 converts expanded UTF-8 characters (`utf8`)
     stored at separate 32-bit lanes.
@@ -23749,151 +25106,131 @@ simdutf_really_inline __m512i expand_utf8_to_utf32(__m512i input) {
   return expanded_utf8_to_utf32(char_class, input);
 }
 /* end file src/icelake/icelake_utf8_common.inl.cpp */
-/* begin file src/icelake/icelake_macros.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8
 
-/*
-    This upcoming macro (SIMDUTF_ICELAKE_TRANSCODE16) takes 16 + 4 bytes (of a
-   UTF-8 string) and loads all possible 4-byte substring into an AVX512
-   register.
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/icelake/icelake_utf8_validation.inl.cpp */
+// file included directly
 
-    For example if we have bytes abcdefgh... we create following 32-bit lanes
+simdutf_really_inline __m512i check_special_cases(__m512i input,
+                                                  const __m512i prev1) {
+  __m512i mask1 = _mm512_setr_epi64(0x0202020202020202, 0x4915012180808080,
+                                    0x0202020202020202, 0x4915012180808080,
+                                    0x0202020202020202, 0x4915012180808080,
+                                    0x0202020202020202, 0x4915012180808080);
+  const __m512i v_0f = _mm512_set1_epi8(0x0f);
+  __m512i index1 = _mm512_and_si512(_mm512_srli_epi16(prev1, 4), v_0f);
 
-    [abcd|bcde|cdef|defg|efgh|...]
-     ^                          ^
-     byte 0 of reg              byte 63 of reg
-*/
-/** pshufb
-        # lane{0,1,2} have got bytes: [  0,  1,  2,  3,  4,  5,  6,  8,  9, 10,
-   11, 12, 13, 14, 15] # lane3 has got bytes:        [ 16, 17, 18, 19,  4,  5,
-   6,  8,  9, 10, 11, 12, 13, 14, 15]
+  __m512i byte_1_high = _mm512_shuffle_epi8(mask1, index1);
+  __m512i mask2 = _mm512_setr_epi64(0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
+                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
+                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
+                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb);
+  __m512i index2 = _mm512_and_si512(prev1, v_0f);
 
-        expand_ver2 = [
-            # lane 0:
-            0, 1, 2, 3,
-            1, 2, 3, 4,
-            2, 3, 4, 5,
-            3, 4, 5, 6,
+  __m512i byte_1_low = _mm512_shuffle_epi8(mask2, index2);
+  __m512i mask3 =
+      _mm512_setr_epi64(0x101010101010101, 0x1010101babaaee6, 0x101010101010101,
+                        0x1010101babaaee6, 0x101010101010101, 0x1010101babaaee6,
+                        0x101010101010101, 0x1010101babaaee6);
+  __m512i index3 = _mm512_and_si512(_mm512_srli_epi16(input, 4), v_0f);
+  __m512i byte_2_high = _mm512_shuffle_epi8(mask3, index3);
+  return _mm512_ternarylogic_epi64(byte_1_high, byte_1_low, byte_2_high, 128);
+}
 
-            # lane 1:
-            4, 5, 6, 7,
-            5, 6, 7, 8,
-            6, 7, 8, 9,
-            7, 8, 9, 10,
+simdutf_really_inline __m512i check_multibyte_lengths(const __m512i input,
+                                                      const __m512i prev_input,
+                                                      const __m512i sc) {
+  __m512i prev2 = prev<2>(input, prev_input);
+  __m512i prev3 = prev<3>(input, prev_input);
+  __m512i is_third_byte = _mm512_subs_epu8(
+      prev2, _mm512_set1_epi8(0b11100000u - 1)); // Only 111_____ will be > 0
+  __m512i is_fourth_byte = _mm512_subs_epu8(
+      prev3, _mm512_set1_epi8(0b11110000u - 1)); // Only 1111____ will be > 0
+  __m512i is_third_or_fourth_byte =
+      _mm512_or_si512(is_third_byte, is_fourth_byte);
+  const __m512i v_7f = _mm512_set1_epi8(char(0x7f));
+  is_third_or_fourth_byte = _mm512_adds_epu8(v_7f, is_third_or_fourth_byte);
+  // We want to compute (is_third_or_fourth_byte AND v80) XOR sc.
+  const __m512i v_80 = _mm512_set1_epi8(char(0x80));
+  return _mm512_ternarylogic_epi32(is_third_or_fourth_byte, v_80, sc,
+                                   0b1101010);
+  //__m512i is_third_or_fourth_byte_mask =
+  //_mm512_and_si512(is_third_or_fourth_byte, v_80); return
+  // _mm512_xor_si512(is_third_or_fourth_byte_mask, sc);
+}
+//
+// Return nonzero if there are incomplete multibyte characters at the end of the
+// block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
+//
+simdutf_really_inline __m512i is_incomplete(const __m512i input) {
+  // If the previous input's last 3 bytes match this, they're too short (they
+  // ended at EOF):
+  // ... 1111____ 111_____ 11______
+  __m512i max_value = _mm512_setr_epi64(0xffffffffffffffff, 0xffffffffffffffff,
+                                        0xffffffffffffffff, 0xffffffffffffffff,
+                                        0xffffffffffffffff, 0xffffffffffffffff,
+                                        0xffffffffffffffff, 0xbfdfefffffffffff);
+  return _mm512_subs_epu8(input, max_value);
+}
 
-            # lane 2:
-             8,  9, 10, 11,
-             9, 10, 11, 12,
-            10, 11, 12, 13,
-            11, 12, 13, 14,
+struct avx512_utf8_checker {
+  // If this is nonzero, there has been a UTF-8 error.
+  __m512i error{};
 
-            # lane 3 order: 13, 14, 15, 16 14, 15, 16, 17, 15, 16, 17, 18, 16,
-   17, 18, 19 12, 13, 14, 15, 13, 14, 15,  0, 14, 15,  0,  1, 15,  0,  1,  2,
-        ]
-*/
+  // The last input we received
+  __m512i prev_input_block{};
+  // Whether the last input we received was incomplete (used for ASCII fast
+  // path)
+  __m512i prev_incomplete{};
 
-#define SIMDUTF_ICELAKE_TRANSCODE16(LANE0, LANE1, MASKED)                      \
-  {                                                                            \
-    const __m512i merged = _mm512_mask_mov_epi32(LANE0, 0x1000, LANE1);        \
-    const __m512i expand_ver2 = _mm512_setr_epi64(                             \
-        0x0403020103020100, 0x0605040305040302, 0x0807060507060504,            \
-        0x0a09080709080706, 0x0c0b0a090b0a0908, 0x0e0d0c0b0d0c0b0a,            \
-        0x000f0e0d0f0e0d0c, 0x0201000f01000f0e);                               \
-    const __m512i input = _mm512_shuffle_epi8(merged, expand_ver2);            \
-                                                                               \
-    __mmask16 leading_bytes;                                                   \
-    const __m512i v_0000_00c0 = _mm512_set1_epi32(0xc0);                       \
-    const __m512i t0 = _mm512_and_si512(input, v_0000_00c0);                   \
-    const __m512i v_0000_0080 = _mm512_set1_epi32(0x80);                       \
-    leading_bytes = _mm512_cmpneq_epu32_mask(t0, v_0000_0080);                 \
-                                                                               \
-    __m512i char_class;                                                        \
-    char_class = _mm512_srli_epi32(input, 4);                                  \
-    /*  char_class = ((input >> 4) & 0x0f) | 0x80808000 */                     \
-    const __m512i v_0000_000f = _mm512_set1_epi32(0x0f);                       \
-    const __m512i v_8080_8000 = _mm512_set1_epi32(0x80808000);                 \
-    char_class =                                                               \
-        _mm512_ternarylogic_epi32(char_class, v_0000_000f, v_8080_8000, 0xea); \
-                                                                               \
-    const int valid_count = static_cast<int>(count_ones(leading_bytes));       \
-    const __m512i utf32 = expanded_utf8_to_utf32(char_class, input);           \
-                                                                               \
-    const __m512i out = _mm512_mask_compress_epi32(_mm512_setzero_si512(),     \
-                                                   leading_bytes, utf32);      \
-                                                                               \
-    if (UTF32) {                                                               \
-      if (MASKED) {                                                            \
-        const __mmask16 valid = uint16_t((1 << valid_count) - 1);              \
-        _mm512_mask_storeu_epi32((__m512i *)output, valid, out);               \
-      } else {                                                                 \
-        _mm512_storeu_si512((__m512i *)output, out);                           \
-      }                                                                        \
-      output += valid_count;                                                   \
-    } else {                                                                   \
-      if (MASKED) {                                                            \
-        output += utf32_to_utf16_masked<big_endian>(                           \
-            byteflip, out, valid_count, reinterpret_cast<char16_t *>(output)); \
-      } else {                                                                 \
-        output += utf32_to_utf16<big_endian>(                                  \
-            byteflip, out, valid_count, reinterpret_cast<char16_t *>(output)); \
-      }                                                                        \
-    }                                                                          \
+  //
+  // Check whether the current bytes are valid UTF-8.
+  //
+  simdutf_really_inline void check_utf8_bytes(const __m512i input,
+                                              const __m512i prev_input) {
+    // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
+    // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
+    // small negative numbers)
+    __m512i prev1 = prev<1>(input, prev_input);
+    __m512i sc = check_special_cases(input, prev1);
+    this->error = _mm512_or_si512(
+        check_multibyte_lengths(input, prev_input, sc), this->error);
   }
 
-#define SIMDUTF_ICELAKE_WRITE_UTF16_OR_UTF32(INPUT, VALID_COUNT, MASKED)       \
-  {                                                                            \
-    if (UTF32) {                                                               \
-      if (MASKED) {                                                            \
-        const __mmask16 valid_mask = uint16_t((1 << VALID_COUNT) - 1);         \
-        _mm512_mask_storeu_epi32((__m512i *)output, valid_mask, INPUT);        \
-      } else {                                                                 \
-        _mm512_storeu_si512((__m512i *)output, INPUT);                         \
-      }                                                                        \
-      output += VALID_COUNT;                                                   \
-    } else {                                                                   \
-      if (MASKED) {                                                            \
-        output += utf32_to_utf16_masked<big_endian>(                           \
-            byteflip, INPUT, VALID_COUNT,                                      \
-            reinterpret_cast<char16_t *>(output));                             \
-      } else {                                                                 \
-        output +=                                                              \
-            utf32_to_utf16<big_endian>(byteflip, INPUT, VALID_COUNT,           \
-                                       reinterpret_cast<char16_t *>(output));  \
-      }                                                                        \
-    }                                                                          \
+  // The only problem that can happen at EOF is that a multibyte character is
+  // too short or a byte value too large in the last bytes: check_special_cases
+  // only checks for bytes too large in the first of two bytes.
+  simdutf_really_inline void check_eof() {
+    // If the previous block had incomplete UTF-8 characters at the end, an
+    // ASCII block can't possibly finish them.
+    this->error = _mm512_or_si512(this->error, this->prev_incomplete);
   }
 
-#define SIMDUTF_ICELAKE_STORE_ASCII(UTF32, utf8, output)                       \
-  if (UTF32) {                                                                 \
-    const __m128i t0 = _mm512_castsi512_si128(utf8);                           \
-    const __m128i t1 = _mm512_extracti32x4_epi32(utf8, 1);                     \
-    const __m128i t2 = _mm512_extracti32x4_epi32(utf8, 2);                     \
-    const __m128i t3 = _mm512_extracti32x4_epi32(utf8, 3);                     \
-    _mm512_storeu_si512((__m512i *)(output + 0 * 16),                          \
-                        _mm512_cvtepu8_epi32(t0));                             \
-    _mm512_storeu_si512((__m512i *)(output + 1 * 16),                          \
-                        _mm512_cvtepu8_epi32(t1));                             \
-    _mm512_storeu_si512((__m512i *)(output + 2 * 16),                          \
-                        _mm512_cvtepu8_epi32(t2));                             \
-    _mm512_storeu_si512((__m512i *)(output + 3 * 16),                          \
-                        _mm512_cvtepu8_epi32(t3));                             \
-  } else {                                                                     \
-    const __m256i h0 = _mm512_castsi512_si256(utf8);                           \
-    const __m256i h1 = _mm512_extracti64x4_epi64(utf8, 1);                     \
-    if (big_endian) {                                                          \
-      _mm512_storeu_si512(                                                     \
-          (__m512i *)(output + 0 * 16),                                        \
-          _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h0), byteflip));            \
-      _mm512_storeu_si512(                                                     \
-          (__m512i *)(output + 2 * 16),                                        \
-          _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h1), byteflip));            \
-    } else {                                                                   \
-      _mm512_storeu_si512((__m512i *)(output + 0 * 16),                        \
-                          _mm512_cvtepu8_epi16(h0));                           \
-      _mm512_storeu_si512((__m512i *)(output + 2 * 16),                        \
-                          _mm512_cvtepu8_epi16(h1));                           \
-    }                                                                          \
+  // returns true if ASCII.
+  simdutf_really_inline bool check_next_input(const __m512i input) {
+    const __m512i v_80 = _mm512_set1_epi8(char(0x80));
+    const __mmask64 ascii = _mm512_test_epi8_mask(input, v_80);
+    if (ascii == 0) {
+      this->error = _mm512_or_si512(this->error, this->prev_incomplete);
+      return true;
+    } else {
+      this->check_utf8_bytes(input, this->prev_input_block);
+      this->prev_incomplete = is_incomplete(input);
+      this->prev_input_block = input;
+      return false;
+    }
   }
-/* end file src/icelake/icelake_macros.inl.cpp */
+  // do not forget to call check_eof!
+  simdutf_really_inline bool errors() const {
+    return _mm512_test_epi8_mask(this->error, this->error) != 0;
+  }
+}; // struct avx512_utf8_checker
+/* end file src/icelake/icelake_utf8_validation.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 &&                                                    \
+    (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_LATIN1)
 /* begin file src/icelake/icelake_from_valid_utf8.inl.cpp */
 // file included directly
 
@@ -24032,201 +25369,11 @@ valid_utf8_to_fixed_length(const char *str, size_t len, OUTPUT *dwords) {
 
 using utf8_to_utf16_result = std::pair<const char *, char16_t *>;
 /* end file src/icelake/icelake_from_valid_utf8.inl.cpp */
-/* begin file src/icelake/icelake_utf8_validation.inl.cpp */
-// file included directly
-
-simdutf_really_inline __m512i check_special_cases(__m512i input,
-                                                  const __m512i prev1) {
-  __m512i mask1 = _mm512_setr_epi64(0x0202020202020202, 0x4915012180808080,
-                                    0x0202020202020202, 0x4915012180808080,
-                                    0x0202020202020202, 0x4915012180808080,
-                                    0x0202020202020202, 0x4915012180808080);
-  const __m512i v_0f = _mm512_set1_epi8(0x0f);
-  __m512i index1 = _mm512_and_si512(_mm512_srli_epi16(prev1, 4), v_0f);
-
-  __m512i byte_1_high = _mm512_shuffle_epi8(mask1, index1);
-  __m512i mask2 = _mm512_setr_epi64(0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
-                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
-                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
-                                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb);
-  __m512i index2 = _mm512_and_si512(prev1, v_0f);
-
-  __m512i byte_1_low = _mm512_shuffle_epi8(mask2, index2);
-  __m512i mask3 =
-      _mm512_setr_epi64(0x101010101010101, 0x1010101babaaee6, 0x101010101010101,
-                        0x1010101babaaee6, 0x101010101010101, 0x1010101babaaee6,
-                        0x101010101010101, 0x1010101babaaee6);
-  __m512i index3 = _mm512_and_si512(_mm512_srli_epi16(input, 4), v_0f);
-  __m512i byte_2_high = _mm512_shuffle_epi8(mask3, index3);
-  return _mm512_ternarylogic_epi64(byte_1_high, byte_1_low, byte_2_high, 128);
-}
-
-simdutf_really_inline __m512i check_multibyte_lengths(const __m512i input,
-                                                      const __m512i prev_input,
-                                                      const __m512i sc) {
-  __m512i prev2 = prev<2>(input, prev_input);
-  __m512i prev3 = prev<3>(input, prev_input);
-  __m512i is_third_byte = _mm512_subs_epu8(
-      prev2, _mm512_set1_epi8(0b11100000u - 1)); // Only 111_____ will be > 0
-  __m512i is_fourth_byte = _mm512_subs_epu8(
-      prev3, _mm512_set1_epi8(0b11110000u - 1)); // Only 1111____ will be > 0
-  __m512i is_third_or_fourth_byte =
-      _mm512_or_si512(is_third_byte, is_fourth_byte);
-  const __m512i v_7f = _mm512_set1_epi8(char(0x7f));
-  is_third_or_fourth_byte = _mm512_adds_epu8(v_7f, is_third_or_fourth_byte);
-  // We want to compute (is_third_or_fourth_byte AND v80) XOR sc.
-  const __m512i v_80 = _mm512_set1_epi8(char(0x80));
-  return _mm512_ternarylogic_epi32(is_third_or_fourth_byte, v_80, sc,
-                                   0b1101010);
-  //__m512i is_third_or_fourth_byte_mask =
-  //_mm512_and_si512(is_third_or_fourth_byte, v_80); return
-  // _mm512_xor_si512(is_third_or_fourth_byte_mask, sc);
-}
-//
-// Return nonzero if there are incomplete multibyte characters at the end of the
-// block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
-//
-simdutf_really_inline __m512i is_incomplete(const __m512i input) {
-  // If the previous input's last 3 bytes match this, they're too short (they
-  // ended at EOF):
-  // ... 1111____ 111_____ 11______
-  __m512i max_value = _mm512_setr_epi64(0xffffffffffffffff, 0xffffffffffffffff,
-                                        0xffffffffffffffff, 0xffffffffffffffff,
-                                        0xffffffffffffffff, 0xffffffffffffffff,
-                                        0xffffffffffffffff, 0xbfdfefffffffffff);
-  return _mm512_subs_epu8(input, max_value);
-}
-
-struct avx512_utf8_checker {
-  // If this is nonzero, there has been a UTF-8 error.
-  __m512i error{};
-
-  // The last input we received
-  __m512i prev_input_block{};
-  // Whether the last input we received was incomplete (used for ASCII fast
-  // path)
-  __m512i prev_incomplete{};
-
-  //
-  // Check whether the current bytes are valid UTF-8.
-  //
-  simdutf_really_inline void check_utf8_bytes(const __m512i input,
-                                              const __m512i prev_input) {
-    // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
-    // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
-    // small negative numbers)
-    __m512i prev1 = prev<1>(input, prev_input);
-    __m512i sc = check_special_cases(input, prev1);
-    this->error = _mm512_or_si512(
-        check_multibyte_lengths(input, prev_input, sc), this->error);
-  }
-
-  // The only problem that can happen at EOF is that a multibyte character is
-  // too short or a byte value too large in the last bytes: check_special_cases
-  // only checks for bytes too large in the first of two bytes.
-  simdutf_really_inline void check_eof() {
-    // If the previous block had incomplete UTF-8 characters at the end, an
-    // ASCII block can't possibly finish them.
-    this->error = _mm512_or_si512(this->error, this->prev_incomplete);
-  }
-
-  // returns true if ASCII.
-  simdutf_really_inline bool check_next_input(const __m512i input) {
-    const __m512i v_80 = _mm512_set1_epi8(char(0x80));
-    const __mmask64 ascii = _mm512_test_epi8_mask(input, v_80);
-    if (ascii == 0) {
-      this->error = _mm512_or_si512(this->error, this->prev_incomplete);
-      return true;
-    } else {
-      this->check_utf8_bytes(input, this->prev_input_block);
-      this->prev_incomplete = is_incomplete(input);
-      this->prev_input_block = input;
-      return false;
-    }
-  }
-  // do not forget to call check_eof!
-  simdutf_really_inline bool errors() const {
-    return _mm512_test_epi8_mask(this->error, this->error) != 0;
-  }
-}; // struct avx512_utf8_checker
-/* end file src/icelake/icelake_utf8_validation.inl.cpp */
 /* begin file src/icelake/icelake_from_utf8.inl.cpp */
 // file included directly
 
 // File contains conversion procedure from possibly invalid UTF-8 strings.
 
-/**
- * Attempts to convert up to len 1-byte code units from in (in UTF-8 format) to
- * out.
- * Returns the position of the input and output after the processing is
- * completed. Upon error, the output is set to null.
- */
-
-template <endianness big_endian>
-utf8_to_utf16_result
-fast_avx512_convert_utf8_to_utf16(const char *in, size_t len, char16_t *out) {
-  const char *const final_in = in + len;
-  bool result = true;
-  while (result) {
-    if (final_in - in >= 64) {
-      result = process_block_utf8_to_utf16<SIMDUTF_FULL, big_endian>(
-          in, out, final_in - in);
-    } else if (in < final_in) {
-      result = process_block_utf8_to_utf16<SIMDUTF_TAIL, big_endian>(
-          in, out, final_in - in);
-    } else {
-      break;
-    }
-  }
-  if (!result) {
-    out = nullptr;
-  }
-  return std::make_pair(in, out);
-}
-
-template <endianness big_endian>
-simdutf::result fast_avx512_convert_utf8_to_utf16_with_errors(const char *in,
-                                                              size_t len,
-                                                              char16_t *out) {
-  const char *const init_in = in;
-  const char16_t *const init_out = out;
-  const char *const final_in = in + len;
-  bool result = true;
-  while (result) {
-    if (final_in - in >= 64) {
-      result = process_block_utf8_to_utf16<SIMDUTF_FULL, big_endian>(
-          in, out, final_in - in);
-    } else if (in < final_in) {
-      result = process_block_utf8_to_utf16<SIMDUTF_TAIL, big_endian>(
-          in, out, final_in - in);
-    } else {
-      break;
-    }
-  }
-  if (!result) {
-    size_t pos = size_t(in - init_in);
-    if (pos < len && (init_in[pos] & 0xc0) == 0x80 && pos >= 64) {
-      // We must check whether we are the fourth continuation byte
-      bool c1 = (init_in[pos - 1] & 0xc0) == 0x80;
-      bool c2 = (init_in[pos - 2] & 0xc0) == 0x80;
-      bool c3 = (init_in[pos - 3] & 0xc0) == 0x80;
-      if (c1 && c2 && c3) {
-        return {simdutf::TOO_LONG, pos};
-      }
-    }
-    // rewind_and_convert_with_errors will seek a potential error from in
-    // onward, with the ability to go back up to in - init_in bytes, and read
-    // final_in - in bytes forward.
-    simdutf::result res =
-        scalar::utf8_to_utf16::rewind_and_convert_with_errors<big_endian>(
-            in - init_in, in, final_in - in, out);
-    res.count += (in - init_in);
-    return res;
-  } else {
-    return simdutf::result(error_code::SUCCESS, out - init_out);
-  }
-}
-
 template <endianness big_endian, typename OUTPUT>
 // todo: replace with the utf-8 to utf-16 routine adapted to utf-32. This code
 // is legacy.
@@ -24490,6 +25637,10 @@ validating_utf8_to_fixed_length_with_constant_checks(const char *str,
   return {ptr, output, true};
 }
 /* end file src/icelake/icelake_from_utf8.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_LATIN1)
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/icelake/icelake_convert_utf8_to_latin1.inl.cpp */
 // file included directly
 
@@ -24667,6 +25818,9 @@ size_t valid_utf8_to_latin1_avx512(const char *buf, size_t len,
   return (size_t)(latin_output - start);
 }
 /* end file src/icelake/icelake_convert_valid_utf8_to_latin1.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/icelake/icelake_convert_utf16_to_latin1.inl.cpp */
 // file included directly
 template <endianness big_endian>
@@ -24734,7 +25888,7 @@ icelake_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     }
     if (_mm512_cmpgt_epu16_mask(in, v_0xFF)) {
       uint16_t word;
-      while ((word = (big_endian ? scalar::utf16::swap_bytes(uint16_t(*buf))
+      while ((word = (big_endian ? scalar::u16_swap_bytes(uint16_t(*buf))
                                  : uint16_t(*buf))) <= 0xff) {
         *latin1_output++ = uint8_t(word);
         buf++;
@@ -24757,7 +25911,7 @@ icelake_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     if (_mm512_cmpgt_epu16_mask(in, v_0xFF)) {
 
       uint16_t word;
-      while ((word = (big_endian ? scalar::utf16::swap_bytes(uint16_t(*buf))
+      while ((word = (big_endian ? scalar::u16_swap_bytes(uint16_t(*buf))
                                  : uint16_t(*buf))) <= 0xff) {
         *latin1_output++ = uint8_t(word);
         buf++;
@@ -24772,6 +25926,9 @@ icelake_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, len), latin1_output);
 }
 /* end file src/icelake/icelake_convert_utf16_to_latin1.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/icelake/icelake_convert_utf16_to_utf8.inl.cpp */
 // file included directly
 
@@ -24980,6 +26137,86 @@ tail:
   return ((inbuf - inbuf_orig) + adjust);
 }
 /* end file src/icelake/icelake_convert_utf16_to_utf8.inl.cpp */
+/* begin file src/icelake/icelake_convert_utf8_to_utf16.inl.cpp */
+// file included directly
+
+// File contains conversion procedure from possibly invalid UTF-8 strings.
+
+/**
+ * Attempts to convert up to len 1-byte code units from in (in UTF-8 format) to
+ * out.
+ * Returns the position of the input and output after the processing is
+ * completed. Upon error, the output is set to null.
+ */
+
+template <endianness big_endian>
+utf8_to_utf16_result
+fast_avx512_convert_utf8_to_utf16(const char *in, size_t len, char16_t *out) {
+  const char *const final_in = in + len;
+  bool result = true;
+  while (result) {
+    if (final_in - in >= 64) {
+      result = process_block_utf8_to_utf16<SIMDUTF_FULL, big_endian>(
+          in, out, final_in - in);
+    } else if (in < final_in) {
+      result = process_block_utf8_to_utf16<SIMDUTF_TAIL, big_endian>(
+          in, out, final_in - in);
+    } else {
+      break;
+    }
+  }
+  if (!result) {
+    out = nullptr;
+  }
+  return std::make_pair(in, out);
+}
+
+template <endianness big_endian>
+simdutf::result fast_avx512_convert_utf8_to_utf16_with_errors(const char *in,
+                                                              size_t len,
+                                                              char16_t *out) {
+  const char *const init_in = in;
+  const char16_t *const init_out = out;
+  const char *const final_in = in + len;
+  bool result = true;
+  while (result) {
+    if (final_in - in >= 64) {
+      result = process_block_utf8_to_utf16<SIMDUTF_FULL, big_endian>(
+          in, out, final_in - in);
+    } else if (in < final_in) {
+      result = process_block_utf8_to_utf16<SIMDUTF_TAIL, big_endian>(
+          in, out, final_in - in);
+    } else {
+      break;
+    }
+  }
+  if (!result) {
+    size_t pos = size_t(in - init_in);
+    if (pos < len && (init_in[pos] & 0xc0) == 0x80 && pos >= 64) {
+      // We must check whether we are the fourth continuation byte
+      bool c1 = (init_in[pos - 1] & 0xc0) == 0x80;
+      bool c2 = (init_in[pos - 2] & 0xc0) == 0x80;
+      bool c3 = (init_in[pos - 3] & 0xc0) == 0x80;
+      if (c1 && c2 && c3) {
+        return {simdutf::TOO_LONG, pos};
+      }
+    }
+    // rewind_and_convert_with_errors will seek a potential error from in
+    // onward, with the ability to go back up to in - init_in bytes, and read
+    // final_in - in bytes forward.
+    simdutf::result res =
+        scalar::utf8_to_utf16::rewind_and_convert_with_errors<big_endian>(
+            in - init_in, in, final_in - in, out);
+    res.count += (in - init_in);
+    return res;
+  } else {
+    return simdutf::result(error_code::SUCCESS, out - init_out);
+  }
+}
+/* end file src/icelake/icelake_convert_utf8_to_utf16.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/icelake/icelake_convert_utf16_to_utf32.inl.cpp */
 // file included directly
 
@@ -25118,6 +26355,9 @@ convert_utf16_to_utf32(const char16_t *buf, size_t len,
   return std::make_tuple(buf + carry, utf32_output, true);
 }
 /* end file src/icelake/icelake_convert_utf16_to_utf32.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF32
 /* begin file src/icelake/icelake_convert_utf32_to_latin1.inl.cpp */
 // file included directly
 size_t icelake_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -25194,6 +26434,9 @@ icelake_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, len), latin1_output);
 }
 /* end file src/icelake/icelake_convert_utf32_to_latin1.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/icelake/icelake_convert_utf32_to_utf8.inl.cpp */
 // file included directly
 
@@ -25770,186 +27013,352 @@ avx512_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf8_output);
 }
 /* end file src/icelake/icelake_convert_utf32_to_utf8.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/icelake/icelake_convert_utf32_to_utf16.inl.cpp */
 // file included directly
 
-// Todo: currently, this is just the haswell code, optimize for icelake kernel.
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
 avx512_convert_utf32_to_utf16(const char32_t *buf, size_t len,
                               char16_t *utf16_output) {
   const char32_t *end = buf + len;
-
-  const size_t safety_margin =
-      12; // to avoid overruns, see issue
-          // https://github.com/simdutf/simdutf/issues/92
-  __m256i forbidden_bytemask = _mm256_setzero_si256();
-
-  while (end - buf >= std::ptrdiff_t(8 + safety_margin)) {
-    __m256i in = _mm256_loadu_si256((__m256i *)buf);
-
-    const __m256i v_00000000 = _mm256_setzero_si256();
-    const __m256i v_ffff0000 = _mm256_set1_epi32((int32_t)0xffff0000);
+  __mmask32 forbidden_bytemask = 0;
+  const __m512i v_00000000 = _mm512_setzero_si512();
+  const __m512i v_ffff0000 = _mm512_set1_epi32((int32_t)0xffff0000);
+  const __m512i v_f800 = _mm512_set1_epi32((uint32_t)0xf800);
+  const __m512i v_d800 = _mm512_set1_epi32((uint32_t)0xd800);
+  const __m512i v_10ffff = _mm512_set1_epi32(0x10FFFF);
+  const __m512i v_10000 = _mm512_set1_epi32(0x10000);
+  const __m512i v_3ff0000 = _mm512_set1_epi32(0x3FF0000);
+  const __m512i v_3ff = _mm512_set1_epi32(0x3FF);
+  const __m512i v_dc00d800 = _mm512_set1_epi32((int32_t)0xDC00D800);
+
+  while (end - buf >= std::ptrdiff_t(16)) {
+    __m512i in = _mm512_loadu_si512(buf);
 
     // no bits set above 16th bit <=> can pack to UTF16 without surrogate pairs
-    const __m256i saturation_bytemask =
-        _mm256_cmpeq_epi32(_mm256_and_si256(in, v_ffff0000), v_00000000);
-    const uint32_t saturation_bitmask =
-        static_cast<uint32_t>(_mm256_movemask_epi8(saturation_bytemask));
+    const __mmask16 saturation_bitmask =
+        _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_ffff0000), v_00000000);
 
-    if (saturation_bitmask == 0xffffffff) {
-      const __m256i v_f800 = _mm256_set1_epi32((uint32_t)0xf800);
-      const __m256i v_d800 = _mm256_set1_epi32((uint32_t)0xd800);
-      forbidden_bytemask = _mm256_or_si256(
-          forbidden_bytemask,
-          _mm256_cmpeq_epi32(_mm256_and_si256(in, v_f800), v_d800));
+    if (saturation_bitmask == 0xffff) {
+      forbidden_bytemask |=
+          _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_f800), v_d800);
 
-      __m128i utf16_packed = _mm_packus_epi32(_mm256_castsi256_si128(in),
-                                              _mm256_extractf128_si256(in, 1));
+      __m256i utf16_packed = _mm512_cvtepi32_epi16(in);
       if (big_endian) {
-        const __m128i swap =
-            _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
-        utf16_packed = _mm_shuffle_epi8(utf16_packed, swap);
+        const __m256i swap = _mm256_setr_epi8(
+            1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 1, 0, 3, 2, 5,
+            4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+        utf16_packed = _mm256_shuffle_epi8(utf16_packed, swap);
       }
-      _mm_storeu_si128((__m128i *)utf16_output, utf16_packed);
-      utf16_output += 8;
-      buf += 8;
+      _mm256_storeu_si256((__m256i *)utf16_output, utf16_packed);
+      utf16_output += 16;
+      buf += 16;
     } else {
-      size_t forward = 7;
-      size_t k = 0;
-      if (size_t(end - buf) < forward + 1) {
-        forward = size_t(end - buf - 1);
-      }
-      for (; k < forward; k++) {
-        uint32_t word = buf[k];
-        if ((word & 0xFFFF0000) == 0) {
-          // will not generate a surrogate pair
-          if (word >= 0xD800 && word <= 0xDFFF) {
-            return std::make_pair(nullptr, utf16_output);
-          }
-          *utf16_output++ =
-              big_endian
-                  ? char16_t((uint16_t(word) >> 8) | (uint16_t(word) << 8))
-                  : char16_t(word);
-        } else {
-          // will generate a surrogate pair
-          if (word > 0x10FFFF) {
-            return std::make_pair(nullptr, utf16_output);
-          }
-          word -= 0x10000;
-          uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
-          uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
-          if (big_endian) {
-            high_surrogate =
-                uint16_t((high_surrogate >> 8) | (high_surrogate << 8));
-            low_surrogate =
-                uint16_t((low_surrogate >> 8) | (low_surrogate << 8));
-          }
-          *utf16_output++ = char16_t(high_surrogate);
-          *utf16_output++ = char16_t(low_surrogate);
-        }
+      // saturation_bitmask == 1 words will generate 1 utf16 char,
+      // and saturation_bitmask == 0 words will generate 2 utf16 chars assuming
+      // no errors. Thus we need a output_mask which has the structure b_2i = 1,
+      // b_2i+1 = !saturation_bitmask_i
+      const __mmask32 output_mask = ~_pdep_u32(saturation_bitmask, 0xAAAAAAAA);
+      const __mmask16 surrogate_bitmask = __mmask16(~saturation_bitmask);
+      __mmask32 error = _mm512_mask_cmpeq_epi32_mask(
+          saturation_bitmask, _mm512_and_si512(in, v_f800), v_d800);
+      error |= _mm512_mask_cmpgt_epu32_mask(surrogate_bitmask, in, v_10ffff);
+      if (simdutf_unlikely(error)) {
+        return std::make_pair(nullptr, utf16_output);
+      }
+      __m512i v1, v2, v;
+      // for the bits saturation_bitmask == 0, we need to unpack the 32-bit word
+      // into two 16 bit words corresponding to high_surrogate and
+      // low_surrogate. Once the bits are unpacked and merged, the output will
+      // be compressed as per output_mask.
+      in = _mm512_mask_sub_epi32(in, surrogate_bitmask, in, v_10000);
+      v1 = _mm512_mask_slli_epi32(in, surrogate_bitmask, in, 16);
+      v1 = _mm512_mask_and_epi32(in, surrogate_bitmask, v1, v_3ff0000);
+      v2 = _mm512_mask_srli_epi32(in, surrogate_bitmask, in, 10);
+      v2 = _mm512_mask_and_epi32(in, surrogate_bitmask, v2, v_3ff);
+      v = _mm512_or_si512(v1, v2);
+      in = _mm512_mask_add_epi32(in, surrogate_bitmask, v, v_dc00d800);
+      if (big_endian) {
+        const __m512i swap_512 = _mm512_set_epi8(
+            14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12,
+            13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8,
+            9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5,
+            2, 3, 0, 1);
+        in = _mm512_shuffle_epi8(in, swap_512);
+      }
+      // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
+      // (AMD Zen4 has terrible performance with it, it is effectively broken)
+      __m512i compressed = _mm512_maskz_compress_epi16(output_mask, in);
+      auto written_out = _mm_popcnt_u32(output_mask);
+      _mm512_mask_storeu_epi16(utf16_output, _bzhi_u32(0xFFFFFFFF, written_out),
+                               compressed);
+      //_mm512_mask_compressstoreu_epi16(utf16_output, output_mask, in);
+      utf16_output += written_out;
+      buf += 16;
+    }
+  }
+
+  size_t remaining_len = size_t(end - buf);
+  if (remaining_len) {
+    __mmask16 input_mask = __mmask16((1 << remaining_len) - 1);
+    __m512i in = _mm512_maskz_loadu_epi32(input_mask, buf);
+    const __mmask16 saturation_bitmask =
+        _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_ffff0000), v_00000000) &
+        input_mask;
+    if (saturation_bitmask == input_mask) {
+      forbidden_bytemask |=
+          _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_f800), v_d800);
+
+      __m256i utf16_packed = _mm512_cvtepi32_epi16(in);
+      if (big_endian) {
+        const __m256i swap = _mm256_setr_epi8(
+            1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 1, 0, 3, 2, 5,
+            4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+        utf16_packed = _mm256_shuffle_epi8(utf16_packed, swap);
+      }
+      _mm256_mask_storeu_epi16(utf16_output, input_mask, utf16_packed);
+      utf16_output += remaining_len;
+      buf += remaining_len;
+    } else {
+      const __mmask32 output_max_mask = (1 << (remaining_len * 2)) - 1;
+      const __mmask32 output_mask =
+          (~_pdep_u32(saturation_bitmask, 0xAAAAAAAA)) & output_max_mask;
+      const __mmask16 surrogate_bitmask =
+          __mmask16(~saturation_bitmask) & input_mask;
+      __mmask32 error = _mm512_mask_cmpeq_epi32_mask(
+          saturation_bitmask, _mm512_and_si512(in, v_f800), v_d800);
+      error |= _mm512_mask_cmpgt_epu32_mask(surrogate_bitmask, in, v_10ffff);
+      if (simdutf_unlikely(error)) {
+        return std::make_pair(nullptr, utf16_output);
+      }
+      __m512i v1, v2, v;
+      in = _mm512_mask_sub_epi32(in, surrogate_bitmask, in, v_10000);
+      v1 = _mm512_mask_slli_epi32(in, surrogate_bitmask, in, 16);
+      v1 = _mm512_mask_and_epi32(in, surrogate_bitmask, v1, v_3ff0000);
+      v2 = _mm512_mask_srli_epi32(in, surrogate_bitmask, in, 10);
+      v2 = _mm512_mask_and_epi32(in, surrogate_bitmask, v2, v_3ff);
+      v = _mm512_or_si512(v1, v2);
+      in = _mm512_mask_add_epi32(in, surrogate_bitmask, v, v_dc00d800);
+      if (big_endian) {
+        const __m512i swap_512 = _mm512_set_epi8(
+            14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12,
+            13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8,
+            9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5,
+            2, 3, 0, 1);
+        in = _mm512_shuffle_epi8(in, swap_512);
       }
-      buf += k;
+      // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
+      // (AMD Zen4 has terrible performance with it, it is effectively broken)
+      __m512i compressed = _mm512_maskz_compress_epi16(output_mask, in);
+      auto written_out = _mm_popcnt_u32(output_mask);
+      _mm512_mask_storeu_epi16(utf16_output, _bzhi_u32(0xFFFFFFFF, written_out),
+                               compressed);
+      //_mm512_mask_compressstoreu_epi16(utf16_output, output_mask, in);
+      utf16_output += written_out;
+      buf += remaining_len;
     }
   }
 
   // check for invalid input
-  if (static_cast<uint32_t>(_mm256_movemask_epi8(forbidden_bytemask)) != 0) {
+  if (forbidden_bytemask != 0) {
     return std::make_pair(nullptr, utf16_output);
   }
 
   return std::make_pair(buf, utf16_output);
 }
 
-// Todo: currently, this is just the haswell code, optimize for icelake kernel.
 template <endianness big_endian>
 std::pair<result, char16_t *>
 avx512_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
                                           char16_t *utf16_output) {
   const char32_t *start = buf;
   const char32_t *end = buf + len;
-
-  const size_t safety_margin =
-      12; // to avoid overruns, see issue
-          // https://github.com/simdutf/simdutf/issues/92
-
-  while (end - buf >= std::ptrdiff_t(8 + safety_margin)) {
-    __m256i in = _mm256_loadu_si256((__m256i *)buf);
-
-    const __m256i v_00000000 = _mm256_setzero_si256();
-    const __m256i v_ffff0000 = _mm256_set1_epi32((int32_t)0xffff0000);
+  const __m512i v_00000000 = _mm512_setzero_si512();
+  const __m512i v_ffff0000 = _mm512_set1_epi32((int32_t)0xffff0000);
+  const __m512i v_f800 = _mm512_set1_epi32((uint32_t)0xf800);
+  const __m512i v_d800 = _mm512_set1_epi32((uint32_t)0xd800);
+  const __m512i v_10ffff = _mm512_set1_epi32(0x10FFFF);
+  const __m512i v_10000 = _mm512_set1_epi32(0x10000);
+  const __m512i v_3ff0000 = _mm512_set1_epi32(0x3FF0000);
+  const __m512i v_3ff = _mm512_set1_epi32(0x3FF);
+  const __m512i v_dc00d800 = _mm512_set1_epi32((int32_t)0xDC00D800);
+  int error_idx = 0;
+  error_code code = error_code::SUCCESS;
+  bool err = false;
+
+  while (end - buf >= std::ptrdiff_t(16)) {
+    __m512i in = _mm512_loadu_si512(buf);
 
     // no bits set above 16th bit <=> can pack to UTF16 without surrogate pairs
-    const __m256i saturation_bytemask =
-        _mm256_cmpeq_epi32(_mm256_and_si256(in, v_ffff0000), v_00000000);
-    const uint32_t saturation_bitmask =
-        static_cast<uint32_t>(_mm256_movemask_epi8(saturation_bytemask));
+    const __mmask16 saturation_bitmask =
+        _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_ffff0000), v_00000000);
 
-    if (saturation_bitmask == 0xffffffff) {
-      const __m256i v_f800 = _mm256_set1_epi32((uint32_t)0xf800);
-      const __m256i v_d800 = _mm256_set1_epi32((uint32_t)0xd800);
-      const __m256i forbidden_bytemask =
-          _mm256_cmpeq_epi32(_mm256_and_si256(in, v_f800), v_d800);
-      if (static_cast<uint32_t>(_mm256_movemask_epi8(forbidden_bytemask)) !=
-          0x0) {
-        return std::make_pair(result(error_code::SURROGATE, buf - start),
+    if (saturation_bitmask == 0xffff) {
+      __mmask32 forbidden_bytemask =
+          _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_f800), v_d800);
+
+      __m256i utf16_packed = _mm512_cvtepi32_epi16(in);
+      if (big_endian) {
+        const __m256i swap = _mm256_setr_epi8(
+            1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 1, 0, 3, 2, 5,
+            4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+        utf16_packed = _mm256_shuffle_epi8(utf16_packed, swap);
+      }
+      if (simdutf_unlikely(forbidden_bytemask)) {
+        int idx = _tzcnt_u32(forbidden_bytemask);
+        _mm256_mask_storeu_epi16(
+            utf16_output, __mmask16(_blsmsk_u32(forbidden_bytemask) >> 1),
+            utf16_packed);
+        return std::make_pair(result(error_code::SURROGATE, buf - start + idx),
+                              utf16_output + idx);
+      }
+      _mm256_storeu_si256((__m256i *)utf16_output, utf16_packed);
+      utf16_output += 16;
+    } else {
+      __mmask32 output_mask = ~_pdep_u32(saturation_bitmask, 0xAAAAAAAA);
+      const __mmask16 surrogate_bitmask = __mmask16(~saturation_bitmask);
+      __mmask32 error_surrogate = _mm512_mask_cmpeq_epi32_mask(
+          saturation_bitmask, _mm512_and_si512(in, v_f800), v_d800);
+      __mmask32 error_too_large =
+          _mm512_mask_cmpgt_epu32_mask(surrogate_bitmask, in, v_10ffff);
+      if (simdutf_unlikely(error_surrogate || error_too_large)) {
+        // Need to find the lowest set bit between the two error masks
+        // Need to also write the partial chunk until the error index to output.
+        int large_idx = _tzcnt_u32(error_too_large);
+        int surrogate_idx = _tzcnt_u32(error_surrogate);
+        err = true;
+        if (large_idx < surrogate_idx) {
+          code = error_code::TOO_LARGE;
+          error_idx = large_idx;
+        } else {
+          code = error_code::SURROGATE;
+          error_idx = surrogate_idx;
+        }
+        output_mask &= ((1 << (2 * error_idx)) - 1);
+      }
+      __m512i v1, v2, v;
+      in = _mm512_mask_sub_epi32(in, surrogate_bitmask, in, v_10000);
+      v1 = _mm512_mask_slli_epi32(in, surrogate_bitmask, in, 16);
+      v1 = _mm512_mask_and_epi32(in, surrogate_bitmask, v1, v_3ff0000);
+      v2 = _mm512_mask_srli_epi32(in, surrogate_bitmask, in, 10);
+      v2 = _mm512_mask_and_epi32(in, surrogate_bitmask, v2, v_3ff);
+      v = _mm512_or_si512(v1, v2);
+      in = _mm512_mask_add_epi32(in, surrogate_bitmask, v, v_dc00d800);
+      if (big_endian) {
+        const __m512i swap_512 = _mm512_set_epi8(
+            14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12,
+            13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8,
+            9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5,
+            2, 3, 0, 1);
+        in = _mm512_shuffle_epi8(in, swap_512);
+      }
+      // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
+      // (AMD Zen4 has terrible performance with it, it is effectively broken)
+      __m512i compressed = _mm512_maskz_compress_epi16(output_mask, in);
+      auto written_out = _mm_popcnt_u32(output_mask);
+      _mm512_mask_storeu_epi16(utf16_output, _bzhi_u32(0xFFFFFFFF, written_out),
+                               compressed);
+      //_mm512_mask_compressstoreu_epi16(utf16_output, output_mask, in);
+      utf16_output += written_out;
+      if (simdutf_unlikely(err)) {
+        return std::make_pair(result(code, buf - start + error_idx),
                               utf16_output);
       }
+    }
+    buf += 16;
+  }
 
-      __m128i utf16_packed = _mm_packus_epi32(_mm256_castsi256_si128(in),
-                                              _mm256_extractf128_si256(in, 1));
+  size_t remaining_len = size_t(end - buf);
+  if (remaining_len) {
+    __mmask16 input_mask = __mmask16((1 << remaining_len) - 1);
+    __m512i in = _mm512_maskz_loadu_epi32(input_mask, buf);
+    const __mmask16 saturation_bitmask =
+        _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_ffff0000), v_00000000) &
+        input_mask;
+    if (saturation_bitmask == input_mask) {
+      __mmask32 forbidden_bytemask =
+          _mm512_cmpeq_epi32_mask(_mm512_and_si512(in, v_f800), v_d800);
+      __m256i utf16_packed = _mm512_cvtepi32_epi16(in);
       if (big_endian) {
-        const __m128i swap =
-            _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
-        utf16_packed = _mm_shuffle_epi8(utf16_packed, swap);
-      }
-      _mm_storeu_si128((__m128i *)utf16_output, utf16_packed);
-      utf16_output += 8;
-      buf += 8;
+        const __m256i swap = _mm256_setr_epi8(
+            1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 1, 0, 3, 2, 5,
+            4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
+        utf16_packed = _mm256_shuffle_epi8(utf16_packed, swap);
+      }
+      if (simdutf_unlikely(forbidden_bytemask)) {
+        int idx = _tzcnt_u32(forbidden_bytemask);
+        _mm256_mask_storeu_epi16(
+            utf16_output, __mmask16(_blsmsk_u32(forbidden_bytemask) >> 1),
+            utf16_packed);
+        return std::make_pair(result(error_code::SURROGATE, buf - start + idx),
+                              utf16_output + idx);
+      }
+      _mm256_mask_storeu_epi16(utf16_output, input_mask, utf16_packed);
+      utf16_output += remaining_len;
     } else {
-      size_t forward = 7;
-      size_t k = 0;
-      if (size_t(end - buf) < forward + 1) {
-        forward = size_t(end - buf - 1);
-      }
-      for (; k < forward; k++) {
-        uint32_t word = buf[k];
-        if ((word & 0xFFFF0000) == 0) {
-          // will not generate a surrogate pair
-          if (word >= 0xD800 && word <= 0xDFFF) {
-            return std::make_pair(
-                result(error_code::SURROGATE, buf - start + k), utf16_output);
-          }
-          *utf16_output++ =
-              big_endian
-                  ? char16_t((uint16_t(word) >> 8) | (uint16_t(word) << 8))
-                  : char16_t(word);
+      const __mmask32 output_max_mask = (1 << (remaining_len * 2)) - 1;
+      __mmask32 output_mask =
+          (~_pdep_u32(saturation_bitmask, 0xAAAAAAAA)) & output_max_mask;
+      const __mmask16 surrogate_bitmask =
+          __mmask16(~saturation_bitmask) & input_mask;
+      __mmask32 error_surrogate = _mm512_mask_cmpeq_epi32_mask(
+          saturation_bitmask, _mm512_and_si512(in, v_f800), v_d800);
+      __mmask32 error_too_large =
+          _mm512_mask_cmpgt_epu32_mask(surrogate_bitmask, in, v_10ffff);
+      if (simdutf_unlikely(error_surrogate || error_too_large)) {
+        int large_idx = _tzcnt_u32(error_too_large);
+        int surrogate_idx = _tzcnt_u32(error_surrogate);
+        err = true;
+        if (large_idx < surrogate_idx) {
+          code = error_code::TOO_LARGE;
+          error_idx = large_idx;
         } else {
-          // will generate a surrogate pair
-          if (word > 0x10FFFF) {
-            return std::make_pair(
-                result(error_code::TOO_LARGE, buf - start + k), utf16_output);
-          }
-          word -= 0x10000;
-          uint16_t high_surrogate = uint16_t(0xD800 + (word >> 10));
-          uint16_t low_surrogate = uint16_t(0xDC00 + (word & 0x3FF));
-          if (big_endian) {
-            high_surrogate =
-                uint16_t((high_surrogate >> 8) | (high_surrogate << 8));
-            low_surrogate =
-                uint16_t((low_surrogate >> 8) | (low_surrogate << 8));
-          }
-          *utf16_output++ = char16_t(high_surrogate);
-          *utf16_output++ = char16_t(low_surrogate);
+          code = error_code::SURROGATE;
+          error_idx = surrogate_idx;
         }
+        output_mask &= ((1 << (2 * error_idx)) - 1);
+      }
+      __m512i v1, v2, v;
+      in = _mm512_mask_sub_epi32(in, surrogate_bitmask, in, v_10000);
+      v1 = _mm512_mask_slli_epi32(in, surrogate_bitmask, in, 16);
+      v1 = _mm512_mask_and_epi32(in, surrogate_bitmask, v1, v_3ff0000);
+      v2 = _mm512_mask_srli_epi32(in, surrogate_bitmask, in, 10);
+      v2 = _mm512_mask_and_epi32(in, surrogate_bitmask, v2, v_3ff);
+      v = _mm512_or_si512(v1, v2);
+      in = _mm512_mask_add_epi32(in, surrogate_bitmask, v, v_dc00d800);
+      if (big_endian) {
+        const __m512i swap_512 = _mm512_set_epi8(
+            14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12,
+            13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8,
+            9, 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5,
+            2, 3, 0, 1);
+        in = _mm512_shuffle_epi8(in, swap_512);
+      }
+      // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
+      // (AMD Zen4 has terrible performance with it, it is effectively broken)
+      __m512i compressed = _mm512_maskz_compress_epi16(output_mask, in);
+      auto written_out = _mm_popcnt_u32(output_mask);
+      _mm512_mask_storeu_epi16(utf16_output, _bzhi_u32(0xFFFFFFFF, written_out),
+                               compressed);
+      //_mm512_mask_compressstoreu_epi16(utf16_output, output_mask, in);
+      utf16_output += written_out;
+      if (simdutf_unlikely(err)) {
+        return std::make_pair(result(code, buf - start + error_idx),
+                              utf16_output);
       }
-      buf += k;
     }
+    buf += remaining_len;
   }
 
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf16_output);
 }
 /* end file src/icelake/icelake_convert_utf32_to_utf16.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_ASCII
 /* begin file src/icelake/icelake_ascii_validation.inl.cpp */
 // file included directly
 
@@ -25971,20 +27380,22 @@ bool validate_ascii(const char *buf, size_t len) {
   return (_mm512_test_epi8_mask(running_or, running_or) == 0);
 }
 /* end file src/icelake/icelake_ascii_validation.inl.cpp */
+#endif // SIMDUTF_FEATURE_ASCII
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/icelake/icelake_utf32_validation.inl.cpp */
 // file included directly
 
-const char32_t *validate_utf32(const char32_t *buf, size_t len) {
-  if (len < 16) {
-    return buf;
+bool validate_utf32(const char32_t *buf, size_t len) {
+  if (simdutf_unlikely(len == 0)) {
+    return true;
   }
-  const char32_t *end = buf + len - 16;
+  const char32_t *end = buf + len;
 
   const __m512i offset = _mm512_set1_epi32((uint32_t)0xffff2000);
   __m512i currentmax = _mm512_setzero_si512();
   __m512i currentoffsetmax = _mm512_setzero_si512();
 
-  while (buf <= end) {
+  while (buf < end - 16) {
     __m512i utf32 = _mm512_loadu_si512((const __m512i *)buf);
     buf += 16;
     currentoffsetmax =
@@ -25992,22 +27403,30 @@ const char32_t *validate_utf32(const char32_t *buf, size_t len) {
     currentmax = _mm512_max_epu32(utf32, currentmax);
   }
 
+  __m512i utf32 =
+      _mm512_maskz_loadu_epi32(__mmask16((1 << (end - buf)) - 1), buf);
+  currentoffsetmax =
+      _mm512_max_epu32(_mm512_add_epi32(utf32, offset), currentoffsetmax);
+  currentmax = _mm512_max_epu32(utf32, currentmax);
+
   const __m512i standardmax = _mm512_set1_epi32((uint32_t)0x10ffff);
   const __m512i standardoffsetmax = _mm512_set1_epi32((uint32_t)0xfffff7ff);
-  __m512i is_zero =
-      _mm512_xor_si512(_mm512_max_epu32(currentmax, standardmax), standardmax);
-  if (_mm512_test_epi8_mask(is_zero, is_zero) != 0) {
-    return nullptr;
+  const auto outside_range = _mm512_cmpgt_epu32_mask(currentmax, standardmax);
+  if (outside_range != 0) {
+    return false;
   }
-  is_zero = _mm512_xor_si512(
-      _mm512_max_epu32(currentoffsetmax, standardoffsetmax), standardoffsetmax);
-  if (_mm512_test_epi8_mask(is_zero, is_zero) != 0) {
-    return nullptr;
+
+  const auto surrogate =
+      _mm512_cmpgt_epu32_mask(currentoffsetmax, standardoffsetmax);
+  if (surrogate != 0) {
+    return false;
   }
 
-  return buf;
+  return true;
 }
 /* end file src/icelake/icelake_utf32_validation.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/icelake/icelake_convert_latin1_to_utf8.inl.cpp */
 // file included directly
 
@@ -26117,6 +27536,8 @@ size_t latin1_to_utf8_avx512_start(const char *buf, size_t len,
   return (size_t)(utf8_output - start);
 }
 /* end file src/icelake/icelake_convert_latin1_to_utf8.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/icelake/icelake_convert_latin1_to_utf16.inl.cpp */
 // file included directly
 template <endianness big_endian>
@@ -26155,28 +27576,35 @@ size_t icelake_convert_latin1_to_utf16(const char *latin1_input, size_t len,
   return len;
 }
 /* end file src/icelake/icelake_convert_latin1_to_utf16.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF32
 /* begin file src/icelake/icelake_convert_latin1_to_utf32.inl.cpp */
-std::pair<const char *, char32_t *>
-avx512_convert_latin1_to_utf32(const char *buf, size_t len,
-                               char32_t *utf32_output) {
-  size_t rounded_len = len & ~0xF; // Round down to nearest multiple of 16
-
-  for (size_t i = 0; i < rounded_len; i += 16) {
+void avx512_convert_latin1_to_utf32(const char *buf, size_t len,
+                                    char32_t *utf32_output) {
+  while (len >= 16) {
     // Load 16 Latin1 characters into a 128-bit register
-    __m128i in = _mm_loadu_si128((__m128i *)&buf[i]);
+    __m128i in = _mm_loadu_si128((__m128i *)buf);
 
     // Zero extend each set of 8 Latin1 characters to 16 32-bit integers using
     // vpmovzxbd
     __m512i out = _mm512_cvtepu8_epi32(in);
 
     // Store the results back to memory
-    _mm512_storeu_si512((__m512i *)&utf32_output[i], out);
+    _mm512_storeu_si512((__m512i *)utf32_output, out);
+
+    len -= 16;
+    buf += 16;
+    utf32_output += 16;
   }
 
-  // Return pointers pointing to where we left off
-  return std::make_pair(buf + rounded_len, utf32_output + rounded_len);
+  __mmask16 mask = __mmask16((1 << len) - 1);
+  __m128i in = _mm_maskz_loadu_epi8(mask, buf);
+  __m512i out = _mm512_cvtepu8_epi32(in);
+  _mm512_mask_storeu_epi32((__m512i *)utf32_output, mask, out);
 }
 /* end file src/icelake/icelake_convert_latin1_to_utf32.inl.cpp */
+#endif // SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/icelake/icelake_base64.inl.cpp */
 // file included directly
 /**
@@ -26267,7 +27695,7 @@ size_t encode_base64(char *dst, const char *src, size_t srclen,
   return (size_t)(out - (uint8_t *)dst) + output_len;
 }
 
-template <bool base64_url>
+template <bool base64_url, bool ignore_garbage>
 static inline uint64_t to_base64_mask(block64 *b, uint64_t *error,
                                       uint64_t input_mask = UINT64_MAX) {
   __m512i input = b->chunks[0];
@@ -26309,7 +27737,7 @@ static inline uint64_t to_base64_mask(block64 *b, uint64_t *error,
   const __m512i translated = _mm512_permutex2var_epi8(lookup0, input, lookup1);
   const __m512i combined = _mm512_or_si512(translated, input);
   const __mmask64 mask = _mm512_movepi8_mask(combined) & input_mask;
-  if (mask) {
+  if (!ignore_garbage && mask) {
     const __mmask64 spaces =
         _mm512_cmpeq_epi8_mask(_mm512_shuffle_epi8(ascii_space_tbl, input),
                                input) &
@@ -26390,7 +27818,7 @@ static inline void base64_decode_block(char *out, block64 *b) {
   base64_decode(out, b->chunks[0]);
 }
 
-template <bool base64_url, typename chartype>
+template <bool base64_url, bool ignore_garbage, typename chartype>
 full_result
 compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                        base64_options options,
@@ -26402,11 +27830,12 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       srclen; // location of the first padding character if any
   size_t equalsigns = 0;
   // skip trailing spaces
-  while (srclen > 0 && scalar::base64::is_eight_byte(src[srclen - 1]) &&
+  while (!ignore_garbage && srclen > 0 &&
+         scalar::base64::is_eight_byte(src[srclen - 1]) &&
          to_base64[uint8_t(src[srclen - 1])] == 64) {
     srclen--;
   }
-  if (srclen > 0 && src[srclen - 1] == '=') {
+  if (!ignore_garbage && srclen > 0 && src[srclen - 1] == '=') {
     equallocation = srclen - 1;
     srclen--;
     equalsigns = 1;
@@ -26422,7 +27851,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -26442,8 +27877,9 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       load_block(&b, src);
       src += 64;
       uint64_t error = 0;
-      uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
-      if (error) {
+      uint64_t badcharmask =
+          to_base64_mask<base64_url, ignore_garbage>(&b, &error);
+      if (!ignore_garbage && error) {
         src -= 64;
         size_t error_offset = _tzcnt_u64(error);
         return {error_code::INVALID_BASE64_CHARACTER,
@@ -26479,8 +27915,9 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     block64 b;
     load_block_partial(&b, src, input_mask);
     uint64_t error = 0;
-    uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error, input_mask);
-    if (error) {
+    uint64_t badcharmask =
+        to_base64_mask<base64_url, ignore_garbage>(&b, &error, input_mask);
+    if (!ignore_garbage && error) {
       size_t error_offset = _tzcnt_u64(error);
       return {error_code::INVALID_BASE64_CHARACTER,
               size_t(src - srcinit + error_offset), size_t(dst - dstinit)};
@@ -26513,14 +27950,16 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
         5, 6, 0, 1, 2);
     const __m512i shuffled = _mm512_permutexvar_epi8(pack, merged);
 
-    if (last_chunk_options == last_chunk_handling_options::strict &&
+    if (!ignore_garbage &&
+        last_chunk_options == last_chunk_handling_options::strict &&
         (idx != 1) && ((idx + equalsigns) & 3) != 0) {
       // The partial chunk was at src - idx
       _mm512_mask_storeu_epi8((__m512i *)dst, output_mask, shuffled);
       dst += output_len;
       return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
               size_t(dst - dstinit)};
-    } else if (last_chunk_options ==
+    } else if (!ignore_garbage &&
+               last_chunk_options ==
                    last_chunk_handling_options::stop_before_partial &&
                (idx != 1) && ((idx + equalsigns) & 3) != 0) {
       // Rewind src to before partial chunk
@@ -26529,7 +27968,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       src -= idx;
     } else {
       if (idx == 2) {
-        if (last_chunk_options == last_chunk_handling_options::strict) {
+        if (!ignore_garbage &&
+            last_chunk_options == last_chunk_handling_options::strict) {
           uint32_t triple = (uint32_t(bufferptr[-2]) << 3 * 6) +
                             (uint32_t(bufferptr[-1]) << 2 * 6);
           if (triple & 0xffff) {
@@ -26544,7 +27984,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
         _mm512_mask_storeu_epi8((__m512i *)dst, output_mask, shuffled);
         dst += output_len;
       } else if (idx == 3) {
-        if (last_chunk_options == last_chunk_handling_options::strict) {
+        if (!ignore_garbage &&
+            last_chunk_options == last_chunk_handling_options::strict) {
           uint32_t triple = (uint32_t(bufferptr[-3]) << 3 * 6) +
                             (uint32_t(bufferptr[-2]) << 2 * 6) +
                             (uint32_t(bufferptr[-1]) << 1 * 6);
@@ -26559,7 +28000,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
         output_len += 2;
         _mm512_mask_storeu_epi8((__m512i *)dst, output_mask, shuffled);
         dst += output_len;
-      } else if (idx == 1) {
+      } else if (!ignore_garbage && idx == 1) {
         _mm512_mask_storeu_epi8((__m512i *)dst, output_mask, shuffled);
         dst += output_len;
         return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
@@ -26570,7 +28011,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       }
     }
 
-    if (last_chunk_options != stop_before_partial && equalsigns > 0) {
+    if (!ignore_garbage && last_chunk_options != stop_before_partial &&
+        equalsigns > 0) {
       size_t output_count = size_t(dst - dstinit);
       if ((output_count % 3 == 0) ||
           ((output_count % 3) + 1 + equalsigns != 4)) {
@@ -26581,7 +28023,15 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     return {SUCCESS, srclen, size_t(dst - dstinit)};
   }
 
-  if (equalsigns > 0) {
+  if (!ignore_garbage && equalsigns > 0) {
+    if (last_chunk_options == last_chunk_handling_options::strict) {
+      return {BASE64_INPUT_REMAINDER, size_t(src - srcinit),
+              size_t(dst - dstinit)};
+    }
+    if (last_chunk_options ==
+        last_chunk_handling_options::stop_before_partial) {
+      return {SUCCESS, size_t(src - srcinit), size_t(dst - dstinit)};
+    }
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -26590,6 +28040,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/icelake/icelake_base64.inl.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
 
 #include <cstdint>
 
@@ -26597,36 +28048,202 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
 } // namespace icelake
 } // namespace simdutf
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+/* begin file src/generic/utf32.h */
+#include <limits>
+
 namespace simdutf {
 namespace icelake {
+namespace {
+namespace utf32 {
+
+template <typename T> T min(T a, T b) { return a <= b ? a : b; }
+
+size_t utf8_length_from_utf32(const char32_t *input, size_t length) {
+  using vector_u32 = simd32<uint32_t>;
+
+  const char32_t *start = input;
+
+  // we add up to three ones in a single iteration (see the vectorized loop in
+  // section #2 below)
+  const size_t max_increment = 3;
+
+  const size_t N = vector_u32::ELEMENTS;
 
+  const auto one = vector_u32::splat(1);
+  const auto v_ffffff80 = vector_u32::splat(0xffffff80);
+  const auto v_fffff800 = vector_u32::splat(0xfffff800);
+  const auto v_ffff0000 = vector_u32::splat(0xffff0000);
+
+  size_t counter = 0;
+
+  // 1. vectorized loop unrolled 4 times
+  {
+    // we use uint32 counters, this is
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / (max_increment * 4);
+    size_t blocks = length / (N * 4);
+    length -= blocks * (N * 4);
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      simd32<uint32_t> acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in0 = vector_u32(input + 0 * N);
+        const auto in1 = vector_u32(input + 1 * N);
+        const auto in2 = vector_u32(input + 2 * N);
+        const auto in3 = vector_u32(input + 3 * N);
+
+        acc += min(one, in0 & v_ffffff80);
+        acc += min(one, in1 & v_ffffff80);
+        acc += min(one, in2 & v_ffffff80);
+        acc += min(one, in3 & v_ffffff80);
+
+        acc += min(one, in0 & v_fffff800);
+        acc += min(one, in1 & v_fffff800);
+        acc += min(one, in2 & v_fffff800);
+        acc += min(one, in3 & v_fffff800);
+
+        acc += min(one, in0 & v_ffff0000);
+        acc += min(one, in1 & v_ffff0000);
+        acc += min(one, in2 & v_ffff0000);
+        acc += min(one, in3 & v_ffff0000);
+
+        input += 4 * N;
+      }
+
+      counter += acc.sum();
+    }
+  }
+
+  // 2. vectorized loop for tail
+  {
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / max_increment;
+    size_t blocks = length / N;
+    length -= blocks * N;
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      auto acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in = vector_u32(input);
+
+        acc += min(one, in & v_ffffff80);
+        acc += min(one, in & v_fffff800);
+        acc += min(one, in & v_ffff0000);
+
+        input += N;
+      }
+
+      counter += acc.sum();
+    }
+  }
+
+  const size_t consumed = input - start;
+  if (consumed != 0) {
+    // We don't count 0th bytes in the vectorized loops above, this
+    // is why we need to count them in the end.
+    counter += consumed;
+  }
+
+  return counter + scalar::utf32::utf8_length_from_utf32(input, length);
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace icelake
+} // namespace simdutf
+/* end file src/generic/utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+namespace simdutf {
+namespace icelake {
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
   // If there is a BOM, then we trust it.
   auto bom_encoding = simdutf::BOM::check_bom(input, length);
-  // todo: convert to a one-pass algorithm
   if (bom_encoding != encoding_type::unspecified) {
     return bom_encoding;
   }
+
   int out = 0;
-  if (validate_utf8(input, length)) {
+  uint32_t utf16_err = (length % 2);
+  uint32_t utf32_err = (length % 4);
+  uint32_t ends_with_high = 0;
+  avx512_utf8_checker checker{};
+  const __m512i offset = _mm512_set1_epi32((uint32_t)0xffff2000);
+  __m512i currentmax = _mm512_setzero_si512();
+  __m512i currentoffsetmax = _mm512_setzero_si512();
+  const char *ptr = input;
+  const char *end = ptr + length;
+  for (; end - ptr >= 64; ptr += 64) {
+    // utf8 checks
+    const __m512i data = _mm512_loadu_si512((const __m512i *)ptr);
+    checker.check_next_input(data);
+
+    // utf16le_checks
+    __m512i diff = _mm512_sub_epi16(data, _mm512_set1_epi16(uint16_t(0xD800)));
+    __mmask32 surrogates =
+        _mm512_cmplt_epu16_mask(diff, _mm512_set1_epi16(uint16_t(0x0800)));
+    __mmask32 highsurrogates =
+        _mm512_cmplt_epu16_mask(diff, _mm512_set1_epi16(uint16_t(0x0400)));
+    __mmask32 lowsurrogates = surrogates ^ highsurrogates;
+    utf16_err |= (((highsurrogates << 1) | ends_with_high) != lowsurrogates);
+    ends_with_high = ((highsurrogates & 0x80000000) != 0);
+
+    // utf32le checks
+    currentoffsetmax =
+        _mm512_max_epu32(_mm512_add_epi32(data, offset), currentoffsetmax);
+    currentmax = _mm512_max_epu32(data, currentmax);
+  }
+
+  // last block with 0 <= len < 64
+  __mmask64 read_mask = (__mmask64(1) << (end - ptr)) - 1;
+  const __m512i data = _mm512_maskz_loadu_epi8(read_mask, (const __m512i *)ptr);
+  checker.check_next_input(data);
+
+  __m512i diff = _mm512_sub_epi16(data, _mm512_set1_epi16(uint16_t(0xD800)));
+  __mmask32 surrogates =
+      _mm512_cmplt_epu16_mask(diff, _mm512_set1_epi16(uint16_t(0x0800)));
+  __mmask32 highsurrogates =
+      _mm512_cmplt_epu16_mask(diff, _mm512_set1_epi16(uint16_t(0x0400)));
+  __mmask32 lowsurrogates = surrogates ^ highsurrogates;
+  utf16_err |= (((highsurrogates << 1) | ends_with_high) != lowsurrogates);
+
+  currentoffsetmax =
+      _mm512_max_epu32(_mm512_add_epi32(data, offset), currentoffsetmax);
+  currentmax = _mm512_max_epu32(data, currentmax);
+
+  const __m512i standardmax = _mm512_set1_epi32((uint32_t)0x10ffff);
+  const __m512i standardoffsetmax = _mm512_set1_epi32((uint32_t)0xfffff7ff);
+  __m512i is_zero =
+      _mm512_xor_si512(_mm512_max_epu32(currentmax, standardmax), standardmax);
+  utf32_err |= (_mm512_test_epi8_mask(is_zero, is_zero) != 0);
+  is_zero = _mm512_xor_si512(
+      _mm512_max_epu32(currentoffsetmax, standardoffsetmax), standardoffsetmax);
+  utf32_err |= (_mm512_test_epi8_mask(is_zero, is_zero) != 0);
+  checker.check_eof();
+  bool is_valid_utf8 = !checker.errors();
+  if (is_valid_utf8) {
     out |= encoding_type::UTF8;
   }
-  if ((length % 2) == 0) {
-    if (validate_utf16le(reinterpret_cast<const char16_t *>(input),
-                         length / 2)) {
-      out |= encoding_type::UTF16_LE;
-    }
+  if (utf16_err == 0) {
+    out |= encoding_type::UTF16_LE;
   }
-  if ((length % 4) == 0) {
-    if (validate_utf32(reinterpret_cast<const char32_t *>(input), length / 4)) {
-      out |= encoding_type::UTF32_LE;
-    }
+  if (utf32_err == 0) {
+    out |= encoding_type::UTF32_LE;
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -26647,7 +28264,9 @@ implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   checker.check_eof();
   return !checker.errors();
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -26690,7 +28309,9 @@ simdutf_warn_unused result implementation::validate_utf8_with_errors(
   }
   return result(error_code::SUCCESS, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
   return icelake::validate_ascii(buf, len);
@@ -26720,7 +28341,9 @@ simdutf_warn_unused result implementation::validate_ascii_with_errors(
   }
   return result(error_code::SUCCESS, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -26768,7 +28391,9 @@ implementation::validate_utf16le(const char16_t *buf,
   }
   return true;
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -26941,19 +28566,16 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
   }
   return result(error_code::SUCCESS, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
-  const char32_t *tail = icelake::validate_utf32(buf, len);
-  if (tail) {
-    return scalar::utf32::validate(tail, len - (tail - buf));
-  } else {
-    // we come here if there was an error, or buf was nullptr which may happen
-    // for empty input.
-    return len == 0;
-  }
+  return icelake::validate_utf32(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
   const char32_t *buf_orig = buf;
@@ -27006,12 +28628,16 @@ simdutf_warn_unused result implementation::validate_utf32_with_errors(
 
   return result(error_code::SUCCESS, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   return icelake::latin1_to_utf8_avx512_start(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   return icelake_convert_latin1_to_utf16<endianness::LITTLE>(buf, len,
@@ -27023,26 +28649,17 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   return icelake_convert_latin1_to_utf16<endianness::BIG>(buf, len,
                                                           utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
-  std::pair<const char *, char32_t *> ret =
-      avx512_convert_latin1_to_utf32(buf, len, utf32_output);
-  if (ret.first == nullptr) {
-    return 0;
-  }
-  size_t converted_chars = ret.second - utf32_output;
-  if (ret.first != buf + len) {
-    const size_t scalar_converted_chars = scalar::latin1_to_utf32::convert(
-        ret.first, len - (ret.first - buf), ret.second);
-    if (scalar_converted_chars == 0) {
-      return 0;
-    }
-    converted_chars += scalar_converted_chars;
-  }
-  return converted_chars;
+  avx512_convert_latin1_to_utf32(buf, len, utf32_output);
+  return len;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return icelake::utf8_to_latin1_avx512(buf, len, latin1_output);
@@ -27070,7 +28687,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return icelake::valid_utf8_to_latin1_avx512(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16_result ret =
@@ -27169,7 +28788,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
 
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_out) const noexcept {
   uint32_t *utf32_output = reinterpret_cast<uint32_t *>(utf32_out);
@@ -27301,7 +28922,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
 
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   return icelake_convert_utf16_to_latin1<endianness::LITTLE>(buf, len,
@@ -27341,7 +28964,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: implement custom function
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   size_t outlen;
@@ -27401,7 +29026,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   return icelake_convert_utf32_to_latin1(buf, len, latin1_output);
@@ -27417,7 +29044,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   return icelake_convert_utf32_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -27463,7 +29092,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -27472,15 +29103,6 @@ simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     return 0;
   }
   size_t saved_bytes = ret.second - utf16_output;
-  if (ret.first != buf + len) {
-    const size_t scalar_saved_bytes =
-        scalar::utf32_to_utf16::convert<endianness::LITTLE>(
-            ret.first, len - (ret.first - buf), ret.second);
-    if (scalar_saved_bytes == 0) {
-      return 0;
-    }
-    saved_bytes += scalar_saved_bytes;
-  }
   return saved_bytes;
 }
 
@@ -27492,15 +29114,6 @@ simdutf_warn_unused size_t implementation::convert_utf32_to_utf16be(
     return 0;
   }
   size_t saved_bytes = ret.second - utf16_output;
-  if (ret.first != buf + len) {
-    const size_t scalar_saved_bytes =
-        scalar::utf32_to_utf16::convert<endianness::BIG>(
-            ret.first, len - (ret.first - buf), ret.second);
-    if (scalar_saved_bytes == 0) {
-      return 0;
-    }
-    saved_bytes += scalar_saved_bytes;
-  }
   return saved_bytes;
 }
 
@@ -27511,16 +29124,8 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf16le_with_errors(
   std::pair<result, char16_t *> ret =
       avx512_convert_utf32_to_utf16_with_errors<endianness::LITTLE>(
           buf, len, utf16_output);
-  if (ret.first.count != len) {
-    result scalar_res =
-        scalar::utf32_to_utf16::convert_with_errors<endianness::LITTLE>(
-            buf + ret.first.count, len - ret.first.count, ret.second);
-    if (scalar_res.error) {
-      scalar_res.count += ret.first.count;
-      return scalar_res;
-    } else {
-      ret.second += scalar_res.count;
-    }
+  if (ret.first.error) {
+    return ret.first;
   }
   ret.first.count =
       ret.second -
@@ -27535,16 +29140,8 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf16be_with_errors(
   std::pair<result, char16_t *> ret =
       avx512_convert_utf32_to_utf16_with_errors<endianness::BIG>(buf, len,
                                                                  utf16_output);
-  if (ret.first.count != len) {
-    result scalar_res =
-        scalar::utf32_to_utf16::convert_with_errors<endianness::BIG>(
-            buf + ret.first.count, len - ret.first.count, ret.second);
-    if (scalar_res.error) {
-      scalar_res.count += ret.first.count;
-      return scalar_res;
-    } else {
-      ret.second += scalar_res.count;
-    }
+  if (ret.first.error) {
+    return ret.first;
   }
   ret.first.count =
       ret.second -
@@ -27698,7 +29295,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
   }
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -27775,7 +29374,9 @@ simdutf_warn_unused size_t implementation::count_utf16be(
   return count + scalar::utf16::count_code_points<endianness::BIG>(
                      ptr, length - (ptr - input));
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   const uint8_t *str = reinterpret_cast<const uint8_t *>(input);
@@ -27832,36 +29433,21 @@ implementation::count_utf8(const char *input, size_t length) const noexcept {
     }
   }
 
-  __m256i first_half = _mm512_extracti64x4_epi64(unrolled_popcount, 0);
-  __m256i second_half = _mm512_extracti64x4_epi64(unrolled_popcount, 1);
-  answer -= (size_t)_mm256_extract_epi64(first_half, 0) +
-            (size_t)_mm256_extract_epi64(first_half, 1) +
-            (size_t)_mm256_extract_epi64(first_half, 2) +
-            (size_t)_mm256_extract_epi64(first_half, 3) +
-            (size_t)_mm256_extract_epi64(second_half, 0) +
-            (size_t)_mm256_extract_epi64(second_half, 1) +
-            (size_t)_mm256_extract_epi64(second_half, 2) +
-            (size_t)_mm256_extract_epi64(second_half, 3);
+  answer -= _mm512_reduce_add_epi64(unrolled_popcount);
 
   return answer + scalar::utf8::count_code_points(
                       reinterpret_cast<const char *>(str + i), length - i);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return scalar::utf16::latin1_length_from_utf16(length);
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return scalar::utf32::latin1_length_from_utf32(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   const char16_t *ptr = input;
@@ -27942,7 +29528,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
   return count + scalar::utf16::utf8_length_from_utf16<endianness::BIG>(
                      ptr, length - (ptr - input));
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return implementation::count_utf16le(input, length);
@@ -27952,17 +29540,9 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return implementation::count_utf16be(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf16_length_from_latin1(length);
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf32_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t length) const noexcept {
   const uint8_t *str = reinterpret_cast<const uint8_t *>(input);
@@ -28027,16 +29607,7 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
           eight_64bits, _mm512_sad_epu8(runner, _mm512_setzero_si512()));
     }
 
-    __m256i first_half = _mm512_extracti64x4_epi64(eight_64bits, 0);
-    __m256i second_half = _mm512_extracti64x4_epi64(eight_64bits, 1);
-    answer += (size_t)_mm256_extract_epi64(first_half, 0) +
-              (size_t)_mm256_extract_epi64(first_half, 1) +
-              (size_t)_mm256_extract_epi64(first_half, 2) +
-              (size_t)_mm256_extract_epi64(first_half, 3) +
-              (size_t)_mm256_extract_epi64(second_half, 0) +
-              (size_t)_mm256_extract_epi64(second_half, 1) +
-              (size_t)_mm256_extract_epi64(second_half, 2) +
-              (size_t)_mm256_extract_epi64(second_half, 3);
+    answer += _mm512_reduce_add_epi64(eight_64bits);
   } else if (answer > 0) {
     for (; i + sizeof(__m512i) <= length; i += sizeof(__m512i)) {
       __m512i latin = _mm512_loadu_si512((const __m512i *)(str + i));
@@ -28047,7 +29618,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return answer + scalar::latin1::utf8_length_from_latin1(
                       reinterpret_cast<const char *>(str + i), length - i);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   size_t pos = 0;
@@ -28067,43 +29640,16 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
   return count +
          scalar::utf8::utf16_length_from_utf8(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
-  const char32_t *ptr = input;
-  size_t count{0};
-
-  if (length >= 16) {
-    const char32_t *end = input + length - 16;
-
-    const __m512i v_0000_007f = _mm512_set1_epi32((uint32_t)0x7f);
-    const __m512i v_0000_07ff = _mm512_set1_epi32((uint32_t)0x7ff);
-    const __m512i v_0000_ffff = _mm512_set1_epi32((uint32_t)0x0000ffff);
-
-    while (ptr <= end) {
-      __m512i utf32 = _mm512_loadu_si512((const __m512i *)ptr);
-      ptr += 16;
-      __mmask16 ascii_bitmask = _mm512_cmple_epu32_mask(utf32, v_0000_007f);
-      __mmask16 two_bytes_bitmask = _mm512_mask_cmple_epu32_mask(
-          _knot_mask16(ascii_bitmask), utf32, v_0000_07ff);
-      __mmask16 three_bytes_bitmask = _mm512_mask_cmple_epu32_mask(
-          _knot_mask16(_mm512_kor(ascii_bitmask, two_bytes_bitmask)), utf32,
-          v_0000_ffff);
-
-      size_t ascii_count = count_ones(ascii_bitmask);
-      size_t two_bytes_count = count_ones(two_bytes_bitmask);
-      size_t three_bytes_count = count_ones(three_bytes_bitmask);
-      size_t four_bytes_count =
-          16 - ascii_count - two_bytes_count - three_bytes_count;
-      count += ascii_count + 2 * two_bytes_count + 3 * three_bytes_count +
-               4 * four_bytes_count;
-    }
-  }
-
-  return count +
-         scalar::utf32::utf8_length_from_utf32(ptr, length - (ptr - input));
+  return utf32::utf8_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const char32_t *ptr = input;
@@ -28127,65 +29673,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(ptr, length - (ptr - input));
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return implementation::count_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -28197,6 +29780,7 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
     return encode_base64<false>(output, input, length, options);
   }
 }
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // namespace icelake
 } // namespace simdutf
@@ -28218,7 +29802,6 @@ SIMDUTF_POP_DISABLE_WARNINGS
 #endif
 #if SIMDUTF_IMPLEMENTATION_HASWELL
 /* begin file src/haswell/implementation.cpp */
-
 /* begin file src/simdutf/haswell/begin.h */
 // redefining SIMDUTF_IMPLEMENTATION to "haswell"
 // #define SIMDUTF_IMPLEMENTATION haswell
@@ -28244,25 +29827,15 @@ namespace {
 #endif
 using namespace simd;
 
+#if SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    SIMDUTF_FEATURE_UTF8
 simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   return input.reduce_or().is_ascii();
 }
+#endif // SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // SIMDUTF_FEATURE_UTF8
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<uint8_t> is_second_byte =
-      prev1.saturating_sub(0b11000000u - 1); // Only 11______ will be > 0
-  simd8<uint8_t> is_third_byte =
-      prev2.saturating_sub(0b11100000u - 1); // Only 111_____ will be > 0
-  simd8<uint8_t> is_fourth_byte =
-      prev3.saturating_sub(0b11110000u - 1); // Only 1111____ will be > 0
-  // Caller requires a bool (all 1's). All values resulting from the subtraction
-  // will be <= 64, so signed comparison is fine.
-  return simd8<int8_t>(is_second_byte | is_third_byte | is_fourth_byte) >
-         int8_t(0);
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -28272,288 +29845,33 @@ must_be_2_3_continuation(const simd8<uint8_t> prev2,
       prev3.saturating_sub(0xf0u - 0x80); // Only 1111____ will be > 0x80
   return simd8<bool>(is_third_byte | is_fourth_byte);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+namespace utf16 {
 /* begin file src/haswell/avx2_validate_utf16.cpp */
-/*
-    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
-
-    In a vectorized algorithm we want to examine the most significant
-    nibble in order to select a fast path. If none of highest nibbles
-    are 0xD (13), than we are sure that UTF-16 chunk in a vector
-    register is valid.
-
-    Let us analyze what we need to check if the nibble is 0xD. The
-    value of the preceding nibble determines what we have:
-
-    0xd000 .. 0xd7ff - a valid word
-    0xd800 .. 0xdbff - low surrogate
-    0xdc00 .. 0xdfff - high surrogate
-
-    Other constraints we have to consider:
-    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
-    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
-    - there must not be sole low surrogate nor high surrogate
-
-    We're going to build three bitmasks based on the 3rd nibble:
-    - V = valid word,
-    - L = low surrogate (0xd800 .. 0xdbff)
-    - H = high surrogate (0xdc00 .. 0xdfff)
-
-      0   1   2   3   4   5   6   7    <--- word index
-    [ V | L | H | L | H | V | V | L ]
-      1   0   0   0   0   1   1   0     - V = valid masks
-      0   1   0   1   0   0   0   1     - L = low surrogate
-      0   0   1   0   1   0   0   0     - H high surrogate
-
-
-      1   0   0   0   0   1   1   0   V = valid masks
-      0   1   0   1   0   0   0   0   a = L & (H >> 1)
-      0   0   1   0   1   0   0   0   b = a << 1
-      1   1   1   1   1   1   1   0   c = V | a | b
-                                  ^
-                                  the last bit can be zero, we just consume 7
-   code units and recheck this word in the next iteration
-*/
-
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
 template <endianness big_endian>
-const char16_t *avx2_validate_utf16(const char16_t *input, size_t size) {
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::ELEMENTS * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 = simd16<uint16_t>(input + simd16<uint16_t>::ELEMENTS);
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-
-    const auto t0 = in0.shr<8>();
-    const auto t1 = in1.shr<8>();
-
-    const auto in = simd16<uint16_t>::pack(t0, t1);
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
-    if (surrogates_bitmask == 0x0) {
-      input += simd16<uint16_t>::ELEMENTS * 2;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint32_t V = ~surrogates_bitmask;
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint32_t H = vH.to_bitmask();
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint32_t L = ~H & surrogates_bitmask;
-
-      const uint32_t a =
-          L & (H >> 1); // A low surrogate must be followed by high one.
-                        // (A low surrogate placed in the 7th register's word
-                        // is an exception we handle.)
-      const uint32_t b =
-          a << 1; // Just mark that the opposite fact is hold,
-                  // thanks to that we have only two masks for valid case.
-      const uint32_t c = V | a | b; // Combine all the masks into the final one.
-
-      if (c == 0xffffffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += simd16<uint16_t>::ELEMENTS * 2;
-      } else if (c == 0x7fffffff) {
-        // The 31 lower code units of the input register contains valid UTF-16.
-        // The 31 word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += simd16<uint16_t>::ELEMENTS * 2 - 1;
-      } else {
-        return nullptr;
-      }
-    }
-  }
-
-  return input;
-}
-
-template <endianness big_endian>
-const result avx2_validate_utf16_with_errors(const char16_t *input,
-                                             size_t size) {
-  if (simdutf_unlikely(size == 0)) {
-    return result(error_code::SUCCESS, 0);
-  }
-  const char16_t *start = input;
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::ELEMENTS * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 = simd16<uint16_t>(input + simd16<uint16_t>::ELEMENTS);
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
+simd8<uint8_t> utf16_gather_high_bytes(const simd16<uint16_t> &in0,
+                                       const simd16<uint16_t> &in1) {
+  if (big_endian) {
+    // we want lower bytes
+    const auto mask = simd16<uint16_t>(0x00ff);
+    const auto t0 = in0 & mask;
+    const auto t1 = in1 & mask;
 
+    return simd16<uint16_t>::pack(t0, t1);
+  } else {
     const auto t0 = in0.shr<8>();
     const auto t1 = in1.shr<8>();
 
-    const auto in = simd16<uint16_t>::pack(t0, t1);
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
-    if (surrogates_bitmask == 0x0) {
-      input += simd16<uint16_t>::ELEMENTS * 2;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint32_t V = ~surrogates_bitmask;
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint32_t H = vH.to_bitmask();
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint32_t L = ~H & surrogates_bitmask;
-
-      const uint32_t a =
-          L & (H >> 1); // A low surrogate must be followed by high one.
-                        // (A low surrogate placed in the 7th register's word
-                        // is an exception we handle.)
-      const uint32_t b =
-          a << 1; // Just mark that the opposite fact is hold,
-                  // thanks to that we have only two masks for valid case.
-      const uint32_t c = V | a | b; // Combine all the masks into the final one.
-
-      if (c == 0xffffffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += simd16<uint16_t>::ELEMENTS * 2;
-      } else if (c == 0x7fffffff) {
-        // The 31 lower code units of the input register contains valid UTF-16.
-        // The 31 word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += simd16<uint16_t>::ELEMENTS * 2 - 1;
-      } else {
-        return result(error_code::SURROGATE, input - start);
-      }
-    }
+    return simd16<uint16_t>::pack(t0, t1);
   }
-
-  return result(error_code::SUCCESS, input - start);
 }
 /* end file src/haswell/avx2_validate_utf16.cpp */
-/* begin file src/haswell/avx2_validate_utf32le.cpp */
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
-const char32_t *avx2_validate_utf32le(const char32_t *input, size_t size) {
-  const char32_t *end = input + size;
-
-  const __m256i standardmax = _mm256_set1_epi32(0x10ffff);
-  const __m256i offset = _mm256_set1_epi32(0xffff2000);
-  const __m256i standardoffsetmax = _mm256_set1_epi32(0xfffff7ff);
-  __m256i currentmax = _mm256_setzero_si256();
-  __m256i currentoffsetmax = _mm256_setzero_si256();
-
-  while (input + 8 < end) {
-    const __m256i in = _mm256_loadu_si256((__m256i *)input);
-    currentmax = _mm256_max_epu32(in, currentmax);
-    currentoffsetmax =
-        _mm256_max_epu32(_mm256_add_epi32(in, offset), currentoffsetmax);
-    input += 8;
-  }
-  __m256i is_zero =
-      _mm256_xor_si256(_mm256_max_epu32(currentmax, standardmax), standardmax);
-  if (_mm256_testz_si256(is_zero, is_zero) == 0) {
-    return nullptr;
-  }
-
-  is_zero = _mm256_xor_si256(
-      _mm256_max_epu32(currentoffsetmax, standardoffsetmax), standardoffsetmax);
-  if (_mm256_testz_si256(is_zero, is_zero) == 0) {
-    return nullptr;
-  }
-
-  return input;
-}
-
-const result avx2_validate_utf32le_with_errors(const char32_t *input,
-                                               size_t size) {
-  const char32_t *start = input;
-  const char32_t *end = input + size;
-
-  const __m256i standardmax = _mm256_set1_epi32(0x10ffff);
-  const __m256i offset = _mm256_set1_epi32(0xffff2000);
-  const __m256i standardoffsetmax = _mm256_set1_epi32(0xfffff7ff);
-  __m256i currentmax = _mm256_setzero_si256();
-  __m256i currentoffsetmax = _mm256_setzero_si256();
-
-  while (input + 8 < end) {
-    const __m256i in = _mm256_loadu_si256((__m256i *)input);
-    currentmax = _mm256_max_epu32(in, currentmax);
-    currentoffsetmax =
-        _mm256_max_epu32(_mm256_add_epi32(in, offset), currentoffsetmax);
-
-    __m256i is_zero = _mm256_xor_si256(
-        _mm256_max_epu32(currentmax, standardmax), standardmax);
-    if (_mm256_testz_si256(is_zero, is_zero) == 0) {
-      return result(error_code::TOO_LARGE, input - start);
-    }
-
-    is_zero =
-        _mm256_xor_si256(_mm256_max_epu32(currentoffsetmax, standardoffsetmax),
-                         standardoffsetmax);
-    if (_mm256_testz_si256(is_zero, is_zero) == 0) {
-      return result(error_code::SURROGATE, input - start);
-    }
-    input += 8;
-  }
-
-  return result(error_code::SUCCESS, input - start);
 }
-/* end file src/haswell/avx2_validate_utf32le.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_latin1_to_utf8.cpp */
 std::pair<const char *, char *>
 avx2_convert_latin1_to_utf8(const char *latin1_input, size_t len,
@@ -28639,45 +29957,42 @@ avx2_convert_latin1_to_utf8(const char *latin1_input, size_t len,
   return std::make_pair(latin1_input, utf8_output);
 }
 /* end file src/haswell/avx2_convert_latin1_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_latin1_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char *, char16_t *>
 avx2_convert_latin1_to_utf16(const char *latin1_input, size_t len,
                              char16_t *utf16_output) {
-  size_t rounded_len = len & ~0xF; // Round down to nearest multiple of 32
+  size_t rounded_len = len & ~0xF; // Round down to nearest multiple of 16
 
   size_t i = 0;
   for (; i < rounded_len; i += 16) {
     // Load 16 bytes from the address (input + i) into a xmm register
-    __m128i xmm0 =
+    const __m128i latin1 =
         _mm_loadu_si128(reinterpret_cast<const __m128i *>(latin1_input + i));
 
-    // Zero extend each byte in xmm0 to word and put it in another xmm register
-    __m128i xmm1 = _mm_cvtepu8_epi16(xmm0);
-
-    // Shift xmm0 to the right by 8 bytes
-    xmm0 = _mm_srli_si128(xmm0, 8);
-
-    // Zero extend each byte in the shifted xmm0 to word in xmm0
-    xmm0 = _mm_cvtepu8_epi16(xmm0);
+    // Zero extend each byte in `in` to word
+    __m256i utf16 = _mm256_cvtepu8_epi16(latin1);
 
     if (big_endian) {
-      const __m128i swap =
+      const __m128i swap128 =
           _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
-      xmm0 = _mm_shuffle_epi8(xmm0, swap);
-      xmm1 = _mm_shuffle_epi8(xmm1, swap);
+      const __m256i swap = _mm256_set_m128i(swap128, swap128);
+      utf16 = _mm256_shuffle_epi8(utf16, swap);
     }
 
     // Store the contents of xmm1 into the address pointed by (output + i)
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(utf16_output + i), xmm1);
-
-    // Store the contents of xmm0 into the address pointed by (output + i + 8)
-    _mm_storeu_si128(reinterpret_cast<__m128i *>(utf16_output + i + 8), xmm0);
+    _mm256_storeu_si256(reinterpret_cast<__m256i *>(utf16_output + i), utf16);
   }
 
   return std::make_pair(latin1_input + rounded_len, utf16_output + rounded_len);
 }
 /* end file src/haswell/avx2_convert_latin1_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_latin1_to_utf32.cpp */
 std::pair<const char *, char32_t *>
 avx2_convert_latin1_to_utf32(const char *buf, size_t len,
@@ -28700,7 +30015,9 @@ avx2_convert_latin1_to_utf32(const char *buf, size_t len,
   return std::make_pair(buf + rounded_len, utf32_output + rounded_len);
 }
 /* end file src/haswell/avx2_convert_latin1_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/haswell/avx2_convert_utf8_to_utf16.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -28898,6 +30215,9 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   return consumed;
 }
 /* end file src/haswell/avx2_convert_utf8_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/haswell/avx2_convert_utf8_to_utf32.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -29035,38 +30355,40 @@ size_t convert_masked_utf8_to_utf32(const char *input,
   return consumed;
 }
 /* end file src/haswell/avx2_convert_utf8_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_utf16_to_latin1.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char *>
 avx2_convert_utf16_to_latin1(const char16_t *buf, size_t len,
                              char *latin1_output) {
   const char16_t *end = buf + len;
-  while (end - buf >= 16) {
+  while (end - buf >= 32) {
     // Load 16 UTF-16 characters into 256-bit AVX2 register
-    __m256i in = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(buf));
+    __m256i in0 = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(buf));
+    __m256i in1 =
+        _mm256_loadu_si256(reinterpret_cast<const __m256i *>(buf + 16));
 
     if (!match_system(big_endian)) {
       const __m256i swap = _mm256_setr_epi8(
           1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
           21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
-      in = _mm256_shuffle_epi8(in, swap);
+      in0 = _mm256_shuffle_epi8(in0, swap);
+      in1 = _mm256_shuffle_epi8(in1, swap);
     }
 
     __m256i high_byte_mask = _mm256_set1_epi16((int16_t)0xFF00);
-    if (_mm256_testz_si256(in, high_byte_mask)) {
+    if (_mm256_testz_si256(_mm256_or_si256(in0, in1), high_byte_mask)) {
       // Pack 16-bit characters into 8-bit and store in latin1_output
-      __m128i lo = _mm256_extractf128_si256(in, 0);
-      __m128i hi = _mm256_extractf128_si256(in, 1);
-      __m128i latin1_packed_lo = _mm_packus_epi16(lo, lo);
-      __m128i latin1_packed_hi = _mm_packus_epi16(hi, hi);
-      _mm_storel_epi64(reinterpret_cast<__m128i *>(latin1_output),
-                       latin1_packed_lo);
-      _mm_storel_epi64(reinterpret_cast<__m128i *>(latin1_output + 8),
-                       latin1_packed_hi);
-      // Adjust pointers for next iteration
-      buf += 16;
-      latin1_output += 16;
+      const __m256i packed = _mm256_packus_epi16(in0, in1);
+
+      const __m256i result = _mm256_permute4x64_epi64(packed, 0b11011000);
+
+      _mm256_storeu_si256(reinterpret_cast<__m256i *>(latin1_output), result);
+      // Adjust pointers for the next iteration
+      buf += 32;
+      latin1_output += 32;
     } else {
       return std::make_pair(nullptr, reinterpret_cast<char *>(latin1_output));
     }
@@ -29105,9 +30427,8 @@ avx2_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     } else {
       // Fallback to scalar code for handling errors
       for (int k = 0; k < 16; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if (word <= 0xff) {
           *latin1_output++ = char(word);
         } else {
@@ -29123,6 +30444,9 @@ avx2_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/haswell/avx2_convert_utf16_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/haswell/avx2_convert_utf16_to_utf8.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -29413,7 +30737,7 @@ avx2_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_output) {
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -29427,7 +30751,7 @@ avx2_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_output) {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -29692,7 +31016,7 @@ avx2_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -29706,7 +31030,7 @@ avx2_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -29727,6 +31051,9 @@ avx2_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf8_output);
 }
 /* end file src/haswell/avx2_convert_utf16_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/haswell/avx2_convert_utf16_to_utf32.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -29831,7 +31158,7 @@ avx2_convert_utf16_to_utf32(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           // No surrogate pair
           *utf32_output++ = char32_t(word);
@@ -29839,7 +31166,7 @@ avx2_convert_utf16_to_utf32(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -29913,7 +31240,7 @@ avx2_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           // No surrogate pair
           *utf32_output++ = char32_t(word);
@@ -29921,7 +31248,7 @@ avx2_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -29939,7 +31266,9 @@ avx2_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf32_output);
 }
 /* end file src/haswell/avx2_convert_utf16_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_utf32_to_latin1.cpp */
 std::pair<const char32_t *, char *>
 avx2_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -29947,63 +31276,81 @@ avx2_convert_utf32_to_latin1(const char32_t *buf, size_t len,
   const size_t rounded_len =
       len & ~0x1F; // Round down to nearest multiple of 32
 
-  __m256i high_bytes_mask = _mm256_set1_epi32(0xFFFFFF00);
+  const __m256i high_bytes_mask = _mm256_set1_epi32(0xFFFFFF00);
 
-  __m256i shufmask = _mm256_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                                     -1, 12, 8, 4, 0, -1, -1, -1, -1, -1, -1,
-                                     -1, -1, -1, -1, -1, -1, 12, 8, 4, 0);
+  for (size_t i = 0; i < rounded_len; i += 4 * 8) {
+    __m256i a = _mm256_loadu_si256((__m256i *)(buf + 0 * 8));
+    __m256i b = _mm256_loadu_si256((__m256i *)(buf + 1 * 8));
+    __m256i c = _mm256_loadu_si256((__m256i *)(buf + 2 * 8));
+    __m256i d = _mm256_loadu_si256((__m256i *)(buf + 3 * 8));
 
-  for (size_t i = 0; i < rounded_len; i += 16) {
-    __m256i in1 = _mm256_loadu_si256((__m256i *)buf);
-    __m256i in2 = _mm256_loadu_si256((__m256i *)(buf + 8));
-
-    __m256i check_combined = _mm256_or_si256(in1, in2);
+    const __m256i check_combined =
+        _mm256_or_si256(_mm256_or_si256(a, b), _mm256_or_si256(c, d));
 
     if (!_mm256_testz_si256(check_combined, high_bytes_mask)) {
       return std::make_pair(nullptr, latin1_output);
     }
 
-    // Turn UTF32 bytes into latin 1 bytes
-    __m256i shuffled1 = _mm256_shuffle_epi8(in1, shufmask);
-    __m256i shuffled2 = _mm256_shuffle_epi8(in2, shufmask);
+    b = _mm256_slli_epi32(b, 1 * 8);
+    c = _mm256_slli_epi32(c, 2 * 8);
+    d = _mm256_slli_epi32(d, 3 * 8);
 
-    // move Latin1 bytes to their correct spot
-    __m256i idx1 = _mm256_set_epi32(-1, -1, -1, -1, -1, -1, 4, 0);
-    __m256i idx2 = _mm256_set_epi32(-1, -1, -1, -1, 4, 0, -1, -1);
-    __m256i reshuffled1 = _mm256_permutevar8x32_epi32(shuffled1, idx1);
-    __m256i reshuffled2 = _mm256_permutevar8x32_epi32(shuffled2, idx2);
+    // clang-format off
 
-    __m256i result = _mm256_or_si256(reshuffled1, reshuffled2);
-    _mm_storeu_si128((__m128i *)latin1_output, _mm256_castsi256_si128(result));
+    // a  = [.. .. .. a7|.. .. .. a6|.. .. .. a5|.. .. .. a4||.. .. .. a3|.. .. .. a2|.. .. .. a1|.. .. .. a0]
+    // b  = [.. .. b7 ..|.. .. b6 ..|.. .. b5 ..|.. .. b4 ..||.. .. b3 ..|.. .. b2 ..|.. .. b1 ..|.. .. b0 ..]
+    // c  = [.. c7 .. ..|.. c6 .. ..|.. c5 .. ..|.. c4 .. ..||.. c3 .. ..|.. c2 .. ..|.. c1 .. ..|.. c0 .. ..]
+    // d  = [d7 .. .. ..|d6 .. .. ..|d5 .. .. ..|d4 .. .. ..||d3 .. .. ..|d2 .. .. ..|d1 .. .. ..|d0 .. .. ..]
 
-    latin1_output += 16;
-    buf += 16;
+    // t0 = [d7 c7 b7 a7|d6 c6 b6 a6|d5 c5 b5 a5|d4 c4 b4 a4||d3 c3 b3 a3|d2 c2 b2 a2|d1 c1 b1 a1|d0 c0 b0 a0]
+    const __m256i t0 =
+        _mm256_or_si256(_mm256_or_si256(a, b), _mm256_or_si256(c, d));
+
+    // shuffle bytes within 128-bit lanes
+    // t1 = [d7 d6 d5 d4|c7 c6 c5 c4|b7 b6 b5 b4|a7 a6 a5 a4||d3 d2 d1 d0|c3 c2 c1 c0|b3 b2 b1 b0|a3 a2 a1 a0]
+    const __m256i shuffle_bytes =
+        _mm256_setr_epi8(0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15,
+                         0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15);
+
+    const __m256i t1 = _mm256_shuffle_epi8(t0, shuffle_bytes);
+
+    // reshuffle dwords
+    // t2 = [d7 d6 d5 d4|d3 d2 d1 d0|c7 c6 c5 c4|c3 c2 c1 c0||b7 b6 b5 b4|b3 b2 b1 b0|a7 a6 a5 a4|a3 a2 a1 a0]
+    const __m256i shuffle_dwords = _mm256_setr_epi32(0, 4, 1, 5, 2, 6, 3, 7);
+    const __m256i t2 = _mm256_permutevar8x32_epi32(t1, shuffle_dwords);
+// clang format on
+
+    _mm256_storeu_si256((__m256i *)latin1_output, t2);
+
+    latin1_output += 32;
+    buf += 32;
   }
 
   return std::make_pair(buf, latin1_output);
 }
+
 std::pair<result, char *>
 avx2_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                                          char *latin1_output) {
   const size_t rounded_len =
       len & ~0x1F; // Round down to nearest multiple of 32
 
-  __m256i high_bytes_mask = _mm256_set1_epi32(0xFFFFFF00);
-  __m256i shufmask = _mm256_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                                     -1, 12, 8, 4, 0, -1, -1, -1, -1, -1, -1,
-                                     -1, -1, -1, -1, -1, -1, 12, 8, 4, 0);
-
   const char32_t *start = buf;
 
-  for (size_t i = 0; i < rounded_len; i += 16) {
-    __m256i in1 = _mm256_loadu_si256((__m256i *)buf);
-    __m256i in2 = _mm256_loadu_si256((__m256i *)(buf + 8));
+  const __m256i high_bytes_mask = _mm256_set1_epi32(0xFFFFFF00);
+
+  for (size_t i = 0; i < rounded_len; i += 4 * 8) {
+    __m256i a = _mm256_loadu_si256((__m256i *)(buf + 0 * 8));
+    __m256i b = _mm256_loadu_si256((__m256i *)(buf + 1 * 8));
+    __m256i c = _mm256_loadu_si256((__m256i *)(buf + 2 * 8));
+    __m256i d = _mm256_loadu_si256((__m256i *)(buf + 3 * 8));
 
-    __m256i check_combined = _mm256_or_si256(in1, in2);
+    const __m256i check_combined =
+        _mm256_or_si256(_mm256_or_si256(a, b), _mm256_or_si256(c, d));
 
     if (!_mm256_testz_si256(check_combined, high_bytes_mask)) {
       // Fallback to scalar code for handling errors
-      for (int k = 0; k < 8; k++) {
+      for (int k = 0; k < 4 * 8; k++) {
         char32_t codepoint = buf[k];
         if (codepoint <= 0xFF) {
           *latin1_output++ = static_cast<char>(codepoint);
@@ -30012,29 +31359,37 @@ avx2_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                                 latin1_output);
         }
       }
-      buf += 8;
-    } else {
-      __m256i shuffled1 = _mm256_shuffle_epi8(in1, shufmask);
-      __m256i shuffled2 = _mm256_shuffle_epi8(in2, shufmask);
+    }
 
-      __m256i idx1 = _mm256_set_epi32(-1, -1, -1, -1, -1, -1, 4, 0);
-      __m256i idx2 = _mm256_set_epi32(-1, -1, -1, -1, 4, 0, -1, -1);
-      __m256i reshuffled1 = _mm256_permutevar8x32_epi32(shuffled1, idx1);
-      __m256i reshuffled2 = _mm256_permutevar8x32_epi32(shuffled2, idx2);
+    b = _mm256_slli_epi32(b, 1 * 8);
+    c = _mm256_slli_epi32(c, 2 * 8);
+    d = _mm256_slli_epi32(d, 3 * 8);
 
-      __m256i result = _mm256_or_si256(reshuffled1, reshuffled2);
-      _mm_storeu_si128((__m128i *)latin1_output,
-                       _mm256_castsi256_si128(result));
+    const __m256i t0 =
+        _mm256_or_si256(_mm256_or_si256(a, b), _mm256_or_si256(c, d));
 
-      latin1_output += 16;
-      buf += 16;
-    }
+    const __m256i shuffle_bytes =
+        _mm256_setr_epi8(0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15,
+                         0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15);
+
+    const __m256i t1 = _mm256_shuffle_epi8(t0, shuffle_bytes);
+
+    const __m256i shuffle_dwords = _mm256_setr_epi32(0, 4, 1, 5, 2, 6, 3, 7);
+    const __m256i t2 = _mm256_permutevar8x32_epi32(t1, shuffle_dwords);
+
+    _mm256_storeu_si256((__m256i *)latin1_output, t2);
+
+    latin1_output += 32;
+    buf += 32;
   }
 
   return std::make_pair(result(error_code::SUCCESS, buf - start),
                         latin1_output);
 }
 /* end file src/haswell/avx2_convert_utf32_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/haswell/avx2_convert_utf32_to_utf8.cpp */
 std::pair<const char32_t *, char *>
 avx2_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_output) {
@@ -30606,6 +31961,9 @@ avx2_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf8_output);
 }
 /* end file src/haswell/avx2_convert_utf32_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/haswell/avx2_convert_utf32_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
@@ -30782,7 +32140,9 @@ avx2_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf16_output);
 }
 /* end file src/haswell/avx2_convert_utf32_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/haswell/avx2_convert_utf8_to_latin1.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -30845,7 +32205,9 @@ size_t convert_masked_utf8_to_latin1(const char *input,
   return consumed;
 }
 /* end file src/haswell/avx2_convert_utf8_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/haswell/avx2_base64.cpp */
 /**
  * References and further reading:
@@ -31062,7 +32424,7 @@ struct block64 {
   __m256i chunks[2];
 };
 
-template <bool base64_url>
+template <bool base64_url, bool ignore_garbage>
 static inline uint32_t to_base64_mask(__m256i *src, uint32_t *error) {
   const __m256i ascii_space_tbl =
       _mm256_setr_epi8(0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xa,
@@ -31144,7 +32506,7 @@ static inline uint32_t to_base64_mask(__m256i *src, uint32_t *error) {
   const __m256i chk =
       _mm256_adds_epi8(_mm256_shuffle_epi8(check_values, check_hash), *src);
   const int mask = _mm256_movemask_epi8(chk);
-  if (mask) {
+  if (!ignore_garbage && mask) {
     __m256i ascii_space =
         _mm256_cmpeq_epi8(_mm256_shuffle_epi8(ascii_space_tbl, *src), *src);
     *error = (mask ^ _mm256_movemask_epi8(ascii_space));
@@ -31153,13 +32515,17 @@ static inline uint32_t to_base64_mask(__m256i *src, uint32_t *error) {
   return (uint32_t)mask;
 }
 
-template <bool base64_url>
+template <bool base64_url, bool ignore_garbage>
 static inline uint64_t to_base64_mask(block64 *b, uint64_t *error) {
   uint32_t err0 = 0;
   uint32_t err1 = 0;
-  uint64_t m0 = to_base64_mask<base64_url>(&b->chunks[0], &err0);
-  uint64_t m1 = to_base64_mask<base64_url>(&b->chunks[1], &err1);
-  *error = err0 | ((uint64_t)err1 << 32);
+  uint64_t m0 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[0], &err0);
+  uint64_t m1 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[1], &err1);
+  if (!ignore_garbage) {
+    *error = err0 | ((uint64_t)err1 << 32);
+  }
   return m0 | (m1 << 32);
 }
 
@@ -31199,6 +32565,8 @@ static inline void load_block(block64 *b, const char16_t *src) {
   b->chunks[1] = _mm256_packus_epi16(m3p, m4p);
 }
 
+template <typename T> bool is_power_of_two(T x) { return (x & (x - 1)) == 0; }
+
 static inline void base64_decode(char *out, __m256i str) {
   // credit: aqrit
   const __m256i pack_shuffle =
@@ -31238,7 +32606,79 @@ static inline void base64_decode_block_safe(char *out, block64 *b) {
   std::memcpy(out + 24, buffer, 24);
 }
 
-template <bool base64_url, typename chartype>
+simdutf_really_inline static size_t
+compress_block_single(block64 *b, uint64_t mask, char *output) {
+  const size_t pos64 = _tzcnt_u64(mask);
+  const int8_t pos = pos64 & 0xf;
+  switch (pos64 >> 4) {
+  case 0b00: {
+    const __m128i lane0 = _mm256_extracti128_si256(b->chunks[0], 0);
+    const __m128i lane1 = _mm256_extracti128_si256(b->chunks[0], 1);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(lane0, sh);
+
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), compressed);
+    _mm_storeu_si128((__m128i *)(output + 1 * 16 - 1), lane1);
+    _mm256_storeu_si256((__m256i *)(output + 2 * 16 - 1), b->chunks[1]);
+  } break;
+  case 0b01: {
+    const __m128i lane0 = _mm256_extracti128_si256(b->chunks[0], 0);
+    const __m128i lane1 = _mm256_extracti128_si256(b->chunks[0], 1);
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), lane0);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(lane1, sh);
+
+    _mm_storeu_si128((__m128i *)(output + 1 * 16), compressed);
+    _mm256_storeu_si256((__m256i *)(output + 2 * 16 - 1), b->chunks[1]);
+  } break;
+  case 0b10: {
+    const __m128i lane2 = _mm256_extracti128_si256(b->chunks[1], 0);
+    const __m128i lane3 = _mm256_extracti128_si256(b->chunks[1], 1);
+
+    _mm256_storeu_si256((__m256i *)(output + 0 * 16), b->chunks[0]);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(lane2, sh);
+
+    _mm_storeu_si128((__m128i *)(output + 2 * 16), compressed);
+    _mm_storeu_si128((__m128i *)(output + 3 * 16 - 1), lane3);
+  } break;
+  case 0b11: {
+    const __m128i lane2 = _mm256_extracti128_si256(b->chunks[1], 0);
+    const __m128i lane3 = _mm256_extracti128_si256(b->chunks[1], 1);
+
+    _mm256_storeu_si256((__m256i *)(output + 0 * 16), b->chunks[0]);
+    _mm_storeu_si128((__m128i *)(output + 2 * 16), lane2);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(lane3, sh);
+
+    _mm_storeu_si128((__m128i *)(output + 3 * 16), compressed);
+  } break;
+  }
+
+  return 63;
+}
+
+template <bool base64_url, bool ignore_garbage, typename chartype>
 full_result
 compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                        base64_options options,
@@ -31248,12 +32688,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   size_t equallocation =
       srclen; // location of the first padding character if any
   // skip trailing spaces
-  while (srclen > 0 && scalar::base64::is_eight_byte(src[srclen - 1]) &&
+  while (!ignore_garbage && srclen > 0 &&
+         scalar::base64::is_eight_byte(src[srclen - 1]) &&
          to_base64[uint8_t(src[srclen - 1])] == 64) {
     srclen--;
   }
   size_t equalsigns = 0;
-  if (srclen > 0 && src[srclen - 1] == '=') {
+  if (!ignore_garbage && srclen > 0 && src[srclen - 1] == '=') {
     equallocation = srclen - 1;
     srclen--;
     equalsigns = 1;
@@ -31269,7 +32710,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -31292,18 +32739,23 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       load_block(&b, src);
       src += 64;
       uint64_t error = 0;
-      uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
-      if (error) {
+      uint64_t badcharmask =
+          to_base64_mask<base64_url, ignore_garbage>(&b, &error);
+      if (!ignore_garbage && error) {
         src -= 64;
         size_t error_offset = _tzcnt_u64(error);
         return {error_code::INVALID_BASE64_CHARACTER,
                 size_t(src - srcinit + error_offset), size_t(dst - dstinit)};
       }
       if (badcharmask != 0) {
-        // optimization opportunity: check for simple masks like those made of
-        // continuous 1s followed by continuous 0s. And masks containing a
-        // single bad character.
-        bufferptr += compress_block(&b, badcharmask, bufferptr);
+        if (is_power_of_two(badcharmask)) {
+          // optimization opportunity: check for simple masks like those made of
+          // continuous 1s followed by continuous 0s. And masks containing a
+          // single bad character.
+          bufferptr += compress_block_single(&b, badcharmask, bufferptr);
+        } else {
+          bufferptr += compress_block(&b, badcharmask, bufferptr);
+        }
       } else if (bufferptr != buffer) {
         copy_block(&b, bufferptr);
         bufferptr += 64;
@@ -31342,7 +32794,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     while ((bufferptr - buffer_start) % 64 != 0 && src < srcend) {
       uint8_t val = to_base64[uint8_t(*src)];
       *bufferptr = char(val);
-      if (!scalar::base64::is_eight_byte(*src) || val > 64) {
+      if (!ignore_garbage &&
+          (!scalar::base64::is_eight_byte(*src) || val > 64)) {
         return {error_code::INVALID_BASE64_CHARACTER, size_t(src - srcinit),
                 size_t(dst - dstinit)};
       }
@@ -31366,19 +32819,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
-      std::memcpy(dst, &triple, 4);
-
-      dst += 3;
-      buffer_start += 4;
-    }
-    if (buffer_start + 4 <= bufferptr) {
-      uint32_t triple = ((uint32_t(uint8_t(buffer_start[0])) << 3 * 6) +
-                         (uint32_t(uint8_t(buffer_start[1])) << 2 * 6) +
-                         (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
-                         (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
-                        << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 3);
 
       dst += 3;
@@ -31388,8 +32829,14 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     // backtrack
     int leftover = int(bufferptr - buffer_start);
     while (leftover > 0) {
-      while (to_base64[uint8_t(*(src - 1))] == 64) {
-        src--;
+      if (!ignore_garbage) {
+        while (to_base64[uint8_t(*(src - 1))] == 64) {
+          src--;
+        }
+      } else {
+        while (to_base64[uint8_t(*(src - 1))] >= 64) {
+          src--;
+        }
       }
       src--;
       leftover--;
@@ -31405,7 +32852,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     } else {
       r.output_count += size_t(dst - dstinit);
     }
-    if (last_chunk_options != stop_before_partial &&
+    if (!ignore_garbage && last_chunk_options != stop_before_partial &&
         r.error == error_code::SUCCESS && equalsigns > 0) {
       // additional checks
       if ((r.output_count % 3 == 0) ||
@@ -31416,7 +32863,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
     return r;
   }
-  if (equalsigns > 0) {
+  if (!ignore_garbage && equalsigns > 0) {
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -31425,6 +32872,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/haswell/avx2_base64.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // unnamed namespace
 } // namespace haswell
@@ -31541,6 +32989,7 @@ simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance() {
 } // namespace haswell
 } // namespace simdutf
 /* end file src/generic/buf_block_reader.h */
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
 namespace simdutf {
 namespace haswell {
@@ -31847,9 +33296,22 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+} // namespace utf8_validation
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+/* end file src/generic/utf8_validation/utf8_validator.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/generic/ascii_validation.h */
+namespace simdutf {
+namespace haswell {
+namespace {
+namespace ascii_validation {
+
+bool generic_validate_ascii(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   uint8_t blocks[64]{};
   simd::simd8x64<uint8_t> running_or(blocks);
   while (reader.has_full_block()) {
@@ -31864,14 +33326,8 @@ bool generic_validate_ascii(const uint8_t *input, size_t length) {
   return running_or.is_ascii();
 }
 
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+result generic_validate_ascii_with_errors(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   size_t count{0};
   while (reader.has_full_block()) {
     simd::simd8x64<uint8_t> in(reader.full_block());
@@ -31896,19 +33352,16 @@ result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
   }
 }
 
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-} // namespace utf8_validation
+} // namespace ascii_validation
 } // unnamed namespace
 } // namespace haswell
 } // namespace simdutf
-/* end file src/generic/utf8_validation/utf8_validator.h */
-// transcoding from UTF-8 to UTF-16
-/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
+/* end file src/generic/ascii_validation.h */
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  // transcoding from UTF-8 to UTF-16
+/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -31985,7 +33438,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -32319,9 +33771,11 @@ struct validating_transcoder {
 } // namespace haswell
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-// transcoding from UTF-8 to UTF-32
-/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  // transcoding from UTF-8 to UTF-32
+/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -32366,7 +33820,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -32686,9 +34139,119 @@ struct validating_transcoder {
 } // namespace haswell
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
+/* begin file src/generic/utf32.h */
+#include <limits>
+
+namespace simdutf {
+namespace haswell {
+namespace {
+namespace utf32 {
+
+template <typename T> T min(T a, T b) { return a <= b ? a : b; }
+
+size_t utf8_length_from_utf32(const char32_t *input, size_t length) {
+  using vector_u32 = simd32<uint32_t>;
+
+  const char32_t *start = input;
+
+  // we add up to three ones in a single iteration (see the vectorized loop in
+  // section #2 below)
+  const size_t max_increment = 3;
+
+  const size_t N = vector_u32::ELEMENTS;
+
+  const auto one = vector_u32::splat(1);
+  const auto v_ffffff80 = vector_u32::splat(0xffffff80);
+  const auto v_fffff800 = vector_u32::splat(0xfffff800);
+  const auto v_ffff0000 = vector_u32::splat(0xffff0000);
+
+  size_t counter = 0;
+
+  // 1. vectorized loop unrolled 4 times
+  {
+    // we use uint32 counters, this is
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / (max_increment * 4);
+    size_t blocks = length / (N * 4);
+    length -= blocks * (N * 4);
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      simd32<uint32_t> acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in0 = vector_u32(input + 0 * N);
+        const auto in1 = vector_u32(input + 1 * N);
+        const auto in2 = vector_u32(input + 2 * N);
+        const auto in3 = vector_u32(input + 3 * N);
+
+        acc += min(one, in0 & v_ffffff80);
+        acc += min(one, in1 & v_ffffff80);
+        acc += min(one, in2 & v_ffffff80);
+        acc += min(one, in3 & v_ffffff80);
+
+        acc += min(one, in0 & v_fffff800);
+        acc += min(one, in1 & v_fffff800);
+        acc += min(one, in2 & v_fffff800);
+        acc += min(one, in3 & v_fffff800);
+
+        acc += min(one, in0 & v_ffff0000);
+        acc += min(one, in1 & v_ffff0000);
+        acc += min(one, in2 & v_ffff0000);
+        acc += min(one, in3 & v_ffff0000);
+
+        input += 4 * N;
+      }
+
+      counter += acc.sum();
+    }
+  }
+
+  // 2. vectorized loop for tail
+  {
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / max_increment;
+    size_t blocks = length / N;
+    length -= blocks * N;
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      auto acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in = vector_u32(input);
+
+        acc += min(one, in & v_ffffff80);
+        acc += min(one, in & v_fffff800);
+        acc += min(one, in & v_ffff0000);
+
+        input += N;
+      }
+
+      counter += acc.sum();
+    }
+  }
+
+  const size_t consumed = input - start;
+  if (consumed != 0) {
+    // We don't count 0th bytes in the vectorized loops above, this
+    // is why we need to count them in the end.
+    counter += consumed;
+  }
+
+  return counter + scalar::utf32::utf8_length_from_utf32(input, length);
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+/* end file src/generic/utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
 // other functions
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/generic/utf8.h */
-
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -32728,6 +34291,9 @@ simdutf_really_inline size_t utf16_length_from_utf8(const char *in,
 } // namespace haswell
 } // namespace simdutf
 /* end file src/generic/utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/generic/utf16.h */
 namespace simdutf {
 namespace haswell {
@@ -32803,10 +34369,146 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace haswell
 } // namespace simdutf
 /* end file src/generic/utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf16.h */
+namespace simdutf {
+namespace haswell {
+namespace {
+namespace utf16 {
+/*
+    UTF-16 validation
+    --------------------------------------------------
 
-// transcoding from UTF-8 to Latin 1
-/* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
+    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
+
+    In a vectorized algorithm we want to examine the most significant
+    nibble in order to select a fast path. If none of highest nibbles
+    are 0xD (13), than we are sure that UTF-16 chunk in a vector
+    register is valid.
+
+    Let us analyze what we need to check if the nibble is 0xD. The
+    value of the preceding nibble determines what we have:
+
+    0xd000 .. 0xd7ff - a valid word
+    0xd800 .. 0xdbff - low surrogate
+    0xdc00 .. 0xdfff - high surrogate
+
+    Other constraints we have to consider:
+    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
+    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
+    - there must not be sole low surrogate nor high surrogate
+
+    We are going to build three bitmasks based on the 3rd nibble:
+    - V = valid word,
+    - L = low surrogate (0xd800 .. 0xdbff)
+    - H = high surrogate (0xdc00 .. 0xdfff)
+
+      0   1   2   3   4   5   6   7    <--- word index
+    [ V | L | H | L | H | V | V | L ]
+      1   0   0   0   0   1   1   0     - V = valid masks
+      0   1   0   1   0   0   0   1     - L = low surrogate
+      0   0   1   0   1   0   0   0     - H high surrogate
+
+
+      1   0   0   0   0   1   1   0   V = valid masks
+      0   1   0   1   0   0   0   0   a = L & (H >> 1)
+      0   0   1   0   1   0   0   0   b = a << 1
+      1   1   1   1   1   1   1   0   c = V | a | b
+                                  ^
+                                  the last bit can be zero, we just consume 7
+   code units and recheck this word in the next iteration
+*/
+template <endianness big_endian>
+const result validate_utf16_with_errors(const char16_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    return result(error_code::SUCCESS, 0);
+  }
 
+  const char16_t *start = input;
+  const char16_t *end = input + size;
+
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+
+  while (input + simd16<uint16_t>::SIZE * 2 < end) {
+    // 0. Load data: since the validation takes into account only higher
+    //    byte of each word, we compress the two vectors into one which
+    //    consists only the higher bytes.
+    auto in0 = simd16<uint16_t>(input);
+    auto in1 =
+        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
+
+    // Function `utf16_gather_high_bytes` consumes two vectors of UTF-16
+    // and yields a single vector having only higher bytes of characters.
+    const auto in = utf16_gather_high_bytes<big_endian>(in0, in1);
+
+    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
+    const auto surrogates_wordmask = (in & v_f8) == v_d8;
+    const uint16_t surrogates_bitmask =
+        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
+    if (surrogates_bitmask == 0x0000) {
+      input += 16;
+    } else {
+      // 2. We have some surrogates that have to be distinguished:
+      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
+      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
+      //
+      //    Fact: high surrogate has 11th bit set (3rd bit in the higher byte)
+
+      // V - non-surrogate code units
+      //     V = not surrogates_wordmask
+      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
+
+      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
+      const auto vH = (in & v_fc) == v_dc;
+      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
+
+      // L - word mask for low surrogates
+      //     L = not H and surrogates_wordmask
+      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
+
+      const uint16_t a = static_cast<uint16_t>(
+          L & (H >> 1)); // A low surrogate must be followed by high one.
+                         // (A low surrogate placed in the 7th register's word
+                         // is an exception we handle.)
+      const uint16_t b = static_cast<uint16_t>(
+          a << 1); // Just mark that the opinput - startite fact is hold,
+                   // thanks to that we have only two masks for valid case.
+      const uint16_t c = static_cast<uint16_t>(
+          V | a | b); // Combine all the masks into the final one.
+
+      if (c == 0xffff) {
+        // The whole input register contains valid UTF-16, i.e.,
+        // either single code units or proper surrogate pairs.
+        input += 16;
+      } else if (c == 0x7fff) {
+        // The 15 lower code units of the input register contains valid UTF-16.
+        // The 15th word may be either a low or high surrogate. It the next
+        // iteration we 1) check if the low surrogate is followed by a high
+        // one, 2) reject sole high surrogate.
+        input += 15;
+      } else {
+        return result(error_code::SURROGATE, input - start);
+      }
+    }
+  }
+
+  return result(error_code::SUCCESS, input - start);
+}
+
+} // namespace utf16
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+/* end file src/generic/validate_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  // transcoding from UTF-8 to Latin 1
+/* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -32965,6 +34667,9 @@ struct validating_transcoder {
         uint64_t utf8_continuation_mask =
             input.lt(-65 + 1); // -64 is 1100 0000 in twos complement. Note: in
                                // this case, we also have ASCII to account for.
+        if (utf8_continuation_mask & 1) {
+          return 0; // error
+        }
         uint64_t utf8_leading_mask = ~utf8_continuation_mask;
         uint64_t utf8_end_of_code_point_mask = utf8_leading_mask >> 1;
         // We process in blocks of up to 12 bytes except possibly
@@ -33122,7 +34827,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 /* begin file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
 namespace simdutf {
 namespace haswell {
 namespace {
@@ -33202,10 +34906,116 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 } // namespace simdutf
   // namespace simdutf
 /* end file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf32.h */
 namespace simdutf {
 namespace haswell {
+namespace {
+namespace utf32 {
+
+simdutf_really_inline bool validate(const char32_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    // empty input is valid UTF-32. protect the implementation from
+    // handling nullptr
+    return true;
+  }
+
+  const char32_t *end = input + size;
+
+  using vector_u32 = simd32<uint32_t>;
+
+  const auto standardmax = vector_u32::splat(0x10ffff);
+  const auto offset = vector_u32::splat(0xffff2000);
+  const auto standardoffsetmax = vector_u32::splat(0xfffff7ff);
+  auto currentmax = vector_u32::zero();
+  auto currentoffsetmax = vector_u32::zero();
+
+  constexpr size_t N = vector_u32::ELEMENTS;
+
+  while (input + N < end) {
+    auto in = vector_u32(input);
+    if (!match_system(endianness::BIG)) {
+      in.swap_bytes();
+    }
+
+    currentmax = max(currentmax, in);
+    currentoffsetmax = max(currentoffsetmax, in + offset);
+    input += N;
+  }
+
+  const auto too_large = currentmax > standardmax;
+  if (too_large.any()) {
+    return false;
+  }
+
+  const auto surrogate = currentoffsetmax > standardoffsetmax;
+  if (surrogate.any()) {
+    return false;
+  }
+
+  return scalar::utf32::validate(input, end - input);
+}
+
+simdutf_really_inline result validate_with_errors(const char32_t *input,
+                                                  size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    // empty input is valid UTF-32. protect the implementation from
+    // handling nullptr
+    return result(error_code::SUCCESS, 0);
+  }
+
+  const char32_t *start = input;
+  const char32_t *end = input + size;
+
+  using vector_u32 = simd32<uint32_t>;
+
+  const auto standardmax = vector_u32::splat(0x10ffff);
+  const auto offset = vector_u32::splat(0xffff2000);
+  const auto standardoffsetmax = vector_u32::splat(0xfffff7ff);
+
+  constexpr size_t N = vector_u32::ELEMENTS;
+
+  while (input + N < end) {
+    auto in = vector_u32(input);
+    if (!match_system(endianness::BIG)) {
+      in.swap_bytes();
+    }
+
+    const auto too_large = in > standardmax;
+    const auto surrogate = (in + offset) > standardoffsetmax;
+
+    const auto combined = too_large | surrogate;
+    if (simdutf_unlikely(combined.any())) {
+      const size_t consumed = input - start;
+      auto sr = scalar::utf32::validate_with_errors(input, end - input);
+      sr.count += consumed;
+
+      return sr;
+    }
+
+    input += N;
+  }
+
+  const size_t consumed = input - start;
+  auto sr = scalar::utf32::validate_with_errors(input, end - input);
+  sr.count += consumed;
+
+  return sr;
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace haswell
+} // namespace simdutf
+/* end file src/generic/validate_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+namespace simdutf {
+namespace haswell {
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -33214,44 +35024,136 @@ implementation::detect_encodings(const char *input,
   if (bom_encoding != encoding_type::unspecified) {
     return bom_encoding;
   }
+
   int out = 0;
-  if (validate_utf8(input, length)) {
+  uint32_t utf16_err = (length % 2);
+  uint32_t utf32_err = (length % 4);
+  uint32_t ends_with_high = 0;
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+  const __m256i standardmax = _mm256_set1_epi32(0x10ffff);
+  const __m256i offset = _mm256_set1_epi32(0xffff2000);
+  const __m256i standardoffsetmax = _mm256_set1_epi32(0xfffff7ff);
+  __m256i currentmax = _mm256_setzero_si256();
+  __m256i currentoffsetmax = _mm256_setzero_si256();
+
+  utf8_checker c{};
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
+  while (reader.has_full_block()) {
+    simd::simd8x64<uint8_t> in(reader.full_block());
+    // utf8 checks
+    c.check_next_input(in);
+
+    // utf16le checks
+    auto in0 = simd16<uint16_t>(in.chunks[0]);
+    auto in1 = simd16<uint16_t>(in.chunks[1]);
+    const auto t0 = in0.shr<8>();
+    const auto t1 = in1.shr<8>();
+    const auto in2 = simd16<uint16_t>::pack(t0, t1);
+    const auto surrogates_wordmask = (in2 & v_f8) == v_d8;
+    const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
+    const auto vL = (in2 & v_fc) == v_dc;
+    const uint32_t L = vL.to_bitmask();
+    const uint32_t H = L ^ surrogates_bitmask;
+    utf16_err |= (((H << 1) | ends_with_high) != L);
+    ends_with_high = (H & 0x80000000) != 0;
+
+    // utf32le checks
+    currentmax = _mm256_max_epu32(in.chunks[0], currentmax);
+    currentoffsetmax = _mm256_max_epu32(_mm256_add_epi32(in.chunks[0], offset),
+                                        currentoffsetmax);
+    currentmax = _mm256_max_epu32(in.chunks[1], currentmax);
+    currentoffsetmax = _mm256_max_epu32(_mm256_add_epi32(in.chunks[1], offset),
+                                        currentoffsetmax);
+
+    reader.advance();
+  }
+
+  uint8_t block[64]{};
+  size_t idx = reader.block_index();
+  std::memcpy(block, &input[idx], length - idx);
+  simd::simd8x64<uint8_t> in(block);
+  c.check_next_input(in);
+
+  // utf16le last block check
+  auto in0 = simd16<uint16_t>(in.chunks[0]);
+  auto in1 = simd16<uint16_t>(in.chunks[1]);
+  const auto t0 = in0.shr<8>();
+  const auto t1 = in1.shr<8>();
+  const auto in2 = simd16<uint16_t>::pack(t0, t1);
+  const auto surrogates_wordmask = (in2 & v_f8) == v_d8;
+  const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
+  const auto vL = (in2 & v_fc) == v_dc;
+  const uint32_t L = vL.to_bitmask();
+  const uint32_t H = L ^ surrogates_bitmask;
+  utf16_err |= (((H << 1) | ends_with_high) != L);
+  // this is required to check for last byte ending in high and end of input
+  // is reached
+  ends_with_high = (H & 0x80000000) != 0;
+  utf16_err |= ends_with_high;
+
+  // utf32le last block check
+  currentmax = _mm256_max_epu32(in.chunks[0], currentmax);
+  currentoffsetmax = _mm256_max_epu32(_mm256_add_epi32(in.chunks[0], offset),
+                                      currentoffsetmax);
+  currentmax = _mm256_max_epu32(in.chunks[1], currentmax);
+  currentoffsetmax = _mm256_max_epu32(_mm256_add_epi32(in.chunks[1], offset),
+                                      currentoffsetmax);
+
+  reader.advance();
+
+  c.check_eof();
+  bool is_valid_utf8 = !c.errors();
+  __m256i is_zero =
+      _mm256_xor_si256(_mm256_max_epu32(currentmax, standardmax), standardmax);
+  utf32_err |= (_mm256_testz_si256(is_zero, is_zero) == 0);
+
+  is_zero = _mm256_xor_si256(
+      _mm256_max_epu32(currentoffsetmax, standardoffsetmax), standardoffsetmax);
+  utf32_err |= (_mm256_testz_si256(is_zero, is_zero) == 0);
+  if (is_valid_utf8) {
     out |= encoding_type::UTF8;
   }
-  if ((length % 2) == 0) {
-    if (validate_utf16le(reinterpret_cast<const char16_t *>(input),
-                         length / 2)) {
-      out |= encoding_type::UTF16_LE;
-    }
+  if (utf16_err == 0) {
+    out |= encoding_type::UTF16_LE;
   }
-  if ((length % 4) == 0) {
-    if (validate_utf32(reinterpret_cast<const char32_t *>(input), length / 4)) {
-      out |= encoding_type::UTF32_LE;
-    }
+  if (utf32_err == 0) {
+    out |= encoding_type::UTF32_LE;
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return haswell::utf8_validation::generic_validate_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return haswell::utf8_validation::generic_validate_utf8_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
-  return haswell::utf8_validation::generic_validate_ascii(buf, len);
+  return haswell::ascii_validation::generic_validate_ascii(buf, len);
 }
 
 simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
-  return haswell::utf8_validation::generic_validate_ascii_with_errors(buf, len);
+  return haswell::ascii_validation::generic_validate_ascii_with_errors(buf,
+                                                                       len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -33260,15 +35162,22 @@ implementation::validate_utf16le(const char16_t *buf,
     // handling nullptr
     return true;
   }
-  const char16_t *tail = avx2_validate_utf16<endianness::LITTLE>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::LITTLE>(tail,
-                                                       len - (tail - buf));
-  } else {
+  const auto res =
+      haswell::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count == len) {
+    return true;
+  }
+
+  return scalar::utf16::validate<endianness::LITTLE>(buf + res.count,
+                                                     len - res.count);
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -33277,20 +35186,29 @@ implementation::validate_utf16be(const char16_t *buf,
     // handling nullptr
     return true;
   }
-  const char16_t *tail = avx2_validate_utf16<endianness::BIG>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::BIG>(tail, len - (tail - buf));
-  } else {
+  const auto res =
+      haswell::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count == len) {
+    return true;
+  }
+
+  return scalar::utf16::validate<endianness::BIG>(buf + res.count,
+                                                  len - res.count);
 }
 
 simdutf_warn_unused result implementation::validate_utf16le_with_errors(
     const char16_t *buf, size_t len) const noexcept {
-  result res = avx2_validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+
+  const result res =
+      haswell::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::LITTLE>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::LITTLE>(
+            buf + res.count, len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
@@ -33299,48 +35217,34 @@ simdutf_warn_unused result implementation::validate_utf16le_with_errors(
 
 simdutf_warn_unused result implementation::validate_utf16be_with_errors(
     const char16_t *buf, size_t len) const noexcept {
-  result res = avx2_validate_utf16_with_errors<endianness::BIG>(buf, len);
+  const result res =
+      haswell::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::BIG>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::BIG>(buf + res.count,
+                                                             len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
-  if (simdutf_unlikely(len == 0)) {
-    // empty input is valid UTF-32. protect the implementation from
-    // handling nullptr
-    return true;
-  }
-  const char32_t *tail = avx2_validate_utf32le(buf, len);
-  if (tail) {
-    return scalar::utf32::validate(tail, len - (tail - buf));
-  } else {
-    return false;
-  }
+  return utf32::validate(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
-  if (simdutf_unlikely(len == 0)) {
-    // empty input is valid UTF-32. protect the implementation from
-    // handling nullptr
-    return result(error_code::SUCCESS, 0);
-  }
-  result res = avx2_validate_utf32le_with_errors(buf, len);
-  if (res.count != len) {
-    result scalar_res =
-        scalar::utf32::validate_with_errors(buf + res.count, len - res.count);
-    return result(scalar_res.error, res.count + scalar_res.count);
-  } else {
-    return res;
-  }
+  return utf32::validate_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char *, char *> ret =
@@ -33355,7 +35259,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
 
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char *, char16_t *> ret =
@@ -33395,7 +35301,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char *, char32_t *> ret =
@@ -33414,7 +35322,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   utf8_to_latin1::validating_transcoder converter;
@@ -33431,7 +35341,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *input, size_t size, char *latin1_output) const noexcept {
   return utf8_to_latin1::convert_valid(input, size, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
@@ -33468,7 +35380,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return utf8_to_utf16::convert_valid<endianness::BIG>(input, size,
                                                        utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   utf8_to_utf32::validating_transcoder converter;
@@ -33485,7 +35399,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -33593,7 +35509,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: implement a custom function
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -33701,7 +35619,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -33720,7 +35640,9 @@ simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
   }
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -33766,7 +35688,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   return convert_utf32_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   // ret.first.count is always the position in the buffer, not the number of
@@ -33788,7 +35712,9 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
       utf8_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char16_t *, char32_t *> ret =
@@ -33886,12 +35812,16 @@ simdutf_warn_unused result implementation::convert_utf16be_to_utf32_with_errors(
       utf32_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -33999,7 +35929,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   return convert_utf16be_to_utf32(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -34015,27 +35947,23 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return scalar::utf16::latin1_length_from_utf16(length);
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return scalar::utf32::latin1_length_from_utf32(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::LITTLE>(input, length);
@@ -34045,7 +35973,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::LITTLE>(input, length);
@@ -34055,22 +35985,16 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf16_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf32_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t len) const noexcept {
   const uint8_t *data = reinterpret_cast<const uint8_t *>(input);
@@ -34126,43 +36050,16 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return answer + scalar::latin1::utf8_length_from_latin1(
                       reinterpret_cast<const char *>(data + i), len - i);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
-  const __m256i v_00000000 = _mm256_setzero_si256();
-  const __m256i v_ffffff80 = _mm256_set1_epi32((uint32_t)0xffffff80);
-  const __m256i v_fffff800 = _mm256_set1_epi32((uint32_t)0xfffff800);
-  const __m256i v_ffff0000 = _mm256_set1_epi32((uint32_t)0xffff0000);
-  size_t pos = 0;
-  size_t count = 0;
-  for (; pos + 8 <= length; pos += 8) {
-    __m256i in = _mm256_loadu_si256((__m256i *)(input + pos));
-    const __m256i ascii_bytes_bytemask =
-        _mm256_cmpeq_epi32(_mm256_and_si256(in, v_ffffff80), v_00000000);
-    const __m256i one_two_bytes_bytemask =
-        _mm256_cmpeq_epi32(_mm256_and_si256(in, v_fffff800), v_00000000);
-    const __m256i two_bytes_bytemask =
-        _mm256_xor_si256(one_two_bytes_bytemask, ascii_bytes_bytemask);
-    const __m256i one_two_three_bytes_bytemask =
-        _mm256_cmpeq_epi32(_mm256_and_si256(in, v_ffff0000), v_00000000);
-    const __m256i three_bytes_bytemask =
-        _mm256_xor_si256(one_two_three_bytes_bytemask, one_two_bytes_bytemask);
-    const uint32_t ascii_bytes_bitmask =
-        static_cast<uint32_t>(_mm256_movemask_epi8(ascii_bytes_bytemask));
-    const uint32_t two_bytes_bitmask =
-        static_cast<uint32_t>(_mm256_movemask_epi8(two_bytes_bytemask));
-    const uint32_t three_bytes_bitmask =
-        static_cast<uint32_t>(_mm256_movemask_epi8(three_bytes_bytemask));
-
-    size_t ascii_count = count_ones(ascii_bytes_bitmask) / 4;
-    size_t two_bytes_count = count_ones(two_bytes_bitmask) / 4;
-    size_t three_bytes_count = count_ones(three_bytes_bitmask) / 4;
-    count += 32 - 3 * ascii_count - 2 * two_bytes_count - three_bytes_count;
-  }
-  return count +
-         scalar::utf32::utf8_length_from_utf32(input + pos, length - pos);
+  return utf32::utf8_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const __m256i v_00000000 = _mm256_setzero_si256();
@@ -34181,65 +36078,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -34251,6 +36185,7 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
     return encode_base64<false>(output, input, length, options);
   }
 }
+#endif // SIMDUTF_FEATURE_BASE64
 } // namespace haswell
 } // namespace simdutf
 
@@ -34271,11 +36206,6 @@ SIMDUTF_POP_DISABLE_WARNINGS
 #endif
 #if SIMDUTF_IMPLEMENTATION_PPC64
 /* begin file src/ppc64/implementation.cpp */
-
-
-
-
-
 /* begin file src/simdutf/ppc64/begin.h */
 // redefining SIMDUTF_IMPLEMENTATION to "ppc64"
 // #define SIMDUTF_IMPLEMENTATION ppc64
@@ -34293,21 +36223,6 @@ simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   return input.reduce_or().saturating_sub(0b01111111u).bits_not_set_anywhere();
 }
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<uint8_t> is_second_byte =
-      prev1.saturating_sub(0b11000000u - 1); // Only 11______ will be > 0
-  simd8<uint8_t> is_third_byte =
-      prev2.saturating_sub(0b11100000u - 1); // Only 111_____ will be > 0
-  simd8<uint8_t> is_fourth_byte =
-      prev3.saturating_sub(0b11110000u - 1); // Only 1111____ will be > 0
-  // Caller requires a bool (all 1's). All values resulting from the subtraction
-  // will be <= 64, so signed comparison is fine.
-  return simd8<int8_t>(is_second_byte | is_third_byte | is_fourth_byte) >
-         int8_t(0);
-}
-
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -34741,60 +36656,6 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
-  uint8_t blocks[64]{};
-  simd::simd8x64<uint8_t> running_or(blocks);
-  while (reader.has_full_block()) {
-    simd::simd8x64<uint8_t> in(reader.full_block());
-    running_or |= in;
-    reader.advance();
-  }
-  uint8_t block[64]{};
-  reader.get_remainder(block);
-  simd::simd8x64<uint8_t> in(block);
-  running_or |= in;
-  return running_or.is_ascii();
-}
-
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
-  size_t count{0};
-  while (reader.has_full_block()) {
-    simd::simd8x64<uint8_t> in(reader.full_block());
-    if (!in.is_ascii()) {
-      result res = scalar::ascii::validate_with_errors(
-          reinterpret_cast<const char *>(input + count), length - count);
-      return result(res.error, count + res.count);
-    }
-    reader.advance();
-
-    count += 64;
-  }
-  uint8_t block[64]{};
-  reader.get_remainder(block);
-  simd::simd8x64<uint8_t> in(block);
-  if (!in.is_ascii()) {
-    result res = scalar::ascii::validate_with_errors(
-        reinterpret_cast<const char *>(input + count), length - count);
-    return result(res.error, count + res.count);
-  } else {
-    return result(error_code::SUCCESS, length);
-  }
-}
-
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
 } // namespace utf8_validation
 } // unnamed namespace
 } // namespace ppc64
@@ -34802,7 +36663,6 @@ result generic_validate_ascii_with_errors(const char *input, size_t length) {
 /* end file src/generic/utf8_validation/utf8_validator.h */
 // transcoding from UTF-8 to UTF-16
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace ppc64 {
 namespace {
@@ -35137,7 +36997,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
-
 namespace simdutf {
 namespace ppc64 {
 namespace {
@@ -35215,7 +37074,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 // transcoding from UTF-8 to UTF-32
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace ppc64 {
 namespace {
@@ -35536,7 +37394,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
-
 namespace simdutf {
 namespace ppc64 {
 namespace {
@@ -35657,7 +37514,6 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace simdutf
 /* end file src/generic/utf16.h */
 /* begin file src/generic/utf8.h */
-
 namespace simdutf {
 namespace ppc64 {
 namespace {
@@ -36022,14 +37878,12 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
   return scalar::utf8::count_code_points(input, length);
 }
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   // skip trailing spaces
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
@@ -36053,7 +37907,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -36061,7 +37921,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -36070,14 +37930,12 @@ simdutf_warn_unused result implementation::base64_to_binary(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   // skip trailing spaces
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
@@ -36101,7 +37959,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -36109,7 +37973,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -36118,11 +37982,6 @@ simdutf_warn_unused result implementation::base64_to_binary(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
-}
-
 size_t implementation::binary_to_base64(const char *input, size_t length,
                                         char *output,
                                         base64_options options) const noexcept {
@@ -36137,11 +37996,6 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
 #endif
 #if SIMDUTF_IMPLEMENTATION_RVV
 /* begin file src/rvv/implementation.cpp */
-
-
-
-
-
 /* begin file src/simdutf/rvv/begin.h */
 // redefining SIMDUTF_IMPLEMENTATION to "rvv"
 // #define SIMDUTF_IMPLEMENTATION rvv
@@ -36195,7 +38049,7 @@ rvv_utf32_store_utf16_m4(uint16_t *dst, vuint32m4_t utf32, size_t vl,
 /* end file src/rvv/rvv_helpers.inl.cpp */
 
 /* begin file src/rvv/rvv_length_from.inl.cpp */
-
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t
 implementation::count_utf16le(const char16_t *src, size_t len) const noexcept {
   return utf32_length_from_utf16le(src, len);
@@ -36205,37 +38059,23 @@ simdutf_warn_unused size_t
 implementation::count_utf16be(const char16_t *src, size_t len) const noexcept {
   return utf32_length_from_utf16be(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *src, size_t len) const noexcept {
   return utf32_length_from_utf8(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *src, size_t len) const noexcept {
   return utf32_length_from_utf8(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t len) const noexcept {
-  return len;
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t len) const noexcept {
-  return len;
-}
-
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t len) const noexcept {
-  return len;
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t len) const noexcept {
-  return len;
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *src, size_t len) const noexcept {
   size_t count = 0;
@@ -36247,7 +38087,9 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
   }
   return count;
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static size_t
 rvv_utf32_length_from_utf16(const char16_t *src, size_t len) {
@@ -36276,7 +38118,9 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
   else
     return rvv_utf32_length_from_utf16<simdutf_ByteFlip::V>(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *src, size_t len) const noexcept {
   size_t count = len;
@@ -36287,7 +38131,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   }
   return count;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static size_t
 rvv_utf8_length_from_utf16(const char16_t *src, size_t len) {
@@ -36319,7 +38165,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
   else
     return rvv_utf8_length_from_utf16<simdutf_ByteFlip::V>(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *src, size_t len) const noexcept {
   size_t count = 0;
@@ -36334,7 +38182,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
   }
   return count;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *src, size_t len) const noexcept {
   size_t count = 0;
@@ -36348,7 +38198,9 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
   }
   return count;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *src, size_t len) const noexcept {
   size_t count = 0;
@@ -36360,10 +38212,10 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   }
   return count;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* end file src/rvv/rvv_length_from.inl.cpp */
 /* begin file src/rvv/rvv_validate.inl.cpp */
-
-
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *src, size_t len) const noexcept {
   size_t vlmax = __riscv_vsetvlmax_e8m8();
@@ -36389,7 +38241,9 @@ simdutf_warn_unused result implementation::validate_ascii_with_errors(
   }
   return result(error_code::SUCCESS, src - beg);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* Returns a close estimation of the number of valid UTF-8 bytes up to the
  * first invalid one, but never overestimating. */
 simdutf_really_inline static size_t rvv_count_valid_utf8(const char *src,
@@ -36478,26 +38332,18 @@ implementation::validate_utf8(const char *src, size_t len) const noexcept {
   size_t count = rvv_count_valid_utf8(src, len);
   return scalar::utf8::validate(src + count, len - count);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *src, size_t len) const noexcept {
   size_t count = rvv_count_valid_utf8(src, len);
   result res = scalar::utf8::validate_with_errors(src + count, len - count);
   return result(res.error, count + res.count);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
-simdutf_warn_unused bool
-implementation::validate_utf16le(const char16_t *src,
-                                 size_t len) const noexcept {
-  return validate_utf16le_with_errors(src, len).error == error_code::SUCCESS;
-}
-
-simdutf_warn_unused bool
-implementation::validate_utf16be(const char16_t *src,
-                                 size_t len) const noexcept {
-  return validate_utf16be_with_errors(src, len).error == error_code::SUCCESS;
-}
-
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static result
 rvv_validate_utf16_with_errors(const char16_t *src, size_t len) {
@@ -36530,7 +38376,26 @@ rvv_validate_utf16_with_errors(const char16_t *src, size_t len) {
     return result(error_code::SUCCESS, src - beg);
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+simdutf_warn_unused bool
+implementation::validate_utf16le(const char16_t *src,
+                                 size_t len) const noexcept {
+  return rvv_validate_utf16_with_errors<simdutf_ByteFlip::NONE>(src, len)
+             .error == error_code::SUCCESS;
+}
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+
+#if SIMDUTF_FEATURE_UTF16
+simdutf_warn_unused bool
+implementation::validate_utf16be(const char16_t *src,
+                                 size_t len) const noexcept {
+  return validate_utf16be_with_errors(src, len).error == error_code::SUCCESS;
+}
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused result implementation::validate_utf16le_with_errors(
     const char16_t *src, size_t len) const noexcept {
   return rvv_validate_utf16_with_errors<simdutf_ByteFlip::NONE>(src, len);
@@ -36543,7 +38408,9 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
   else
     return rvv_validate_utf16_with_errors<simdutf_ByteFlip::V>(src, len);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *src, size_t len) const noexcept {
   size_t vlmax = __riscv_vsetvlmax_e32m8();
@@ -36562,7 +38429,9 @@ implementation::validate_utf32(const char32_t *src, size_t len) const noexcept {
                  __riscv_vmsne_vx_u32m8_b4(maxOff, 0xFFFFF7FF, vlmax), vlmax),
              vlmax) < 0;
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *src, size_t len) const noexcept {
   const char32_t *beg = src;
@@ -36590,10 +38459,11 @@ simdutf_warn_unused result implementation::validate_utf32_with_errors(
   }
   return result(error_code::SUCCESS, src - beg);
 }
+#endif // SIMDUTF_FEATURE_UTF32
 /* end file src/rvv/rvv_validate.inl.cpp */
 
 /* begin file src/rvv/rvv_latin1_to.inl.cpp */
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *src, size_t len, char *dst) const noexcept {
   char *beg = dst;
@@ -36624,7 +38494,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
   }
   return dst - beg;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *src, size_t len, char16_t *dst) const noexcept {
   char16_t *beg = dst;
@@ -36648,7 +38520,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return dst - beg;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *src, size_t len, char32_t *dst) const noexcept {
   char32_t *beg = dst;
@@ -36659,10 +38533,10 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return dst - beg;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* end file src/rvv/rvv_latin1_to.inl.cpp */
 /* begin file src/rvv/rvv_utf16_to.inl.cpp */
-#include <cstdio>
-
+#if SIMDUTF_FEATURE_UTF16
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static result
 rvv_utf16_to_latin1_with_errors(const char16_t *src, size_t len, char *dst) {
@@ -36678,7 +38552,9 @@ rvv_utf16_to_latin1_with_errors(const char16_t *src, size_t len, char *dst) {
   }
   return result(error_code::SUCCESS, src - beg);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *src, size_t len, char *dst) const noexcept {
   result res = convert_utf16le_to_latin1_with_errors(src, len, dst);
@@ -36728,7 +38604,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_latin1(
   }
   return src - beg;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static result
 rvv_utf16_to_utf8_with_errors(const char16_t *src, size_t len, char *dst) {
@@ -36906,7 +38784,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *src, size_t len, char *dst) const noexcept {
   return convert_utf16be_to_utf8(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static result
 rvv_utf16_to_utf32_with_errors(const char16_t *src, size_t len, char32_t *dst) {
@@ -37054,9 +38934,11 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *src, size_t len, char32_t *dst) const noexcept {
   return convert_utf16be_to_utf32(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* end file src/rvv/rvv_utf16_to.inl.cpp */
-/* begin file src/rvv/rvv_utf32_to.inl.cpp */
 
+/* begin file src/rvv/rvv_utf32_to.inl.cpp */
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *src, size_t len, char *dst) const noexcept {
   result res = convert_utf32_to_latin1_with_errors(src, len, dst);
@@ -37086,7 +38968,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
     const char32_t *src, size_t len, char *dst) const noexcept {
   return convert_utf32_to_latin1(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
     const char32_t *src, size_t len, char *dst) const noexcept {
   size_t n = len;
@@ -37238,7 +39122,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *src, size_t len, char *dst) const noexcept {
   return convert_utf32_to_utf8(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static result
 rvv_convert_utf32_to_utf16_with_errors(const char32_t *src, size_t len,
@@ -37345,8 +39231,10 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf16be(
   else
     return rvv_convert_valid_utf32_to_utf16<simdutf_ByteFlip::V>(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* end file src/rvv/rvv_utf32_to.inl.cpp */
 /* begin file src/rvv/rvv_utf8_to.inl.cpp */
+#if SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32)
 template <typename Tdst, simdutf_ByteFlip bflip, bool validate = true>
 simdutf_really_inline static size_t rvv_utf8_to_common(char const *src,
                                                        size_t len, Tdst *dst) {
@@ -37389,6 +39277,7 @@ simdutf_really_inline static size_t rvv_utf8_to_common(char const *src,
   const vuint8m1_t err3tbl =
       __riscv_vreinterpret_v_u64m1_u8m1(__riscv_vle64_v_u64m1(err3m, 2));
 
+  size_t vl8m1 = __riscv_vsetvlmax_e8m1();
   size_t vl8m2 = __riscv_vsetvlmax_e8m2();
   vbool4_t m4even = __riscv_vmseq_vx_u8m2_b4(
       __riscv_vand_vx_u8m2(__riscv_vid_v_u8m2(vl8m2), 1, vl8m2), 0, vl8m2);
@@ -37537,51 +39426,51 @@ simdutf_really_inline static size_t rvv_utf8_to_common(char const *src,
      * vssubu.vx v, 10, (max(x-10, 0)) almost gives us what we want, we
      * just need to manually detect and handle the one special case:
      */
-#define SIMDUTF_RVV_UTF8_TO_COMMON_M1(idx)                                     \
-  vuint8m1_t c1 = __riscv_vget_v_u8m2_u8m1(b1, idx);                           \
-  vuint8m1_t c2 = __riscv_vget_v_u8m2_u8m1(b2, idx);                           \
-  vuint8m1_t c3 = __riscv_vget_v_u8m2_u8m1(b3, idx);                           \
-  vuint8m1_t c4 = __riscv_vget_v_u8m2_u8m1(b4, idx);                           \
-  /* remove prefix from trailing bytes */                                      \
-  c2 = __riscv_vand_vx_u8m1(c2, 0b00111111, vlOut);                            \
-  c3 = __riscv_vand_vx_u8m1(c3, 0b00111111, vlOut);                            \
-  c4 = __riscv_vand_vx_u8m1(c4, 0b00111111, vlOut);                            \
-  vuint8m1_t shift = __riscv_vsrl_vx_u8m1(c1, 4, vlOut);                       \
-  shift = __riscv_vmerge_vxm_u8m1(__riscv_vssubu_vx_u8m1(shift, 10, vlOut), 3, \
-                                  __riscv_vmseq_vx_u8m1_b8(shift, 12, vlOut),  \
-                                  vlOut);                                      \
-  c1 = __riscv_vsll_vv_u8m1(c1, shift, vlOut);                                 \
-  c1 = __riscv_vsrl_vv_u8m1(c1, shift, vlOut);                                 \
-  /* unconditionally widen and combine to c1234 */                             \
-  vuint16m2_t c34 = __riscv_vwaddu_wv_u16m2(                                   \
-      __riscv_vwmulu_vx_u16m2(c3, 1 << 6, vlOut), c4, vlOut);                  \
-  vuint16m2_t c12 = __riscv_vwaddu_wv_u16m2(                                   \
-      __riscv_vwmulu_vx_u16m2(c1, 1 << 6, vlOut), c2, vlOut);                  \
-  vuint32m4_t c1234 = __riscv_vwaddu_wv_u32m4(                                 \
-      __riscv_vwmulu_vx_u32m4(c12, 1 << 12, vlOut), c34, vlOut);               \
-  /* derive required right-shift amount from `shift` to reduce                 \
-   * c1234 to the required number of bytes */                                  \
-  c1234 = __riscv_vsrl_vv_u32m4(                                               \
-      c1234,                                                                   \
-      __riscv_vzext_vf4_u32m4(                                                 \
-          __riscv_vmul_vx_u8m1(                                                \
-              __riscv_vrsub_vx_u8m1(__riscv_vssubu_vx_u8m1(shift, 2, vlOut),   \
-                                    3, vlOut),                                 \
-              6, vlOut),                                                       \
-          vlOut),                                                              \
-      vlOut);                                                                  \
-  /* store result in desired format */                                         \
-  if (is16)                                                                    \
-    vlDst = rvv_utf32_store_utf16_m4<bflip>((uint16_t *)dst, c1234, vlOut,     \
-                                            m4even);                           \
-  else                                                                         \
-    vlDst = vlOut, __riscv_vse32_v_u32m4((uint32_t *)dst, c1234, vlOut);
+  #define SIMDUTF_RVV_UTF8_TO_COMMON_M1(idx)                                   \
+    vuint8m1_t c1 = __riscv_vget_v_u8m2_u8m1(b1, idx);                         \
+    vuint8m1_t c2 = __riscv_vget_v_u8m2_u8m1(b2, idx);                         \
+    vuint8m1_t c3 = __riscv_vget_v_u8m2_u8m1(b3, idx);                         \
+    vuint8m1_t c4 = __riscv_vget_v_u8m2_u8m1(b4, idx);                         \
+    /* remove prefix from trailing bytes */                                    \
+    c2 = __riscv_vand_vx_u8m1(c2, 0b00111111, vlOut);                          \
+    c3 = __riscv_vand_vx_u8m1(c3, 0b00111111, vlOut);                          \
+    c4 = __riscv_vand_vx_u8m1(c4, 0b00111111, vlOut);                          \
+    vuint8m1_t shift = __riscv_vsrl_vx_u8m1(c1, 4, vlOut);                     \
+    shift = __riscv_vmerge_vxm_u8m1(                                           \
+        __riscv_vssubu_vx_u8m1(shift, 10, vlOut), 3,                           \
+        __riscv_vmseq_vx_u8m1_b8(shift, 12, vlOut), vlOut);                    \
+    c1 = __riscv_vsll_vv_u8m1(c1, shift, vlOut);                               \
+    c1 = __riscv_vsrl_vv_u8m1(c1, shift, vlOut);                               \
+    /* unconditionally widen and combine to c1234 */                           \
+    vuint16m2_t c34 = __riscv_vwaddu_wv_u16m2(                                 \
+        __riscv_vwmulu_vx_u16m2(c3, 1 << 6, vlOut), c4, vlOut);                \
+    vuint16m2_t c12 = __riscv_vwaddu_wv_u16m2(                                 \
+        __riscv_vwmulu_vx_u16m2(c1, 1 << 6, vlOut), c2, vlOut);                \
+    vuint32m4_t c1234 = __riscv_vwaddu_wv_u32m4(                               \
+        __riscv_vwmulu_vx_u32m4(c12, 1 << 12, vlOut), c34, vlOut);             \
+    /* derive required right-shift amount from `shift` to reduce               \
+     * c1234 to the required number of bytes */                                \
+    c1234 = __riscv_vsrl_vv_u32m4(                                             \
+        c1234,                                                                 \
+        __riscv_vzext_vf4_u32m4(                                               \
+            __riscv_vmul_vx_u8m1(                                              \
+                __riscv_vrsub_vx_u8m1(__riscv_vssubu_vx_u8m1(shift, 2, vlOut), \
+                                      3, vlOut),                               \
+                6, vlOut),                                                     \
+            vlOut),                                                            \
+        vlOut);                                                                \
+    /* store result in desired format */                                       \
+    if (is16)                                                                  \
+      vlDst = rvv_utf32_store_utf16_m4<bflip>((uint16_t *)dst, c1234, vlOut,   \
+                                              m4even);                         \
+    else                                                                       \
+      vlDst = vlOut, __riscv_vse32_v_u32m4((uint32_t *)dst, c1234, vlOut);
 
     /* Unrolling this manually reduces register pressure and allows
      * us to terminate early. */
     {
       size_t vlOutm2 = vlOut, vlDst;
-      vlOut = __riscv_vsetvl_e8m1(vlOut);
+      vlOut = __riscv_vsetvl_e8m1(vlOut < vl8m1 ? vlOut : vl8m1);
       SIMDUTF_RVV_UTF8_TO_COMMON_M1(0)
       if (vlOutm2 == vlOut) {
         vlOut = vlDst;
@@ -37597,7 +39486,7 @@ simdutf_really_inline static size_t rvv_utf8_to_common(char const *src,
       vlOut = vlDst;
     }
 
-#undef SIMDUTF_RVV_UTF8_TO_COMMON_M1
+  #undef SIMDUTF_RVV_UTF8_TO_COMMON_M1
   }
 
   /* validate the last character and reparse it + tail */
@@ -37618,7 +39507,10 @@ simdutf_really_inline static size_t rvv_utf8_to_common(char const *src,
     return 0;
   return (size_t)(dst - beg) + ret;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32)
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *src, size_t len, char *dst) const noexcept {
   const char *beg = dst;
@@ -37707,7 +39599,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
   }
   return dst - beg;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *src, size_t len, char16_t *dst) const noexcept {
   return rvv_utf8_to_common<uint16_t, simdutf_ByteFlip::NONE>(src, len,
@@ -37757,7 +39651,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
     return rvv_utf8_to_common<uint16_t, simdutf_ByteFlip::V, false>(
         src, len, (uint16_t *)dst);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *src, size_t len, char32_t *dst) const noexcept {
   return rvv_utf8_to_common<uint32_t, simdutf_ByteFlip::NONE>(src, len,
@@ -37777,8 +39673,10 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
   return rvv_utf8_to_common<uint32_t, simdutf_ByteFlip::NONE, false>(
       src, len, (uint32_t *)dst);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* end file src/rvv/rvv_utf8_to.inl.cpp */
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -37791,7 +39689,7 @@ implementation::detect_encodings(const char *input,
   if (validate_utf8(input, length))
     out |= encoding_type::UTF8;
   if (length % 2 == 0) {
-    if (validate_utf16(reinterpret_cast<const char16_t *>(input), length / 2))
+    if (validate_utf16le(reinterpret_cast<const char16_t *>(input), length / 2))
       out |= encoding_type::UTF16_LE;
   }
   if (length % 4 == 0) {
@@ -37801,7 +39699,9 @@ implementation::detect_encodings(const char *input,
 
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 template <simdutf_ByteFlip bflip>
 simdutf_really_inline static void
 rvv_change_endianness_utf16(const char16_t *src, size_t len, char16_t *dst) {
@@ -37819,15 +39719,15 @@ void implementation::change_endianness_utf16(const char16_t *src, size_t len,
   else
     return rvv_change_endianness_utf16<simdutf_ByteFlip::V>(src, len, dst);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -37850,7 +39750,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -37858,7 +39764,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -37870,6 +39776,9 @@ simdutf_warn_unused result implementation::base64_to_binary(
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -37892,7 +39801,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -37900,7 +39815,7 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   full_result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.output_count % 3 == 0) ||
         ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -37910,14 +39825,12 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -37940,7 +39853,13 @@ simdutf_warn_unused result implementation::base64_to_binary(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation};
     }
     return {SUCCESS, 0};
@@ -37948,7 +39867,7 @@ simdutf_warn_unused result implementation::base64_to_binary(
   result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.count % 3 == 0) || ((r.count % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation};
@@ -37960,6 +39879,9 @@ simdutf_warn_unused result implementation::base64_to_binary(
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
+  const bool ignore_garbage =
+      (options == base64_options::base64_url_accept_garbage) ||
+      (options == base64_options::base64_default_accept_garbage);
   while (length > 0 &&
          scalar::base64::is_ascii_white_space(input[length - 1])) {
     length--;
@@ -37982,7 +39904,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
     }
   }
   if (length == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -37990,7 +39918,7 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   full_result r = scalar::base64::base64_tail_decode(
       output, input, length, equalsigns, options, last_chunk_options);
   if (last_chunk_options != stop_before_partial &&
-      r.error == error_code::SUCCESS && equalsigns > 0) {
+      r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
     // additional checks
     if ((r.output_count % 3 == 0) ||
         ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -38000,16 +39928,13 @@ simdutf_warn_unused full_result implementation::base64_to_binary_details(
   return r;
 }
 
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
-}
-
 size_t implementation::binary_to_base64(const char *input, size_t length,
                                         char *output,
                                         base64_options options) const noexcept {
   return scalar::base64::tail_encode_base64(output, input, length, options);
 }
+#endif // SIMDUTF_FEATURE_BASE64
+
 } // namespace rvv
 } // namespace simdutf
 
@@ -38043,25 +39968,15 @@ namespace {
 #endif
 using namespace simd;
 
+#if SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    SIMDUTF_FEATURE_UTF8
 simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   return input.reduce_or().is_ascii();
 }
+#endif // SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // SIMDUTF_FEATURE_UTF8
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<uint8_t> is_second_byte =
-      prev1.saturating_sub(0b11000000u - 1); // Only 11______ will be > 0
-  simd8<uint8_t> is_third_byte =
-      prev2.saturating_sub(0b11100000u - 1); // Only 111_____ will be > 0
-  simd8<uint8_t> is_fourth_byte =
-      prev3.saturating_sub(0b11110000u - 1); // Only 1111____ will be > 0
-  // Caller requires a bool (all 1's). All values resulting from the subtraction
-  // will be <= 64, so signed comparison is fine.
-  return simd8<int8_t>(is_second_byte | is_third_byte | is_fourth_byte) >
-         int8_t(0);
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -38071,7 +39986,9 @@ must_be_2_3_continuation(const simd8<uint8_t> prev2,
       prev3.saturating_sub(0xf0u - 0x80); // Only 1111____ will be >= 0x80
   return simd8<bool>(is_third_byte | is_fourth_byte);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/westmere/internal/loader.cpp */
 namespace internal {
 namespace westmere {
@@ -38148,292 +40065,31 @@ inline void write_v_u16_11bits_to_utf8(const __m128i v_u16, char *&utf8_output,
 } // namespace westmere
 } // namespace internal
 /* end file src/westmere/internal/loader.cpp */
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/westmere/sse_validate_utf16.cpp */
-/*
-    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
-
-    In a vectorized algorithm we want to examine the most significant
-    nibble in order to select a fast path. If none of highest nibbles
-    are 0xD (13), than we are sure that UTF-16 chunk in a vector
-    register is valid.
-
-    Let us analyze what we need to check if the nibble is 0xD. The
-    value of the preceding nibble determines what we have:
-
-    0xd000 .. 0xd7ff - a valid word
-    0xd800 .. 0xdbff - low surrogate
-    0xdc00 .. 0xdfff - high surrogate
-
-    Other constraints we have to consider:
-    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
-    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
-    - there must not be sole low surrogate nor high surrogate
-
-    We are going to build three bitmasks based on the 3rd nibble:
-    - V = valid word,
-    - L = low surrogate (0xd800 .. 0xdbff)
-    - H = high surrogate (0xdc00 .. 0xdfff)
-
-      0   1   2   3   4   5   6   7    <--- word index
-    [ V | L | H | L | H | V | V | L ]
-      1   0   0   0   0   1   1   0     - V = valid masks
-      0   1   0   1   0   0   0   1     - L = low surrogate
-      0   0   1   0   1   0   0   0     - H high surrogate
-
-
-      1   0   0   0   0   1   1   0   V = valid masks
-      0   1   0   1   0   0   0   0   a = L & (H >> 1)
-      0   0   1   0   1   0   0   0   b = a << 1
-      1   1   1   1   1   1   1   0   c = V | a | b
-                                  ^
-                                  the last bit can be zero, we just consume 7
-   code units and recheck this word in the next iteration
-*/
-
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
 template <endianness big_endian>
-const char16_t *sse_validate_utf16(const char16_t *input, size_t size) {
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::SIZE * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 =
-        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
+simd8<uint8_t> utf16_gather_high_bytes(const simd16<uint16_t> in0,
+                                       const simd16<uint16_t> in1) {
+  if (big_endian) {
+    // we want lower bytes
+    const auto mask = simd16<uint16_t>(0x00ff);
+    const auto t0 = in0 & mask;
+    const auto t1 = in1 & mask;
 
+    return simd16<uint16_t>::pack(t0, t1);
+  } else {
     const auto t0 = in0.shr<8>();
     const auto t1 = in1.shr<8>();
 
-    const auto in = simd16<uint16_t>::pack(t0, t1);
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint16_t surrogates_bitmask =
-        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
-    if (surrogates_bitmask == 0x0000) {
-      input += 16;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
-
-      const uint16_t a = static_cast<uint16_t>(
-          L & (H >> 1)); // A low surrogate must be followed by high one.
-                         // (A low surrogate placed in the 7th register's word
-                         // is an exception we handle.)
-      const uint16_t b = static_cast<uint16_t>(
-          a << 1); // Just mark that the opinput - startite fact is hold,
-                   // thanks to that we have only two masks for valid case.
-      const uint16_t c = static_cast<uint16_t>(
-          V | a | b); // Combine all the masks into the final one.
-
-      if (c == 0xffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += 16;
-      } else if (c == 0x7fff) {
-        // The 15 lower code units of the input register contains valid UTF-16.
-        // The 15th word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += 15;
-      } else {
-        return nullptr;
-      }
-    }
+    return simd16<uint16_t>::pack(t0, t1);
   }
-
-  return input;
-}
-
-template <endianness big_endian>
-const result sse_validate_utf16_with_errors(const char16_t *input,
-                                            size_t size) {
-  if (simdutf_unlikely(size == 0)) {
-    return result(error_code::SUCCESS, 0);
-  }
-  const char16_t *start = input;
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::SIZE * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 =
-        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-
-    const auto t0 = in0.shr<8>();
-    const auto t1 = in1.shr<8>();
-
-    const auto in = simd16<uint16_t>::pack(t0, t1);
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint16_t surrogates_bitmask =
-        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
-    if (surrogates_bitmask == 0x0000) {
-      input += 16;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
-
-      const uint16_t a = static_cast<uint16_t>(
-          L & (H >> 1)); // A low surrogate must be followed by high one.
-                         // (A low surrogate placed in the 7th register's word
-                         // is an exception we handle.)
-      const uint16_t b = static_cast<uint16_t>(
-          a << 1); // Just mark that the opinput - startite fact is hold,
-                   // thanks to that we have only two masks for valid case.
-      const uint16_t c = static_cast<uint16_t>(
-          V | a | b); // Combine all the masks into the final one.
-
-      if (c == 0xffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += 16;
-      } else if (c == 0x7fff) {
-        // The 15 lower code units of the input register contains valid UTF-16.
-        // The 15th word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += 15;
-      } else {
-        return result(error_code::SURROGATE, input - start);
-      }
-    }
-  }
-
-  return result(error_code::SUCCESS, input - start);
 }
 /* end file src/westmere/sse_validate_utf16.cpp */
-/* begin file src/westmere/sse_validate_utf32le.cpp */
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
-const char32_t *sse_validate_utf32le(const char32_t *input, size_t size) {
-  const char32_t *end = input + size;
-
-  const __m128i standardmax = _mm_set1_epi32(0x10ffff);
-  const __m128i offset = _mm_set1_epi32(0xffff2000);
-  const __m128i standardoffsetmax = _mm_set1_epi32(0xfffff7ff);
-  __m128i currentmax = _mm_setzero_si128();
-  __m128i currentoffsetmax = _mm_setzero_si128();
-
-  while (input + 4 < end) {
-    const __m128i in = _mm_loadu_si128((__m128i *)input);
-    currentmax = _mm_max_epu32(in, currentmax);
-    currentoffsetmax =
-        _mm_max_epu32(_mm_add_epi32(in, offset), currentoffsetmax);
-    input += 4;
-  }
-  __m128i is_zero =
-      _mm_xor_si128(_mm_max_epu32(currentmax, standardmax), standardmax);
-  if (_mm_test_all_zeros(is_zero, is_zero) == 0) {
-    return nullptr;
-  }
-
-  is_zero = _mm_xor_si128(_mm_max_epu32(currentoffsetmax, standardoffsetmax),
-                          standardoffsetmax);
-  if (_mm_test_all_zeros(is_zero, is_zero) == 0) {
-    return nullptr;
-  }
-
-  return input;
-}
-
-const result sse_validate_utf32le_with_errors(const char32_t *input,
-                                              size_t size) {
-  const char32_t *start = input;
-  const char32_t *end = input + size;
-
-  const __m128i standardmax = _mm_set1_epi32(0x10ffff);
-  const __m128i offset = _mm_set1_epi32(0xffff2000);
-  const __m128i standardoffsetmax = _mm_set1_epi32(0xfffff7ff);
-  __m128i currentmax = _mm_setzero_si128();
-  __m128i currentoffsetmax = _mm_setzero_si128();
-
-  while (input + 4 < end) {
-    const __m128i in = _mm_loadu_si128((__m128i *)input);
-    currentmax = _mm_max_epu32(in, currentmax);
-    currentoffsetmax =
-        _mm_max_epu32(_mm_add_epi32(in, offset), currentoffsetmax);
-
-    __m128i is_zero =
-        _mm_xor_si128(_mm_max_epu32(currentmax, standardmax), standardmax);
-    if (_mm_test_all_zeros(is_zero, is_zero) == 0) {
-      return result(error_code::TOO_LARGE, input - start);
-    }
-
-    is_zero = _mm_xor_si128(_mm_max_epu32(currentoffsetmax, standardoffsetmax),
-                            standardoffsetmax);
-    if (_mm_test_all_zeros(is_zero, is_zero) == 0) {
-      return result(error_code::SURROGATE, input - start);
-    }
-    input += 4;
-  }
-
-  return result(error_code::SUCCESS, input - start);
-}
-/* end file src/westmere/sse_validate_utf32le.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_latin1_to_utf8.cpp */
 std::pair<const char *const, char *const>
 sse_convert_latin1_to_utf8(const char *latin_input,
@@ -38507,6 +40163,9 @@ sse_convert_latin1_to_utf8(const char *latin_input,
   return std::make_pair(latin_input, utf8_output);
 }
 /* end file src/westmere/sse_convert_latin1_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_latin1_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char *, char16_t *>
@@ -38530,6 +40189,9 @@ sse_convert_latin1_to_utf16(const char *latin1_input, size_t len,
   return std::make_pair(latin1_input + rounded_len, utf16_output + rounded_len);
 }
 /* end file src/westmere/sse_convert_latin1_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_latin1_to_utf32.cpp */
 std::pair<const char *, char32_t *>
 sse_convert_latin1_to_utf32(const char *buf, size_t len,
@@ -38563,7 +40225,9 @@ sse_convert_latin1_to_utf32(const char *buf, size_t len,
   return std::make_pair(buf, utf32_output);
 }
 /* end file src/westmere/sse_convert_latin1_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/westmere/sse_convert_utf8_to_utf16.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -38763,6 +40427,9 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   return consumed;
 }
 /* end file src/westmere/sse_convert_utf8_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/westmere/sse_convert_utf8_to_utf32.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -38906,6 +40573,9 @@ size_t convert_masked_utf8_to_utf32(const char *input,
   return consumed;
 }
 /* end file src/westmere/sse_convert_utf8_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_utf8_to_latin1.cpp */
 // depends on "tables/utf8_to_utf16_tables.h"
 
@@ -38966,7 +40636,9 @@ size_t convert_masked_utf8_to_latin1(const char *input,
   return consumed;
 }
 /* end file src/westmere/sse_convert_utf8_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_utf16_to_latin1.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char *>
@@ -39024,9 +40696,8 @@ sse_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     } else {
       // Fallback to scalar code for handling errors
       for (int k = 0; k < 8; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if (word <= 0xff) {
           *latin1_output++ = char(word);
         } else {
@@ -39041,6 +40712,9 @@ sse_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/westmere/sse_convert_utf16_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/westmere/sse_convert_utf16_to_utf8.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -39282,7 +40956,7 @@ sse_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_output) {
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -39296,7 +40970,7 @@ sse_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_output) {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -39511,7 +41185,7 @@ sse_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -39525,7 +41199,7 @@ sse_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -39547,6 +41221,9 @@ sse_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf8_output);
 }
 /* end file src/westmere/sse_convert_utf16_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/westmere/sse_convert_utf16_to_utf32.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -39650,14 +41327,14 @@ sse_convert_utf16_to_utf32(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -39730,14 +41407,14 @@ sse_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = big_endian ? scalar::utf16::swap_bytes(buf[k]) : buf[k];
+        uint16_t word = big_endian ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word =
-              big_endian ? scalar::utf16::swap_bytes(buf[k + 1]) : buf[k + 1];
+              big_endian ? scalar::u16_swap_bytes(buf[k + 1]) : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
           if ((diff | diff2) > 0x3FF) {
@@ -39755,7 +41432,9 @@ sse_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf32_output);
 }
 /* end file src/westmere/sse_convert_utf16_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/westmere/sse_convert_utf32_to_latin1.cpp */
 std::pair<const char32_t *, char *>
 sse_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -39840,6 +41519,9 @@ sse_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/westmere/sse_convert_utf32_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/westmere/sse_convert_utf32_to_utf8.cpp */
 std::pair<const char32_t *, char *>
 sse_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_output) {
@@ -40432,6 +42114,9 @@ sse_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf8_output);
 }
 /* end file src/westmere/sse_convert_utf32_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/westmere/sse_convert_utf32_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
@@ -40604,6 +42289,9 @@ sse_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
   return std::make_pair(result(error_code::SUCCESS, buf - start), utf16_output);
 }
 /* end file src/westmere/sse_convert_utf32_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/westmere/sse_base64.cpp */
 /**
  * References and further reading:
@@ -40813,7 +42501,7 @@ struct block64 {
   __m128i chunks[4];
 };
 
-template <bool base64_url>
+template <bool base64_url, bool ignore_garbage>
 static inline uint16_t to_base64_mask(__m128i *src, uint32_t *error) {
   const __m128i ascii_space_tbl =
       _mm_setr_epi8(0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xa, 0x0,
@@ -40878,7 +42566,7 @@ static inline uint16_t to_base64_mask(__m128i *src, uint32_t *error) {
   const __m128i chk =
       _mm_adds_epi8(_mm_shuffle_epi8(check_values, check_hash), *src);
   const int mask = _mm_movemask_epi8(chk);
-  if (mask) {
+  if (!ignore_garbage && mask) {
     __m128i ascii_space =
         _mm_cmpeq_epi8(_mm_shuffle_epi8(ascii_space_tbl, *src), *src);
     *error = (mask ^ _mm_movemask_epi8(ascii_space));
@@ -40887,18 +42575,24 @@ static inline uint16_t to_base64_mask(__m128i *src, uint32_t *error) {
   return (uint16_t)mask;
 }
 
-template <bool base64_url>
+template <bool base64_url, bool ignore_garbage>
 static inline uint64_t to_base64_mask(block64 *b, uint64_t *error) {
   uint32_t err0 = 0;
   uint32_t err1 = 0;
   uint32_t err2 = 0;
   uint32_t err3 = 0;
-  uint64_t m0 = to_base64_mask<base64_url>(&b->chunks[0], &err0);
-  uint64_t m1 = to_base64_mask<base64_url>(&b->chunks[1], &err1);
-  uint64_t m2 = to_base64_mask<base64_url>(&b->chunks[2], &err2);
-  uint64_t m3 = to_base64_mask<base64_url>(&b->chunks[3], &err3);
-  *error = (err0) | ((uint64_t)err1 << 16) | ((uint64_t)err2 << 32) |
-           ((uint64_t)err3 << 48);
+  uint64_t m0 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[0], &err0);
+  uint64_t m1 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[1], &err1);
+  uint64_t m2 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[2], &err2);
+  uint64_t m3 =
+      to_base64_mask<base64_url, ignore_garbage>(&b->chunks[3], &err3);
+  if (!ignore_garbage) {
+    *error = (err0) | ((uint64_t)err1 << 16) | ((uint64_t)err2 << 32) |
+             ((uint64_t)err3 << 48);
+  }
   return m0 | (m1 << 16) | (m2 << 32) | (m3 << 48);
 }
 
@@ -40962,6 +42656,8 @@ static inline void load_block(block64 *b, const char16_t *src) {
   b->chunks[3] = _mm_packus_epi16(m7, m8);
 }
 
+template <typename T> bool is_power_of_two(T x) { return (x & (x - 1)) == 0; }
+
 static inline void base64_decode(char *out, __m128i str) {
   // credit: aqrit
 
@@ -41011,7 +42707,72 @@ static inline void base64_decode_block_safe(char *out, block64 *b) {
   std::memcpy(out + 36, buffer, 12);
 }
 
-template <bool base64_url, typename chartype>
+simdutf_really_inline static size_t
+compress_block_single(block64 *b, uint64_t mask, char *output) {
+  const size_t pos64 = simdutf_tzcnt_u64(mask);
+  const int8_t pos = pos64 & 0xf;
+  switch (pos64 >> 4) {
+  case 0b00: {
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(b->chunks[0], sh);
+
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), compressed);
+    _mm_storeu_si128((__m128i *)(output + 1 * 16 - 1), b->chunks[1]);
+    _mm_storeu_si128((__m128i *)(output + 2 * 16 - 1), b->chunks[2]);
+    _mm_storeu_si128((__m128i *)(output + 3 * 16 - 1), b->chunks[3]);
+  } break;
+  case 0b01: {
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), b->chunks[0]);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(b->chunks[1], sh);
+
+    _mm_storeu_si128((__m128i *)(output + 1 * 16), compressed);
+    _mm_storeu_si128((__m128i *)(output + 2 * 16 - 1), b->chunks[2]);
+    _mm_storeu_si128((__m128i *)(output + 3 * 16 - 1), b->chunks[3]);
+  } break;
+  case 0b10: {
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), b->chunks[0]);
+    _mm_storeu_si128((__m128i *)(output + 1 * 16), b->chunks[1]);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(b->chunks[2], sh);
+
+    _mm_storeu_si128((__m128i *)(output + 2 * 16), compressed);
+    _mm_storeu_si128((__m128i *)(output + 3 * 16 - 1), b->chunks[3]);
+  } break;
+  case 0b11: {
+    _mm_storeu_si128((__m128i *)(output + 0 * 16), b->chunks[0]);
+    _mm_storeu_si128((__m128i *)(output + 1 * 16), b->chunks[1]);
+    _mm_storeu_si128((__m128i *)(output + 2 * 16), b->chunks[2]);
+
+    const __m128i v0 = _mm_set1_epi8(char(pos - 1));
+    const __m128i v1 =
+        _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+    const __m128i v2 = _mm_cmpgt_epi8(v1, v0);
+    const __m128i sh = _mm_sub_epi8(v1, v2);
+    const __m128i compressed = _mm_shuffle_epi8(b->chunks[3], sh);
+
+    _mm_storeu_si128((__m128i *)(output + 3 * 16), compressed);
+  } break;
+  }
+
+  return 63;
+}
+
+template <bool base64_url, bool ignore_garbage, typename chartype>
 full_result
 compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                        base64_options options,
@@ -41021,12 +42782,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   size_t equallocation =
       srclen; // location of the first padding character if any
   // skip trailing spaces
-  while (srclen > 0 && scalar::base64::is_eight_byte(src[srclen - 1]) &&
+  while (!ignore_garbage && srclen > 0 &&
+         scalar::base64::is_eight_byte(src[srclen - 1]) &&
          to_base64[uint8_t(src[srclen - 1])] == 64) {
     srclen--;
   }
   size_t equalsigns = 0;
-  if (srclen > 0 && src[srclen - 1] == '=') {
+  if (!ignore_garbage && srclen > 0 && src[srclen - 1] == '=') {
     equallocation = srclen - 1;
     srclen--;
     equalsigns = 1;
@@ -41042,7 +42804,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -41065,18 +42833,23 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       load_block(&b, src);
       src += 64;
       uint64_t error = 0;
-      uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
-      if (error) {
+      uint64_t badcharmask =
+          to_base64_mask<base64_url, ignore_garbage>(&b, &error);
+      if (error && !ignore_garbage) {
         src -= 64;
         size_t error_offset = simdutf_tzcnt_u64(error);
         return {error_code::INVALID_BASE64_CHARACTER,
                 size_t(src - srcinit + error_offset), size_t(dst - dstinit)};
       }
       if (badcharmask != 0) {
-        // optimization opportunity: check for simple masks like those made of
-        // continuous 1s followed by continuous 0s. And masks containing a
-        // single bad character.
-        bufferptr += compress_block(&b, badcharmask, bufferptr);
+        if (is_power_of_two(badcharmask)) {
+          bufferptr += compress_block_single(&b, badcharmask, bufferptr);
+        } else {
+          // optimization opportunity: check for simple masks like those made of
+          // continuous 1s followed by continuous 0s. And masks containing a
+          // single bad character.
+          bufferptr += compress_block(&b, badcharmask, bufferptr);
+        }
       } else if (bufferptr != buffer) {
         copy_block(&b, bufferptr);
         bufferptr += 64;
@@ -41114,7 +42887,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     while ((bufferptr - buffer_start) % 64 != 0 && src < srcend) {
       uint8_t val = to_base64[uint8_t(*src)];
       *bufferptr = char(val);
-      if (!scalar::base64::is_eight_byte(*src) || val > 64) {
+      if ((!scalar::base64::is_eight_byte(*src) || val > 64) &&
+          !ignore_garbage) {
         return {error_code::INVALID_BASE64_CHARACTER, size_t(src - srcinit),
                 size_t(dst - dstinit)};
       }
@@ -41138,7 +42912,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 4);
 
       dst += 3;
@@ -41150,7 +42924,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 3);
 
       dst += 3;
@@ -41160,8 +42934,14 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     // backtrack
     int leftover = int(bufferptr - buffer_start);
     while (leftover > 0) {
-      while (to_base64[uint8_t(*(src - 1))] == 64) {
-        src--;
+      if (!ignore_garbage) {
+        while (to_base64[uint8_t(*(src - 1))] == 64) {
+          src--;
+        }
+      } else {
+        while (to_base64[uint8_t(*(src - 1))] >= 64) {
+          src--;
+        }
       }
       src--;
       leftover--;
@@ -41178,7 +42958,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       r.output_count += size_t(dst - dstinit);
     }
     if (last_chunk_options != stop_before_partial &&
-        r.error == error_code::SUCCESS && equalsigns > 0) {
+        r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
       // additional checks
       if ((r.output_count % 3 == 0) ||
           ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -41188,7 +42968,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
     return r;
   }
-  if (equalsigns > 0) {
+  if (equalsigns > 0 && !ignore_garbage) {
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -41197,6 +42977,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/westmere/sse_base64.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // unnamed namespace
 } // namespace westmere
@@ -41313,6 +43094,7 @@ simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance() {
 } // namespace westmere
 } // namespace simdutf
 /* end file src/generic/buf_block_reader.h */
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
 namespace simdutf {
 namespace westmere {
@@ -41619,9 +43401,21 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+} // namespace utf8_validation
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+/* end file src/generic/utf8_validation/utf8_validator.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/generic/ascii_validation.h */
+namespace simdutf {
+namespace westmere {
+namespace {
+namespace ascii_validation {
+
+bool generic_validate_ascii(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   uint8_t blocks[64]{};
   simd::simd8x64<uint8_t> running_or(blocks);
   while (reader.has_full_block()) {
@@ -41636,14 +43430,8 @@ bool generic_validate_ascii(const uint8_t *input, size_t length) {
   return running_or.is_ascii();
 }
 
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+result generic_validate_ascii_with_errors(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   size_t count{0};
   while (reader.has_full_block()) {
     simd::simd8x64<uint8_t> in(reader.full_block());
@@ -41668,19 +43456,16 @@ result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
   }
 }
 
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-} // namespace utf8_validation
+} // namespace ascii_validation
 } // unnamed namespace
 } // namespace westmere
 } // namespace simdutf
-/* end file src/generic/utf8_validation/utf8_validator.h */
-// transcoding from UTF-8 to UTF-16
-/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
+/* end file src/generic/ascii_validation.h */
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  // transcoding from UTF-8 to UTF-16
+/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -41757,7 +43542,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42091,9 +43875,10 @@ struct validating_transcoder {
 } // namespace westmere
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-// transcoding from UTF-8 to UTF-32
-/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42138,7 +43923,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42458,9 +44242,118 @@ struct validating_transcoder {
 } // namespace westmere
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-// other functions
-/* begin file src/generic/utf8.h */
+/* begin file src/generic/utf32.h */
+#include <limits>
+
+namespace simdutf {
+namespace westmere {
+namespace {
+namespace utf32 {
+
+template <typename T> T min(T a, T b) { return a <= b ? a : b; }
+
+size_t utf8_length_from_utf32(const char32_t *input, size_t length) {
+  using vector_u32 = simd32<uint32_t>;
+
+  const char32_t *start = input;
+
+  // we add up to three ones in a single iteration (see the vectorized loop in
+  // section #2 below)
+  const size_t max_increment = 3;
+
+  const size_t N = vector_u32::ELEMENTS;
+
+  const auto one = vector_u32::splat(1);
+  const auto v_ffffff80 = vector_u32::splat(0xffffff80);
+  const auto v_fffff800 = vector_u32::splat(0xfffff800);
+  const auto v_ffff0000 = vector_u32::splat(0xffff0000);
+
+  size_t counter = 0;
+
+  // 1. vectorized loop unrolled 4 times
+  {
+    // we use uint32 counters, this is
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / (max_increment * 4);
+    size_t blocks = length / (N * 4);
+    length -= blocks * (N * 4);
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      simd32<uint32_t> acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in0 = vector_u32(input + 0 * N);
+        const auto in1 = vector_u32(input + 1 * N);
+        const auto in2 = vector_u32(input + 2 * N);
+        const auto in3 = vector_u32(input + 3 * N);
+
+        acc += min(one, in0 & v_ffffff80);
+        acc += min(one, in1 & v_ffffff80);
+        acc += min(one, in2 & v_ffffff80);
+        acc += min(one, in3 & v_ffffff80);
+
+        acc += min(one, in0 & v_fffff800);
+        acc += min(one, in1 & v_fffff800);
+        acc += min(one, in2 & v_fffff800);
+        acc += min(one, in3 & v_fffff800);
+
+        acc += min(one, in0 & v_ffff0000);
+        acc += min(one, in1 & v_ffff0000);
+        acc += min(one, in2 & v_ffff0000);
+        acc += min(one, in3 & v_ffff0000);
+
+        input += 4 * N;
+      }
 
+      counter += acc.sum();
+    }
+  }
+
+  // 2. vectorized loop for tail
+  {
+    const size_t max_iterations =
+        std::numeric_limits<uint32_t>::max() / max_increment;
+    size_t blocks = length / N;
+    length -= blocks * N;
+    while (blocks != 0) {
+      const size_t iterations = min(blocks, max_iterations);
+      blocks -= iterations;
+
+      auto acc = vector_u32::zero();
+      for (size_t i = 0; i < iterations; i++) {
+        const auto in = vector_u32(input);
+
+        acc += min(one, in & v_ffffff80);
+        acc += min(one, in & v_fffff800);
+        acc += min(one, in & v_ffff0000);
+
+        input += N;
+      }
+
+      counter += acc.sum();
+    }
+  }
+
+  const size_t consumed = input - start;
+  if (consumed != 0) {
+    // We don't count 0th bytes in the vectorized loops above, this
+    // is why we need to count them in the end.
+    counter += consumed;
+  }
+
+  return counter + scalar::utf32::utf8_length_from_utf32(input, length);
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+/* end file src/generic/utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+
+#if SIMDUTF_FEATURE_UTF8
+/* begin file src/generic/utf8.h */
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42500,6 +44393,8 @@ simdutf_really_inline size_t utf16_length_from_utf8(const char *in,
 } // namespace westmere
 } // namespace simdutf
 /* end file src/generic/utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/generic/utf16.h */
 namespace simdutf {
 namespace westmere {
@@ -42575,9 +44470,144 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace westmere
 } // namespace simdutf
 /* end file src/generic/utf16.h */
-// transcoding from UTF-8 to Latin 1
-/* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf16.h */
+namespace simdutf {
+namespace westmere {
+namespace {
+namespace utf16 {
+/*
+    UTF-16 validation
+    --------------------------------------------------
+
+    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
+
+    In a vectorized algorithm we want to examine the most significant
+    nibble in order to select a fast path. If none of highest nibbles
+    are 0xD (13), than we are sure that UTF-16 chunk in a vector
+    register is valid.
+
+    Let us analyze what we need to check if the nibble is 0xD. The
+    value of the preceding nibble determines what we have:
+
+    0xd000 .. 0xd7ff - a valid word
+    0xd800 .. 0xdbff - low surrogate
+    0xdc00 .. 0xdfff - high surrogate
+
+    Other constraints we have to consider:
+    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
+    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
+    - there must not be sole low surrogate nor high surrogate
 
+    We are going to build three bitmasks based on the 3rd nibble:
+    - V = valid word,
+    - L = low surrogate (0xd800 .. 0xdbff)
+    - H = high surrogate (0xdc00 .. 0xdfff)
+
+      0   1   2   3   4   5   6   7    <--- word index
+    [ V | L | H | L | H | V | V | L ]
+      1   0   0   0   0   1   1   0     - V = valid masks
+      0   1   0   1   0   0   0   1     - L = low surrogate
+      0   0   1   0   1   0   0   0     - H high surrogate
+
+
+      1   0   0   0   0   1   1   0   V = valid masks
+      0   1   0   1   0   0   0   0   a = L & (H >> 1)
+      0   0   1   0   1   0   0   0   b = a << 1
+      1   1   1   1   1   1   1   0   c = V | a | b
+                                  ^
+                                  the last bit can be zero, we just consume 7
+   code units and recheck this word in the next iteration
+*/
+template <endianness big_endian>
+const result validate_utf16_with_errors(const char16_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    return result(error_code::SUCCESS, 0);
+  }
+
+  const char16_t *start = input;
+  const char16_t *end = input + size;
+
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+
+  while (input + simd16<uint16_t>::SIZE * 2 < end) {
+    // 0. Load data: since the validation takes into account only higher
+    //    byte of each word, we compress the two vectors into one which
+    //    consists only the higher bytes.
+    auto in0 = simd16<uint16_t>(input);
+    auto in1 =
+        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
+
+    // Function `utf16_gather_high_bytes` consumes two vectors of UTF-16
+    // and yields a single vector having only higher bytes of characters.
+    const auto in = utf16_gather_high_bytes<big_endian>(in0, in1);
+
+    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
+    const auto surrogates_wordmask = (in & v_f8) == v_d8;
+    const uint16_t surrogates_bitmask =
+        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
+    if (surrogates_bitmask == 0x0000) {
+      input += 16;
+    } else {
+      // 2. We have some surrogates that have to be distinguished:
+      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
+      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
+      //
+      //    Fact: high surrogate has 11th bit set (3rd bit in the higher byte)
+
+      // V - non-surrogate code units
+      //     V = not surrogates_wordmask
+      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
+
+      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
+      const auto vH = (in & v_fc) == v_dc;
+      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
+
+      // L - word mask for low surrogates
+      //     L = not H and surrogates_wordmask
+      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
+
+      const uint16_t a = static_cast<uint16_t>(
+          L & (H >> 1)); // A low surrogate must be followed by high one.
+                         // (A low surrogate placed in the 7th register's word
+                         // is an exception we handle.)
+      const uint16_t b = static_cast<uint16_t>(
+          a << 1); // Just mark that the opinput - startite fact is hold,
+                   // thanks to that we have only two masks for valid case.
+      const uint16_t c = static_cast<uint16_t>(
+          V | a | b); // Combine all the masks into the final one.
+
+      if (c == 0xffff) {
+        // The whole input register contains valid UTF-16, i.e.,
+        // either single code units or proper surrogate pairs.
+        input += 16;
+      } else if (c == 0x7fff) {
+        // The 15 lower code units of the input register contains valid UTF-16.
+        // The 15th word may be either a low or high surrogate. It the next
+        // iteration we 1) check if the low surrogate is followed by a high
+        // one, 2) reject sole high surrogate.
+        input += 15;
+      } else {
+        return result(error_code::SURROGATE, input - start);
+      }
+    }
+  }
+
+  return result(error_code::SUCCESS, input - start);
+}
+
+} // namespace utf16
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+/* end file src/generic/validate_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+/* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42736,6 +44766,9 @@ struct validating_transcoder {
         uint64_t utf8_continuation_mask =
             input.lt(-65 + 1); // -64 is 1100 0000 in twos complement. Note: in
                                // this case, we also have ASCII to account for.
+        if (utf8_continuation_mask & 1) {
+          return 0; // error
+        }
         uint64_t utf8_leading_mask = ~utf8_continuation_mask;
         uint64_t utf8_end_of_code_point_mask = utf8_leading_mask >> 1;
         // We process in blocks of up to 12 bytes except possibly
@@ -42893,7 +44926,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 /* begin file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
 namespace simdutf {
 namespace westmere {
 namespace {
@@ -42973,6 +45005,111 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 } // namespace simdutf
   // namespace simdutf
 /* end file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf32.h */
+namespace simdutf {
+namespace westmere {
+namespace {
+namespace utf32 {
+
+simdutf_really_inline bool validate(const char32_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    // empty input is valid UTF-32. protect the implementation from
+    // handling nullptr
+    return true;
+  }
+
+  const char32_t *end = input + size;
+
+  using vector_u32 = simd32<uint32_t>;
+
+  const auto standardmax = vector_u32::splat(0x10ffff);
+  const auto offset = vector_u32::splat(0xffff2000);
+  const auto standardoffsetmax = vector_u32::splat(0xfffff7ff);
+  auto currentmax = vector_u32::zero();
+  auto currentoffsetmax = vector_u32::zero();
+
+  constexpr size_t N = vector_u32::ELEMENTS;
+
+  while (input + N < end) {
+    auto in = vector_u32(input);
+    if (!match_system(endianness::BIG)) {
+      in.swap_bytes();
+    }
+
+    currentmax = max(currentmax, in);
+    currentoffsetmax = max(currentoffsetmax, in + offset);
+    input += N;
+  }
+
+  const auto too_large = currentmax > standardmax;
+  if (too_large.any()) {
+    return false;
+  }
+
+  const auto surrogate = currentoffsetmax > standardoffsetmax;
+  if (surrogate.any()) {
+    return false;
+  }
+
+  return scalar::utf32::validate(input, end - input);
+}
+
+simdutf_really_inline result validate_with_errors(const char32_t *input,
+                                                  size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    // empty input is valid UTF-32. protect the implementation from
+    // handling nullptr
+    return result(error_code::SUCCESS, 0);
+  }
+
+  const char32_t *start = input;
+  const char32_t *end = input + size;
+
+  using vector_u32 = simd32<uint32_t>;
+
+  const auto standardmax = vector_u32::splat(0x10ffff);
+  const auto offset = vector_u32::splat(0xffff2000);
+  const auto standardoffsetmax = vector_u32::splat(0xfffff7ff);
+
+  constexpr size_t N = vector_u32::ELEMENTS;
+
+  while (input + N < end) {
+    auto in = vector_u32(input);
+    if (!match_system(endianness::BIG)) {
+      in.swap_bytes();
+    }
+
+    const auto too_large = in > standardmax;
+    const auto surrogate = (in + offset) > standardoffsetmax;
+
+    const auto combined = too_large | surrogate;
+    if (simdutf_unlikely(combined.any())) {
+      const size_t consumed = input - start;
+      auto sr = scalar::utf32::validate_with_errors(input, end - input);
+      sr.count += consumed;
+
+      return sr;
+    }
+
+    input += N;
+  }
+
+  const size_t consumed = input - start;
+  auto sr = scalar::utf32::validate_with_errors(input, end - input);
+  sr.count += consumed;
+
+  return sr;
+}
+
+} // namespace utf32
+} // unnamed namespace
+} // namespace westmere
+} // namespace simdutf
+/* end file src/generic/validate_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
 //
 // Implementation-specific overrides
@@ -42981,54 +45118,179 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 namespace simdutf {
 namespace westmere {
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
   // If there is a BOM, then we trust it.
   auto bom_encoding = simdutf::BOM::check_bom(input, length);
-  // todo: reimplement as a one-pass algorithm.
   if (bom_encoding != encoding_type::unspecified) {
     return bom_encoding;
   }
+
   int out = 0;
-  if (validate_utf8(input, length)) {
+  uint32_t utf16_err = (length % 2);
+  uint32_t utf32_err = (length % 4);
+  uint32_t ends_with_high = 0;
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+  const __m128i standardmax = _mm_set1_epi32(0x10ffff);
+  const __m128i offset = _mm_set1_epi32(0xffff2000);
+  const __m128i standardoffsetmax = _mm_set1_epi32(0xfffff7ff);
+  __m128i currentmax = _mm_setzero_si128();
+  __m128i currentoffsetmax = _mm_setzero_si128();
+
+  utf8_checker c{};
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
+  while (reader.has_full_block()) {
+    simd::simd8x64<uint8_t> in(reader.full_block());
+    // utf8 checks
+    c.check_next_input(in);
+
+    // utf16le checks
+    auto in0 = simd16<uint16_t>(in.chunks[0]);
+    auto in1 = simd16<uint16_t>(in.chunks[1]);
+    const auto t0 = in0.shr<8>();
+    const auto t1 = in1.shr<8>();
+    const auto packed1 = simd16<uint16_t>::pack(t0, t1);
+    auto in2 = simd16<uint16_t>(in.chunks[2]);
+    auto in3 = simd16<uint16_t>(in.chunks[3]);
+    const auto t2 = in2.shr<8>();
+    const auto t3 = in3.shr<8>();
+    const auto packed2 = simd16<uint16_t>::pack(t2, t3);
+
+    const auto surrogates_wordmask_lo = (packed1 & v_f8) == v_d8;
+    const auto surrogates_wordmask_hi = (packed2 & v_f8) == v_d8;
+    const uint32_t surrogates_bitmask =
+        (surrogates_wordmask_hi.to_bitmask() << 16) |
+        surrogates_wordmask_lo.to_bitmask();
+    const auto vL_lo = (packed1 & v_fc) == v_dc;
+    const auto vL_hi = (packed2 & v_fc) == v_dc;
+    const uint32_t L = (vL_hi.to_bitmask() << 16) | vL_lo.to_bitmask();
+    const uint32_t H = L ^ surrogates_bitmask;
+    utf16_err |= (((H << 1) | ends_with_high) != L);
+    ends_with_high = (H & 0x80000000) != 0;
+
+    // utf32le checks
+    currentmax = _mm_max_epu32(in.chunks[0], currentmax);
+    currentoffsetmax =
+        _mm_max_epu32(_mm_add_epi32(in.chunks[0], offset), currentoffsetmax);
+    currentmax = _mm_max_epu32(in.chunks[1], currentmax);
+    currentoffsetmax =
+        _mm_max_epu32(_mm_add_epi32(in.chunks[1], offset), currentoffsetmax);
+    currentmax = _mm_max_epu32(in.chunks[2], currentmax);
+    currentoffsetmax =
+        _mm_max_epu32(_mm_add_epi32(in.chunks[2], offset), currentoffsetmax);
+    currentmax = _mm_max_epu32(in.chunks[3], currentmax);
+    currentoffsetmax =
+        _mm_max_epu32(_mm_add_epi32(in.chunks[3], offset), currentoffsetmax);
+
+    reader.advance();
+  }
+
+  uint8_t block[64]{};
+  size_t idx = reader.block_index();
+  std::memcpy(block, &input[idx], length - idx);
+  simd::simd8x64<uint8_t> in(block);
+  c.check_next_input(in);
+
+  // utf16le last block check
+  auto in0 = simd16<uint16_t>(in.chunks[0]);
+  auto in1 = simd16<uint16_t>(in.chunks[1]);
+  const auto t0 = in0.shr<8>();
+  const auto t1 = in1.shr<8>();
+  const auto packed1 = simd16<uint16_t>::pack(t0, t1);
+  auto in2 = simd16<uint16_t>(in.chunks[2]);
+  auto in3 = simd16<uint16_t>(in.chunks[3]);
+  const auto t2 = in2.shr<8>();
+  const auto t3 = in3.shr<8>();
+  const auto packed2 = simd16<uint16_t>::pack(t2, t3);
+
+  const auto surrogates_wordmask_lo = (packed1 & v_f8) == v_d8;
+  const auto surrogates_wordmask_hi = (packed2 & v_f8) == v_d8;
+  const uint32_t surrogates_bitmask =
+      (surrogates_wordmask_hi.to_bitmask() << 16) |
+      surrogates_wordmask_lo.to_bitmask();
+  const auto vL_lo = (packed1 & v_fc) == v_dc;
+  const auto vL_hi = (packed2 & v_fc) == v_dc;
+  const uint32_t L = (vL_hi.to_bitmask() << 16) | vL_lo.to_bitmask();
+  const uint32_t H = L ^ surrogates_bitmask;
+  utf16_err |= (((H << 1) | ends_with_high) != L);
+  // this is required to check for last byte ending in high and end of input
+  // is reached
+  ends_with_high = (H & 0x80000000) != 0;
+  utf16_err |= ends_with_high;
+
+  // utf32le last block check
+  currentmax = _mm_max_epu32(in.chunks[0], currentmax);
+  currentoffsetmax =
+      _mm_max_epu32(_mm_add_epi32(in.chunks[0], offset), currentoffsetmax);
+  currentmax = _mm_max_epu32(in.chunks[1], currentmax);
+  currentoffsetmax =
+      _mm_max_epu32(_mm_add_epi32(in.chunks[1], offset), currentoffsetmax);
+  currentmax = _mm_max_epu32(in.chunks[2], currentmax);
+  currentoffsetmax =
+      _mm_max_epu32(_mm_add_epi32(in.chunks[2], offset), currentoffsetmax);
+  currentmax = _mm_max_epu32(in.chunks[3], currentmax);
+  currentoffsetmax =
+      _mm_max_epu32(_mm_add_epi32(in.chunks[3], offset), currentoffsetmax);
+
+  reader.advance();
+
+  c.check_eof();
+  bool is_valid_utf8 = !c.errors();
+  __m128i is_zero =
+      _mm_xor_si128(_mm_max_epu32(currentmax, standardmax), standardmax);
+  utf32_err |= (_mm_test_all_zeros(is_zero, is_zero) == 0);
+
+  is_zero = _mm_xor_si128(_mm_max_epu32(currentoffsetmax, standardoffsetmax),
+                          standardoffsetmax);
+  utf32_err |= (_mm_test_all_zeros(is_zero, is_zero) == 0);
+  if (is_valid_utf8) {
     out |= encoding_type::UTF8;
   }
-  if ((length % 2) == 0) {
-    if (validate_utf16le(reinterpret_cast<const char16_t *>(input),
-                         length / 2)) {
-      out |= encoding_type::UTF16_LE;
-    }
+  if (utf16_err == 0) {
+    out |= encoding_type::UTF16_LE;
   }
-  if ((length % 4) == 0) {
-    if (validate_utf32(reinterpret_cast<const char32_t *>(input), length / 4)) {
-      out |= encoding_type::UTF32_LE;
-    }
+  if (utf32_err == 0) {
+    out |= encoding_type::UTF32_LE;
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return westmere::utf8_validation::generic_validate_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return westmere::utf8_validation::generic_validate_utf8_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
-  return westmere::utf8_validation::generic_validate_ascii(buf, len);
+  return westmere::ascii_validation::generic_validate_ascii(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
-  return westmere::utf8_validation::generic_validate_ascii_with_errors(buf,
-                                                                       len);
+  return westmere::ascii_validation::generic_validate_ascii_with_errors(buf,
+                                                                        len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -43037,15 +45299,21 @@ implementation::validate_utf16le(const char16_t *buf,
     // handling nullptr
     return true;
   }
-  const char16_t *tail = sse_validate_utf16<endianness::LITTLE>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::LITTLE>(tail,
-                                                       len - (tail - buf));
-  } else {
+  const auto res =
+      westmere::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count == len)
+    return true;
+
+  return scalar::utf16::validate<endianness::LITTLE>(buf + res.count,
+                                                     len - res.count);
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -43054,20 +45322,27 @@ implementation::validate_utf16be(const char16_t *buf,
     // handling nullptr
     return true;
   }
-  const char16_t *tail = sse_validate_utf16<endianness::BIG>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::BIG>(tail, len - (tail - buf));
-  } else {
+  const auto res =
+      westmere::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count == len)
+    return true;
+
+  return scalar::utf16::validate<endianness::BIG>(buf + res.count,
+                                                  len - res.count);
 }
 
 simdutf_warn_unused result implementation::validate_utf16le_with_errors(
     const char16_t *buf, size_t len) const noexcept {
-  result res = sse_validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  const result res =
+      westmere::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::LITTLE>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::LITTLE>(
+            buf + res.count, len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
@@ -43076,7 +45351,8 @@ simdutf_warn_unused result implementation::validate_utf16le_with_errors(
 
 simdutf_warn_unused result implementation::validate_utf16be_with_errors(
     const char16_t *buf, size_t len) const noexcept {
-  result res = sse_validate_utf16_with_errors<endianness::BIG>(buf, len);
+  const result res =
+      westmere::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
   if (res.count != len) {
     result scalar_res = scalar::utf16::validate_with_errors<endianness::BIG>(
         buf + res.count, len - res.count);
@@ -43085,39 +45361,23 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
-  if (simdutf_unlikely(len == 0)) {
-    // empty input is valid UTF-32. protect the implementation from
-    // handling nullptr
-    return true;
-  }
-  const char32_t *tail = sse_validate_utf32le(buf, len);
-  if (tail) {
-    return scalar::utf32::validate(tail, len - (tail - buf));
-  } else {
-    return false;
-  }
+  return utf32::validate(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
-  if (len == 0) {
-    // empty input is valid UTF-32. protect the implementation from
-    // handling nullptr
-    return result(error_code::SUCCESS, 0);
-  }
-  result res = sse_validate_utf32le_with_errors(buf, len);
-  if (res.count != len) {
-    result scalar_res =
-        scalar::utf32::validate_with_errors(buf + res.count, len - res.count);
-    return result(scalar_res.error, res.count + scalar_res.count);
-  } else {
-    return res;
-  }
+  return utf32::validate_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
 
@@ -43133,7 +45393,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
 
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char *, char16_t *> ret =
@@ -43173,7 +45435,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char *, char32_t *> ret =
@@ -43192,7 +45456,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   utf8_to_latin1::validating_transcoder converter;
@@ -43209,7 +45475,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return westmere::utf8_to_latin1::convert_valid(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
@@ -43246,7 +45514,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return utf8_to_utf16::convert_valid<endianness::BIG>(input, size,
                                                        utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   utf8_to_utf32::validating_transcoder converter;
@@ -43263,7 +45533,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -43371,7 +45643,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: we could provide an optimized function.
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -43477,7 +45751,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -43526,7 +45802,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
   // optimization opportunity: we could provide an optimized function.
   return convert_utf32_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -43567,7 +45845,9 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
       utf8_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char16_t *, char32_t *> ret =
@@ -43663,12 +45943,16 @@ simdutf_warn_unused result implementation::convert_utf16be_to_utf32_with_errors(
       utf32_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -43776,7 +46060,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   return convert_utf16be_to_utf32(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -43792,27 +46078,23 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return scalar::utf16::latin1_length_from_utf16(length);
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return scalar::utf32::latin1_length_from_utf32(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::LITTLE>(input, length);
@@ -43822,17 +46104,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf16_length_from_latin1(length);
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return scalar::latin1::utf32_length_from_latin1(length);
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t len) const noexcept {
   const uint8_t *str = reinterpret_cast<const uint8_t *>(input);
@@ -43892,7 +46166,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return answer + scalar::latin1::utf8_length_from_latin1(
                       reinterpret_cast<const char *>(str + i), len - i);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::LITTLE>(input, length);
@@ -43902,48 +46178,23 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
-  const __m128i v_00000000 = _mm_setzero_si128();
-  const __m128i v_ffffff80 = _mm_set1_epi32((uint32_t)0xffffff80);
-  const __m128i v_fffff800 = _mm_set1_epi32((uint32_t)0xfffff800);
-  const __m128i v_ffff0000 = _mm_set1_epi32((uint32_t)0xffff0000);
-  size_t pos = 0;
-  size_t count = 0;
-  for (; pos + 4 <= length; pos += 4) {
-    __m128i in = _mm_loadu_si128((__m128i *)(input + pos));
-    const __m128i ascii_bytes_bytemask =
-        _mm_cmpeq_epi32(_mm_and_si128(in, v_ffffff80), v_00000000);
-    const __m128i one_two_bytes_bytemask =
-        _mm_cmpeq_epi32(_mm_and_si128(in, v_fffff800), v_00000000);
-    const __m128i two_bytes_bytemask =
-        _mm_xor_si128(one_two_bytes_bytemask, ascii_bytes_bytemask);
-    const __m128i one_two_three_bytes_bytemask =
-        _mm_cmpeq_epi32(_mm_and_si128(in, v_ffff0000), v_00000000);
-    const __m128i three_bytes_bytemask =
-        _mm_xor_si128(one_two_three_bytes_bytemask, one_two_bytes_bytemask);
-    const uint16_t ascii_bytes_bitmask =
-        static_cast<uint16_t>(_mm_movemask_epi8(ascii_bytes_bytemask));
-    const uint16_t two_bytes_bitmask =
-        static_cast<uint16_t>(_mm_movemask_epi8(two_bytes_bytemask));
-    const uint16_t three_bytes_bitmask =
-        static_cast<uint16_t>(_mm_movemask_epi8(three_bytes_bytemask));
-
-    size_t ascii_count = count_ones(ascii_bytes_bitmask) / 4;
-    size_t two_bytes_count = count_ones(two_bytes_bitmask) / 4;
-    size_t three_bytes_count = count_ones(three_bytes_bitmask) / 4;
-    count += 16 - 3 * ascii_count - 2 * two_bytes_count - three_bytes_count;
-  }
-  return count +
-         scalar::utf32::utf8_length_from_utf32(input + pos, length - pos);
+  return utf32::utf8_length_from_utf32(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const __m128i v_00000000 = _mm_setzero_si128();
@@ -43962,65 +46213,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -44032,6 +46320,8 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
     return encode_base64<false>(output, input, length, options);
   }
 }
+#endif // SIMDUTF_FEATURE_BASE64
+
 } // namespace westmere
 } // namespace simdutf
 
@@ -44059,6 +46349,7 @@ namespace {
 #endif
 using namespace simd;
 
+#if SIMDUTF_FEATURE_UTF8
 // convert vmskltz/vmskgez/vmsknz to
 // simdutf::tables::utf16_to_utf8::pack_1_2_utf8_bytes index
 const uint8_t lsx_1_2_utf8_bytes_mask[] = {
@@ -44080,33 +46371,26 @@ const uint8_t lsx_1_2_utf8_bytes_mask[] = {
     169, 172, 173, 184, 185, 188, 189, 232, 233, 236, 237, 248, 249, 252, 253,
     170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254,
     255};
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 simdutf_really_inline __m128i lsx_swap_bytes(__m128i vec) {
   // const v16u8 shuf = {1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14};
   // return __lsx_vshuf_b(__lsx_vldi(0), vec, shuf);
   return __lsx_vshuf4i_b(vec, 0b10110001);
   // return __lsx_vor_v(__lsx_vslli_h(vec, 8), __lsx_vsrli_h(vec, 8));
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    SIMDUTF_FEATURE_UTF8
 simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   return input.is_ascii();
 }
+#endif // SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // SIMDUTF_FEATURE_UTF8
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<bool> is_second_byte = prev1 >= uint8_t(0b11000000u);
-  simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
-  simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
-  // Use ^ instead of | for is_*_byte, because ^ is commutative, and the caller
-  // is using ^ as well. This will work fine because we only have to report
-  // errors for cases with 0-1 lead bytes. Multiple lead bytes implies 2
-  // overlapping multibyte characters, and if that happens, there is guaranteed
-  // to be at least *one* lead byte that is part of only 1 other multibyte
-  // character. The error will be detected there.
-  return is_second_byte ^ is_third_byte ^ is_fourth_byte;
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -44114,7 +46398,9 @@ must_be_2_3_continuation(const simd8<uint8_t> prev2,
   simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
   return is_third_byte ^ is_fourth_byte;
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32)
 // common functions for utf8 conversions
 simdutf_really_inline __m128i convert_utf8_3_byte_to_utf16(__m128i in) {
   // Low half contains  10bbbbbb|10cccccc
@@ -44172,210 +46458,27 @@ convert_utf8_1_to_2_byte_to_utf16(__m128i in, size_t shufutf8_idx) {
   composed = __lsx_vadd_h(ascii, composed);
   return composed;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32)
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/lsx/lsx_validate_utf16.cpp */
-/*
-    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
-
-    In a vectorized algorithm we want to examine the most significant
-    nibble in order to select a fast path. If none of highest nibbles
-    are 0xD (13), than we are sure that UTF-16 chunk in a vector
-    register is valid.
-
-    Let us analyze what we need to check if the nibble is 0xD. The
-    value of the preceding nibble determines what we have:
-
-    0xd000 .. 0xd7ff - a valid word
-    0xd800 .. 0xdbff - low surrogate
-    0xdc00 .. 0xdfff - high surrogate
-
-    Other constraints we have to consider:
-    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
-    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
-    - there must not be sole low surrogate nor high surrogate
-
-    We're going to build three bitmasks based on the 3rd nibble:
-    - V = valid word,
-    - L = low surrogate (0xd800 .. 0xdbff)
-    - H = high surrogate (0xdc00 .. 0xdfff)
-
-      0   1   2   3   4   5   6   7    <--- word index
-    [ V | L | H | L | H | V | V | L ]
-      1   0   0   0   0   1   1   0     - V = valid masks
-      0   1   0   1   0   0   0   1     - L = low surrogate
-      0   0   1   0   1   0   0   0     - H high surrogate
-
-
-      1   0   0   0   0   1   1   0   V = valid masks
-      0   1   0   1   0   0   0   0   a = L & (H >> 1)
-      0   0   1   0   1   0   0   0   b = a << 1
-      1   1   1   1   1   1   1   0   c = V | a | b
-                                  ^
-                                  the last bit can be zero, we just consume 7
-   code units and recheck this word in the next iteration
-*/
-
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
 template <endianness big_endian>
-const char16_t *lsx_validate_utf16(const char16_t *input, size_t size) {
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::SIZE * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 =
-        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-    const auto in = simd8<uint8_t>(__lsx_vssrlni_bu_h(in1.value, in0.value, 8));
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint16_t surrogates_bitmask =
-        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
-    if (surrogates_bitmask == 0x0000) {
-      input += 16;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
-
-      const uint16_t a = static_cast<uint16_t>(
-          L & (H >> 1)); // A low surrogate must be followed by high one.
-                         // (A low surrogate placed in the 7th register's word
-                         // is an exception we handle.)
-      const uint16_t b = static_cast<uint16_t>(
-          a << 1); // Just mark that the opinput - startite fact is hold,
-                   // thanks to that we have only two masks for valid case.
-      const uint16_t c = static_cast<uint16_t>(
-          V | a | b); // Combine all the masks into the final one.
-
-      if (c == 0xffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += 16;
-      } else if (c == 0x7fff) {
-        // The 15 lower code units of the input register contains valid UTF-16.
-        // The 15th word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += 15;
-      } else {
-        return nullptr;
-      }
-    }
-  }
-
-  return input;
-}
-
-template <endianness big_endian>
-const result lsx_validate_utf16_with_errors(const char16_t *input,
-                                            size_t size) {
-  const char16_t *start = input;
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::SIZE * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 =
-        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-
-    const auto in = simd8<uint8_t>(__lsx_vssrlni_bu_h(in1.value, in0.value, 8));
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint16_t surrogates_bitmask =
-        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
-    if (surrogates_bitmask == 0x0000) {
-      input += 16;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
-
-      const uint16_t a = static_cast<uint16_t>(
-          L & (H >> 1)); // A low surrogate must be followed by high one.
-                         // (A low surrogate placed in the 7th register's word
-                         // is an exception we handle.)
-      const uint16_t b = static_cast<uint16_t>(
-          a << 1); // Just mark that the opinput - startite fact is hold,
-                   // thanks to that we have only two masks for valid case.
-      const uint16_t c = static_cast<uint16_t>(
-          V | a | b); // Combine all the masks into the final one.
+simd8<uint8_t> utf16_gather_high_bytes(const simd16<uint16_t> in0,
+                                       const simd16<uint16_t> in1) {
+  if (big_endian) {
+    const auto mask = simd16<uint16_t>(0x00ff);
+    const auto t0 = in0 & mask;
+    const auto t1 = in1 & mask;
 
-      if (c == 0xffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += 16;
-      } else if (c == 0x7fff) {
-        // The 15 lower code units of the input register contains valid UTF-16.
-        // The 15th word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += 15;
-      } else {
-        return result(error_code::SURROGATE, input - start);
-      }
-    }
+    return simd16<uint16_t>::pack(t0, t1);
+  } else {
+    return simd8<uint8_t>(__lsx_vssrlni_bu_h(in1.value, in0.value, 8));
   }
-
-  return result(error_code::SUCCESS, input - start);
 }
 /* end file src/lsx/lsx_validate_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/lsx/lsx_validate_utf32le.cpp */
 
 const char32_t *lsx_validate_utf32le(const char32_t *input, size_t size) {
@@ -44447,7 +46550,9 @@ const result lsx_validate_utf32le_with_errors(const char32_t *input,
   return result(error_code::SUCCESS, input - start);
 }
 /* end file src/lsx/lsx_validate_utf32le.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_latin1_to_utf8.cpp */
 /*
   Returns a pair: the first unprocessed byte from buf and utf8_output
@@ -44463,7 +46568,7 @@ lsx_convert_latin1_to_utf8(const char *latin1_input, size_t len,
   __m128i zero = __lsx_vldi(0);
   // We always write 16 bytes, of which more than the first 8 bytes
   // are valid. A safety margin of 8 is more than sufficient.
-  while (latin1_input + 16 <= end) {
+  while (end - latin1_input >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(latin1_input), 0);
     uint32_t ascii = __lsx_vpickve2gr_hu(__lsx_vmskgez_b(in8), 0);
     if (ascii == 0xffff) { // ASCII fast path!!!!
@@ -44506,6 +46611,8 @@ lsx_convert_latin1_to_utf8(const char *latin1_input, size_t len,
   return std::make_pair(latin1_input, reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lsx/lsx_convert_latin1_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_latin1_to_utf16.cpp */
 std::pair<const char *, char16_t *>
 lsx_convert_latin1_to_utf16le(const char *buf, size_t len,
@@ -44513,7 +46620,7 @@ lsx_convert_latin1_to_utf16le(const char *buf, size_t len,
   const char *end = buf + len;
 
   __m128i zero = __lsx_vldi(0);
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m128i inlow = __lsx_vilvl_b(zero, in8);
@@ -44533,7 +46640,7 @@ lsx_convert_latin1_to_utf16be(const char *buf, size_t len,
                               char16_t *utf16_output) {
   const char *end = buf + len;
   __m128i zero = __lsx_vldi(0);
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m128i inlow = __lsx_vilvl_b(in8, zero);
@@ -44547,13 +46654,15 @@ lsx_convert_latin1_to_utf16be(const char *buf, size_t len,
   return std::make_pair(buf, utf16_output);
 }
 /* end file src/lsx/lsx_convert_latin1_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_latin1_to_utf32.cpp */
 std::pair<const char *, char32_t *>
 lsx_convert_latin1_to_utf32(const char *buf, size_t len,
                             char32_t *utf32_output) {
   const char *end = buf + len;
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m128i zero = __lsx_vldi(0);
@@ -44576,7 +46685,9 @@ lsx_convert_latin1_to_utf32(const char *buf, size_t len,
   return std::make_pair(buf, utf32_output);
 }
 /* end file src/lsx/lsx_convert_latin1_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/lsx/lsx_convert_utf8_to_utf16.cpp */
 // Convert up to 16 bytes from utf8 to utf16 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -44718,6 +46829,15 @@ size_t convert_masked_utf8_to_utf16(const char *input,
       // of the extra memory access is less important than the early branch
       // overhead in shorter sequences.
 
+      __m128i expected_mask =
+          (__m128i)v16u8{0xf8, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xc0,
+                         0xf8, 0xc0, 0xc0, 0xc0, 0x0,  0x0,  0x0,  0x0};
+      __m128i expected =
+          (__m128i)v16u8{0xf0, 0x80, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80,
+                         0xf0, 0x80, 0x80, 0x80, 0x0,  0x0,  0x0,  0x0};
+      __m128i check = __lsx_vseq_b(__lsx_vand_v(in, expected_mask), expected);
+      if (__lsx_bz_b(check))
+        return 12;
       // Swap byte pairs
       // 10dddddd 10cccccc|10bbbbbb 11110aaa
       // 10cccccc 10dddddd|11110aaa 10bbbbbb
@@ -44867,6 +46987,8 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   }
 }
 /* end file src/lsx/lsx_convert_utf8_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lsx/lsx_convert_utf8_to_utf32.cpp */
 // Convert up to 12 bytes from utf8 to utf32 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -45026,8 +47148,7 @@ size_t convert_masked_utf8_to_utf32(const char *input,
     __m128i ascii = __lsx_vand_v(perm, __lsx_vrepli_w(0x7F));
     __m128i middle = __lsx_vand_v(perm, __lsx_vldi(-3777 /*0x00003f00*/));
     // 00000000 00000000 0000cccc ccdddddd
-    __m128i cd =
-        __lsx_vbitsel_v(__lsx_vsrli_w(middle, 2), ascii, __lsx_vrepli_w(0x3f));
+    __m128i cd = __lsx_vor_v(__lsx_vsrli_w(middle, 2), ascii);
 
     __m128i correction = __lsx_vand_v(perm, __lsx_vldi(-3520 /*0x00400000*/));
     __m128i corrected = __lsx_vadd_b(perm, __lsx_vsrli_w(correction, 1));
@@ -45051,6 +47172,8 @@ size_t convert_masked_utf8_to_utf32(const char *input,
   }
 }
 /* end file src/lsx/lsx_convert_utf8_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_utf8_to_latin1.cpp */
 size_t convert_masked_utf8_to_latin1(const char *input,
                                      uint64_t utf8_end_of_code_point_mask,
@@ -45128,14 +47251,16 @@ size_t convert_masked_utf8_to_latin1(const char *input,
   return consumed;
 }
 /* end file src/lsx/lsx_convert_utf8_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_utf16_to_latin1.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char *>
 lsx_convert_utf16_to_latin1(const char16_t *buf, size_t len,
                             char *latin1_output) {
   const char16_t *end = buf + len;
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 16);
     if (!match_system(big_endian)) {
@@ -45163,7 +47288,7 @@ lsx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                                         char *latin1_output) {
   const char16_t *start = buf;
   const char16_t *end = buf + len;
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 16);
     if (!match_system(big_endian)) {
@@ -45181,9 +47306,8 @@ lsx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     } else {
       // Let us do a scalar fallback.
       for (int k = 0; k < 16; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if (word <= 0xff) {
           *latin1_output++ = char(word);
         } else {
@@ -45197,6 +47321,8 @@ lsx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/lsx/lsx_convert_utf16_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF8
 /* begin file src/lsx/lsx_convert_utf16_to_utf8.cpp */
 /*
     The vectorized algorithm works on single SSE register i.e., it
@@ -45261,7 +47387,7 @@ lsx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
           // https://github.com/simdutf/simdutf/issues/92
 
   __m128i v_07ff = __lsx_vreplgr2vr_h(uint16_t(0x7ff));
-  while (buf + 16 + safety_margin <= end) {
+  while (end - buf >= std::ptrdiff_t(16 + safety_margin)) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lsx_swap_bytes(in);
@@ -45445,9 +47571,8 @@ lsx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -45461,7 +47586,7 @@ lsx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -45500,7 +47625,7 @@ lsx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
   const size_t safety_margin =
       12; // to avoid overruns, see issue
           // https://github.com/simdutf/simdutf/issues/92
-  while (buf + 16 + safety_margin <= end) {
+  while (end - buf >= std::ptrdiff_t(16 + safety_margin)) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lsx_swap_bytes(in);
@@ -45685,9 +47810,8 @@ lsx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -45701,7 +47825,7 @@ lsx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -45725,6 +47849,8 @@ lsx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lsx/lsx_convert_utf16_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF8
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lsx/lsx_convert_utf16_to_utf32.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char32_t *>
@@ -45737,7 +47863,7 @@ lsx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
   __m128i v_f800 = __lsx_vldi(-2568); /*0xF800*/
   __m128i v_d800 = __lsx_vldi(-2600); /*0xD800*/
 
-  while (buf + 8 <= end) {
+  while (end - buf >= 8) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lsx_swap_bytes(in);
@@ -45765,16 +47891,15 @@ lsx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -45811,7 +47936,7 @@ lsx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
   __m128i v_f800 = __lsx_vldi(-2568); /*0xF800*/
   __m128i v_d800 = __lsx_vldi(-2600); /*0xD800*/
 
-  while (buf + 8 <= end) {
+  while (end - buf >= 8) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lsx_swap_bytes(in);
@@ -45837,16 +47962,15 @@ lsx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -45866,7 +47990,9 @@ lsx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char32_t *>(utf32_output));
 }
 /* end file src/lsx/lsx_convert_utf16_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lsx/lsx_convert_utf32_to_latin1.cpp */
 std::pair<const char32_t *, char *>
 lsx_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -45875,7 +48001,7 @@ lsx_convert_utf32_to_latin1(const char32_t *buf, size_t len,
   const v16u8 shuf_mask = {0, 4, 8, 12, 16, 20, 24, 28, 0, 0, 0, 0, 0, 0, 0, 0};
   __m128i v_ff = __lsx_vrepli_w(0xFF);
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i in2 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
 
@@ -45904,7 +48030,7 @@ lsx_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
   const v16u8 shuf_mask = {0, 4, 8, 12, 16, 20, 24, 28, 0, 0, 0, 0, 0, 0, 0, 0};
   __m128i v_ff = __lsx_vrepli_w(0xFF);
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i in2 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
 
@@ -45935,6 +48061,8 @@ lsx_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/lsx/lsx_convert_utf32_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lsx/lsx_convert_utf32_to_utf8.cpp */
 std::pair<const char32_t *, char *>
 lsx_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_out) {
@@ -45951,7 +48079,7 @@ lsx_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_out) {
       12; // to avoid overruns, see issue
           // https://github.com/simdutf/simdutf/issues/92
 
-  while (buf + 16 + safety_margin < end) {
+  while (end - buf > std::ptrdiff_t(16 + safety_margin)) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i nextin = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
 
@@ -46180,7 +48308,7 @@ lsx_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
       12; // to avoid overruns, see issue
           // https://github.com/simdutf/simdutf/issues/92
 
-  while (buf + 16 + safety_margin < end) {
+  while (end - buf > std::ptrdiff_t(16 + safety_margin)) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i nextin = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
 
@@ -46396,6 +48524,8 @@ lsx_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lsx/lsx_convert_utf32_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lsx/lsx_convert_utf32_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
@@ -46407,7 +48537,7 @@ lsx_convert_utf32_to_utf16(const char32_t *buf, size_t len,
   __m128i forbidden_bytemask = __lsx_vrepli_h(0);
   __m128i v_d800 = __lsx_vldi(-2600); /*0xD800*/
   __m128i v_dfff = __lsx_vreplgr2vr_h(uint16_t(0xdfff));
-  while (buf + 8 <= end) {
+  while (end - buf >= 8) {
     __m128i in0 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
 
@@ -46484,7 +48614,7 @@ lsx_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
   __m128i v_d800 = __lsx_vldi(-2600); /*0xD800*/
   __m128i v_dfff = __lsx_vreplgr2vr_h(uint16_t(0xdfff));
 
-  while (buf + 8 <= end) {
+  while (end - buf >= 8) {
     __m128i in0 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint32_t *>(buf), 16);
     // Check if no bits set above 16th
@@ -46553,6 +48683,8 @@ lsx_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char16_t *>(utf16_output));
 }
 /* end file src/lsx/lsx_convert_utf32_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/lsx/lsx_base64.cpp */
 /**
  * References and further reading:
@@ -46960,7 +49092,7 @@ static inline void base64_decode_block_safe(char *out, block64 *b) {
   base64_decode_block(out, b);
 }
 
-template <bool base64_url, typename char_type>
+template <bool base64_url, bool ignore_garbage, typename char_type>
 full_result
 compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                        base64_options options,
@@ -46991,7 +49123,13 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -47012,7 +49150,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
       bool error = false;
       uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
       if (badcharmask) {
-        if (error) {
+        if (error && !ignore_garbage) {
           src -= 64;
           while (src < srcend && scalar::base64::is_eight_byte(*src) &&
                  to_base64[uint8_t(*src)] <= 64) {
@@ -47056,7 +49194,8 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     while ((bufferptr - buffer_start) % 64 != 0 && src < srcend) {
       uint8_t val = to_base64[uint8_t(*src)];
       *bufferptr = char(val);
-      if (!scalar::base64::is_eight_byte(*src) || val > 64) {
+      if ((!scalar::base64::is_eight_byte(*src) || val > 64) &&
+          !ignore_garbage) {
         return {error_code::INVALID_BASE64_CHARACTER, size_t(src - srcinit),
                 size_t(dst - dstinit)};
       }
@@ -47076,7 +49215,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 4);
 
       dst += 3;
@@ -47088,7 +49227,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 3);
 
       dst += 3;
@@ -47098,8 +49237,14 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     // backtrack
     int leftover = int(bufferptr - buffer_start);
     while (leftover > 0) {
-      while (to_base64[uint8_t(*(src - 1))] == 64) {
-        src--;
+      if (!ignore_garbage) {
+        while (to_base64[uint8_t(*(src - 1))] == 64) {
+          src--;
+        }
+      } else {
+        while (to_base64[uint8_t(*(src - 1))] >= 64) {
+          src--;
+        }
       }
       src--;
       leftover--;
@@ -47116,7 +49261,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
       r.output_count += size_t(dst - dstinit);
     }
     if (last_chunk_options != stop_before_partial &&
-        r.error == error_code::SUCCESS && equalsigns > 0) {
+        r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
       // additional checks
       if ((r.output_count % 3 == 0) ||
           ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -47126,7 +49271,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
     }
     return r;
   }
-  if (equalsigns > 0) {
+  if (equalsigns > 0 && !ignore_garbage) {
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -47135,6 +49280,7 @@ compress_decode_base64(char *dst, const char_type *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/lsx/lsx_base64.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // namespace
 } // namespace lsx
@@ -47251,6 +49397,7 @@ simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance() {
 } // namespace lsx
 } // namespace simdutf
 /* end file src/generic/buf_block_reader.h */
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
 namespace simdutf {
 namespace lsx {
@@ -47557,9 +49704,21 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+} // namespace utf8_validation
+} // unnamed namespace
+} // namespace lsx
+} // namespace simdutf
+/* end file src/generic/utf8_validation/utf8_validator.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/generic/ascii_validation.h */
+namespace simdutf {
+namespace lsx {
+namespace {
+namespace ascii_validation {
+
+bool generic_validate_ascii(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   uint8_t blocks[64]{};
   simd::simd8x64<uint8_t> running_or(blocks);
   while (reader.has_full_block()) {
@@ -47574,14 +49733,8 @@ bool generic_validate_ascii(const uint8_t *input, size_t length) {
   return running_or.is_ascii();
 }
 
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+result generic_validate_ascii_with_errors(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   size_t count{0};
   while (reader.has_full_block()) {
     simd::simd8x64<uint8_t> in(reader.full_block());
@@ -47606,20 +49759,16 @@ result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
   }
 }
 
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-} // namespace utf8_validation
+} // namespace ascii_validation
 } // unnamed namespace
 } // namespace lsx
 } // namespace simdutf
-/* end file src/generic/utf8_validation/utf8_validator.h */
+/* end file src/generic/ascii_validation.h */
+#endif // SIMDUTF_FEATURE_ASCII
 
-// transcoding from UTF-8 to Latin 1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  // transcoding from UTF-8 to Latin 1
 /* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
-
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -47778,6 +49927,9 @@ struct validating_transcoder {
         uint64_t utf8_continuation_mask =
             input.lt(-65 + 1); // -64 is 1100 0000 in twos complement. Note: in
                                // this case, we also have ASCII to account for.
+        if (utf8_continuation_mask & 1) {
+          return 0; // error
+        }
         uint64_t utf8_leading_mask = ~utf8_continuation_mask;
         uint64_t utf8_end_of_code_point_mask = utf8_leading_mask >> 1;
         // We process in blocks of up to 12 bytes except possibly
@@ -47935,7 +50087,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 /* begin file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48015,9 +50166,11 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 } // namespace simdutf
   // namespace simdutf
 /* end file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-// transcoding from UTF-8 to UTF-16
-/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  // transcoding from UTF-8 to UTF-16
+/* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48094,7 +50247,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48428,9 +50580,11 @@ struct validating_transcoder {
 } // namespace lsx
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-// transcoding from UTF-8 to UTF-32
-/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  // transcoding from UTF-8 to UTF-32
+/* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48475,7 +50629,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48795,11 +50948,10 @@ struct validating_transcoder {
 } // namespace lsx
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-
-// other functions
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/generic/utf8.h */
-
 namespace simdutf {
 namespace lsx {
 namespace {
@@ -48839,6 +50991,9 @@ simdutf_really_inline size_t utf16_length_from_utf8(const char *in,
 } // namespace lsx
 } // namespace simdutf
 /* end file src/generic/utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/generic/utf16.h */
 namespace simdutf {
 namespace lsx {
@@ -48914,6 +51069,143 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace lsx
 } // namespace simdutf
 /* end file src/generic/utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf16.h */
+namespace simdutf {
+namespace lsx {
+namespace {
+namespace utf16 {
+/*
+    UTF-16 validation
+    --------------------------------------------------
+
+    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
+
+    In a vectorized algorithm we want to examine the most significant
+    nibble in order to select a fast path. If none of highest nibbles
+    are 0xD (13), than we are sure that UTF-16 chunk in a vector
+    register is valid.
+
+    Let us analyze what we need to check if the nibble is 0xD. The
+    value of the preceding nibble determines what we have:
+
+    0xd000 .. 0xd7ff - a valid word
+    0xd800 .. 0xdbff - low surrogate
+    0xdc00 .. 0xdfff - high surrogate
+
+    Other constraints we have to consider:
+    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
+    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
+    - there must not be sole low surrogate nor high surrogate
+
+    We are going to build three bitmasks based on the 3rd nibble:
+    - V = valid word,
+    - L = low surrogate (0xd800 .. 0xdbff)
+    - H = high surrogate (0xdc00 .. 0xdfff)
+
+      0   1   2   3   4   5   6   7    <--- word index
+    [ V | L | H | L | H | V | V | L ]
+      1   0   0   0   0   1   1   0     - V = valid masks
+      0   1   0   1   0   0   0   1     - L = low surrogate
+      0   0   1   0   1   0   0   0     - H high surrogate
+
+
+      1   0   0   0   0   1   1   0   V = valid masks
+      0   1   0   1   0   0   0   0   a = L & (H >> 1)
+      0   0   1   0   1   0   0   0   b = a << 1
+      1   1   1   1   1   1   1   0   c = V | a | b
+                                  ^
+                                  the last bit can be zero, we just consume 7
+   code units and recheck this word in the next iteration
+*/
+template <endianness big_endian>
+const result validate_utf16_with_errors(const char16_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    return result(error_code::SUCCESS, 0);
+  }
+
+  const char16_t *start = input;
+  const char16_t *end = input + size;
+
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+
+  while (input + simd16<uint16_t>::SIZE * 2 < end) {
+    // 0. Load data: since the validation takes into account only higher
+    //    byte of each word, we compress the two vectors into one which
+    //    consists only the higher bytes.
+    auto in0 = simd16<uint16_t>(input);
+    auto in1 =
+        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
+
+    // Function `utf16_gather_high_bytes` consumes two vectors of UTF-16
+    // and yields a single vector having only higher bytes of characters.
+    const auto in = utf16_gather_high_bytes<big_endian>(in0, in1);
+
+    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
+    const auto surrogates_wordmask = (in & v_f8) == v_d8;
+    const uint16_t surrogates_bitmask =
+        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
+    if (surrogates_bitmask == 0x0000) {
+      input += 16;
+    } else {
+      // 2. We have some surrogates that have to be distinguished:
+      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
+      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
+      //
+      //    Fact: high surrogate has 11th bit set (3rd bit in the higher byte)
+
+      // V - non-surrogate code units
+      //     V = not surrogates_wordmask
+      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
+
+      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
+      const auto vH = (in & v_fc) == v_dc;
+      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
+
+      // L - word mask for low surrogates
+      //     L = not H and surrogates_wordmask
+      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
+
+      const uint16_t a = static_cast<uint16_t>(
+          L & (H >> 1)); // A low surrogate must be followed by high one.
+                         // (A low surrogate placed in the 7th register's word
+                         // is an exception we handle.)
+      const uint16_t b = static_cast<uint16_t>(
+          a << 1); // Just mark that the opinput - startite fact is hold,
+                   // thanks to that we have only two masks for valid case.
+      const uint16_t c = static_cast<uint16_t>(
+          V | a | b); // Combine all the masks into the final one.
+
+      if (c == 0xffff) {
+        // The whole input register contains valid UTF-16, i.e.,
+        // either single code units or proper surrogate pairs.
+        input += 16;
+      } else if (c == 0x7fff) {
+        // The 15 lower code units of the input register contains valid UTF-16.
+        // The 15th word may be either a low or high surrogate. It the next
+        // iteration we 1) check if the low surrogate is followed by a high
+        // one, 2) reject sole high surrogate.
+        input += 15;
+      } else {
+        return result(error_code::SURROGATE, input - start);
+      }
+    }
+  }
+
+  return result(error_code::SUCCESS, input - start);
+}
+
+} // namespace utf16
+} // unnamed namespace
+} // namespace lsx
+} // namespace simdutf
+/* end file src/generic/validate_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
 //
 // Implementation-specific overrides
@@ -48921,6 +51213,7 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 namespace simdutf {
 namespace lsx {
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -48947,27 +51240,35 @@ implementation::detect_encodings(const char *input,
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return lsx::utf8_validation::generic_validate_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return lsx::utf8_validation::generic_validate_utf8_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
-  return lsx::utf8_validation::generic_validate_ascii(buf, len);
+  return lsx::ascii_validation::generic_validate_ascii(buf, len);
 }
 
 simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
-  return lsx::utf8_validation::generic_validate_ascii_with_errors(buf, len);
+  return lsx::ascii_validation::generic_validate_ascii_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -48975,15 +51276,23 @@ implementation::validate_utf16le(const char16_t *buf,
     // empty input is valid. protected the implementation from nullptr.
     return true;
   }
-  const char16_t *tail = lsx_validate_utf16<endianness::LITTLE>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::LITTLE>(tail,
-                                                       len - (tail - buf));
-  } else {
+  const auto res =
+      lsx::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count != len) {
+    return scalar::utf16::validate<endianness::LITTLE>(buf + res.count,
+                                                       len - res.count);
+  }
+
+  return true;
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -48991,12 +51300,19 @@ implementation::validate_utf16be(const char16_t *buf,
     // empty input is valid. protected the implementation from nullptr.
     return true;
   }
-  const char16_t *tail = lsx_validate_utf16<endianness::BIG>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::BIG>(tail, len - (tail - buf));
-  } else {
+  const auto res =
+      lsx::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
+
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count != len) {
+    return scalar::utf16::validate<endianness::BIG>(buf + res.count,
+                                                    len - res.count);
+  }
+
+  return true;
 }
 
 simdutf_warn_unused result implementation::validate_utf16le_with_errors(
@@ -49004,10 +51320,12 @@ simdutf_warn_unused result implementation::validate_utf16le_with_errors(
   if (simdutf_unlikely(len == 0)) {
     return result(error_code::SUCCESS, 0);
   }
-  result res = lsx_validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  const result res =
+      lsx::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::LITTLE>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::LITTLE>(
+            buf + res.count, len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
@@ -49019,16 +51337,20 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
   if (simdutf_unlikely(len == 0)) {
     return result(error_code::SUCCESS, 0);
   }
-  result res = lsx_validate_utf16_with_errors<endianness::BIG>(buf, len);
+  const result res =
+      lsx::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::BIG>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::BIG>(buf + res.count,
+                                                             len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -49042,7 +51364,9 @@ implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
     return false;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -49057,7 +51381,9 @@ simdutf_warn_unused result implementation::validate_utf32_with_errors(
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char *, char *> ret =
@@ -49071,7 +51397,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char *, char16_t *> ret =
@@ -49099,7 +51427,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char *, char32_t *> ret =
@@ -49112,7 +51442,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   utf8_to_latin1::validating_transcoder converter;
@@ -49129,7 +51461,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   return lsx::utf8_to_latin1::convert_valid(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
@@ -49166,7 +51500,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return utf8_to_utf16::convert_valid<endianness::BIG>(input, size,
                                                        utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   utf8_to_utf32::validating_transcoder converter;
@@ -49183,7 +51519,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -49291,7 +51629,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: implement a custom function.
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -49397,7 +51737,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -49444,7 +51786,9 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
       utf8_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char16_t *, char32_t *> ret =
@@ -49540,7 +51884,9 @@ simdutf_warn_unused result implementation::convert_utf16be_to_utf32_with_errors(
       utf32_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -49601,13 +51947,17 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
   }
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   // optimization opportunity: implement a custom function.
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -49716,7 +52066,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   return convert_utf16be_to_utf32(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -49732,33 +52084,29 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return length;
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return length;
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t length) const noexcept {
   const uint8_t *data = reinterpret_cast<const uint8_t *>(input);
   const uint8_t *data_end = data + length;
   uint64_t result = 0;
-  while (data + 16 < data_end) {
+  while (data_end - data > 16) {
     uint64_t two_bytes = 0;
     __m128i input_vec = __lsx_vld(data, 0);
     two_bytes =
@@ -49769,7 +52117,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return result + scalar::latin1::utf8_length_from_latin1((const char *)data,
                                                           data_end - data);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::LITTLE>(input, length);
@@ -49779,17 +52129,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return length;
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return length;
-}
-
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::LITTLE>(input, length);
@@ -49799,12 +52141,16 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const __m128i v_80 = __lsx_vrepli_w(0x80); /*0x00000080*/
@@ -49834,7 +52180,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
   return count +
          scalar::utf32::utf8_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   const __m128i v_ffff = __lsx_vldi(-2304); /*0x0000ffff*/
@@ -49850,65 +52198,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -49920,6 +52305,7 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
     return encode_base64<false>(output, input, length, options);
   }
 }
+#endif // SIMDUTF_FEATURE_BASE64
 } // namespace lsx
 } // namespace simdutf
 
@@ -49941,6 +52327,7 @@ namespace {
 #endif
 using namespace simd;
 
+#if SIMDUTF_FEATURE_UTF8
 // convert vmskltz/vmskgez/vmsknz to
 // simdutf::tables::utf16_to_utf8::pack_1_2_utf8_bytes index
 const uint8_t lasx_1_2_utf8_bytes_mask[] = {
@@ -49962,33 +52349,26 @@ const uint8_t lasx_1_2_utf8_bytes_mask[] = {
     169, 172, 173, 184, 185, 188, 189, 232, 233, 236, 237, 248, 249, 252, 253,
     170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254,
     255};
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 simdutf_really_inline __m128i lsx_swap_bytes(__m128i vec) {
   return __lsx_vshuf4i_b(vec, 0b10110001);
 }
 simdutf_really_inline __m256i lasx_swap_bytes(__m256i vec) {
   return __lasx_xvshuf4i_b(vec, 0b10110001);
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||                \
+    SIMDUTF_FEATURE_UTF8
 simdutf_really_inline bool is_ascii(const simd8x64<uint8_t> &input) {
   return input.is_ascii();
 }
+#endif // SIMDUTF_FEATURE_ASCII || SIMDUTF_FEATURE_DETECT_ENCODING ||
+       // SIMDUTF_FEATURE_UTF8
 
-simdutf_unused simdutf_really_inline simd8<bool>
-must_be_continuation(const simd8<uint8_t> prev1, const simd8<uint8_t> prev2,
-                     const simd8<uint8_t> prev3) {
-  simd8<bool> is_second_byte = prev1 >= uint8_t(0b11000000u);
-  simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
-  simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
-  // Use ^ instead of | for is_*_byte, because ^ is commutative, and the caller
-  // is using ^ as well. This will work fine because we only have to report
-  // errors for cases with 0-1 lead bytes. Multiple lead bytes implies 2
-  // overlapping multibyte characters, and if that happens, there is guaranteed
-  // to be at least *one* lead byte that is part of only 1 other multibyte
-  // character. The error will be detected there.
-  return is_second_byte ^ is_third_byte ^ is_fourth_byte;
-}
-
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_really_inline simd8<bool>
 must_be_2_3_continuation(const simd8<uint8_t> prev2,
                          const simd8<uint8_t> prev3) {
@@ -49996,7 +52376,9 @@ must_be_2_3_continuation(const simd8<uint8_t> prev2,
   simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
   return is_third_byte ^ is_fourth_byte;
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_UTF32)
 // common functions for utf8 conversions
 simdutf_really_inline __m128i convert_utf8_3_byte_to_utf16(__m128i in) {
   // Low half contains  10bbbbbb|10cccccc
@@ -50054,210 +52436,27 @@ convert_utf8_1_to_2_byte_to_utf16(__m128i in, size_t shufutf8_idx) {
   composed = __lsx_vadd_h(ascii, composed);
   return composed;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && (SIMDUTF_FEATURE_UTF16 ||
+       // SIMDUTF_FEATURE_UTF32)
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/lasx/lasx_validate_utf16.cpp */
-/*
-    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
-
-    In a vectorized algorithm we want to examine the most significant
-    nibble in order to select a fast path. If none of highest nibbles
-    are 0xD (13), than we are sure that UTF-16 chunk in a vector
-    register is valid.
-
-    Let us analyze what we need to check if the nibble is 0xD. The
-    value of the preceding nibble determines what we have:
-
-    0xd000 .. 0xd7ff - a valid word
-    0xd800 .. 0xdbff - low surrogate
-    0xdc00 .. 0xdfff - high surrogate
-
-    Other constraints we have to consider:
-    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
-    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
-    - there must not be sole low surrogate nor high surrogate
-
-    We're going to build three bitmasks based on the 3rd nibble:
-    - V = valid word,
-    - L = low surrogate (0xd800 .. 0xdbff)
-    - H = high surrogate (0xdc00 .. 0xdfff)
-
-      0   1   2   3   4   5   6   7    <--- word index
-    [ V | L | H | L | H | V | V | L ]
-      1   0   0   0   0   1   1   0     - V = valid masks
-      0   1   0   1   0   0   0   1     - L = low surrogate
-      0   0   1   0   1   0   0   0     - H high surrogate
-
-
-      1   0   0   0   0   1   1   0   V = valid masks
-      0   1   0   1   0   0   0   0   a = L & (H >> 1)
-      0   0   1   0   1   0   0   0   b = a << 1
-      1   1   1   1   1   1   1   0   c = V | a | b
-                                  ^
-                                  the last bit can be zero, we just consume 7
-   code units and recheck this word in the next iteration
-*/
-
-/* Returns:
-   - pointer to the last unprocessed character (a scalar fallback should check
-   the rest);
-   - nullptr if an error was detected.
-*/
 template <endianness big_endian>
-const char16_t *lasx_validate_utf16(const char16_t *input, size_t size) {
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::ELEMENTS * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 = simd16<uint16_t>(input + simd16<uint16_t>::ELEMENTS);
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-
-    const auto in = simd8<uint8_t>(__lasx_xvpermi_d(
-        __lasx_xvssrlni_bu_h(in1.value, in0.value, 8), 0b11011000));
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
-    if (surrogates_bitmask == 0x0) {
-      input += simd16<uint16_t>::ELEMENTS * 2;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint32_t V = ~surrogates_bitmask;
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint32_t H = vH.to_bitmask();
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint32_t L = ~H & surrogates_bitmask;
-
-      const uint32_t a =
-          L & (H >> 1); // A low surrogate must be followed by high one.
-                        // (A low surrogate placed in the 7th register's word
-                        // is an exception we handle.)
-      const uint32_t b =
-          a << 1; // Just mark that the opposite fact is hold,
-                  // thanks to that we have only two masks for valid case.
-      const uint32_t c = V | a | b; // Combine all the masks into the final one.
-
-      if (c == 0xffffffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += simd16<uint16_t>::ELEMENTS * 2;
-      } else if (c == 0x7fffffff) {
-        // The 31 lower code units of the input register contains valid UTF-16.
-        // The 31 word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += simd16<uint16_t>::ELEMENTS * 2 - 1;
-      } else {
-        return nullptr;
-      }
-    }
-  }
-
-  return input;
-}
-
-template <endianness big_endian>
-const result lasx_validate_utf16_with_errors(const char16_t *input,
-                                             size_t size) {
-  if (simdutf_unlikely(size == 0)) {
-    return result(error_code::SUCCESS, 0);
-  }
-  const char16_t *start = input;
-  const char16_t *end = input + size;
-
-  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
-  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
-  const auto v_fc = simd8<uint8_t>::splat(0xfc);
-  const auto v_dc = simd8<uint8_t>::splat(0xdc);
-
-  while (input + simd16<uint16_t>::ELEMENTS * 2 < end) {
-    // 0. Load data: since the validation takes into account only higher
-    //    byte of each word, we compress the two vectors into one which
-    //    consists only the higher bytes.
-    auto in0 = simd16<uint16_t>(input);
-    auto in1 = simd16<uint16_t>(input + simd16<uint16_t>::ELEMENTS);
-
-    if (big_endian) {
-      in0 = in0.swap_bytes();
-      in1 = in1.swap_bytes();
-    }
-    const auto in = simd8<uint8_t>(__lasx_xvpermi_d(
-        __lasx_xvssrlni_bu_h(in1.value, in0.value, 8), 0b11011000));
-
-    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
-    const auto surrogates_wordmask = (in & v_f8) == v_d8;
-    const uint32_t surrogates_bitmask = surrogates_wordmask.to_bitmask();
-    if (surrogates_bitmask == 0x0) {
-      input += simd16<uint16_t>::ELEMENTS * 2;
-    } else {
-      // 2. We have some surrogates that have to be distinguished:
-      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
-      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
-      //
-      //    Fact: high surrogate has 11th bit set (3rd bit in the higher word)
-
-      // V - non-surrogate code units
-      //     V = not surrogates_wordmask
-      const uint32_t V = ~surrogates_bitmask;
-
-      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
-      const auto vH = (in & v_fc) == v_dc;
-      const uint32_t H = vH.to_bitmask();
-
-      // L - word mask for low surrogates
-      //     L = not H and surrogates_wordmask
-      const uint32_t L = ~H & surrogates_bitmask;
-
-      const uint32_t a =
-          L & (H >> 1); // A low surrogate must be followed by high one.
-                        // (A low surrogate placed in the 7th register's word
-                        // is an exception we handle.)
-      const uint32_t b =
-          a << 1; // Just mark that the opposite fact is hold,
-                  // thanks to that we have only two masks for valid case.
-      const uint32_t c = V | a | b; // Combine all the masks into the final one.
+simd8<uint8_t> utf16_gather_high_bytes(const simd16<uint16_t> in0,
+                                       const simd16<uint16_t> in1) {
+  if (big_endian) {
+    const auto mask = simd16<uint16_t>(0x00ff);
+    const auto t0 = in0 & mask;
+    const auto t1 = in1 & mask;
 
-      if (c == 0xffffffff) {
-        // The whole input register contains valid UTF-16, i.e.,
-        // either single code units or proper surrogate pairs.
-        input += simd16<uint16_t>::ELEMENTS * 2;
-      } else if (c == 0x7fffffff) {
-        // The 31 lower code units of the input register contains valid UTF-16.
-        // The 31 word may be either a low or high surrogate. It the next
-        // iteration we 1) check if the low surrogate is followed by a high
-        // one, 2) reject sole high surrogate.
-        input += simd16<uint16_t>::ELEMENTS * 2 - 1;
-      } else {
-        return result(error_code::SURROGATE, input - start);
-      }
-    }
+    return simd16<uint16_t>::pack(t0, t1);
+  } else {
+    return simd8<uint8_t>(__lasx_xvssrlni_bu_h(in1.value, in0.value, 8));
   }
-
-  return result(error_code::SUCCESS, input - start);
 }
 /* end file src/lasx/lasx_validate_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/lasx/lasx_validate_utf32le.cpp */
 
 const char32_t *lasx_validate_utf32le(const char32_t *input, size_t size) {
@@ -50345,7 +52544,9 @@ const result lasx_validate_utf32le_with_errors(const char32_t *input,
   return result(error_code::SUCCESS, input - start);
 }
 /* end file src/lasx/lasx_validate_utf32le.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_latin1_to_utf8.cpp */
 /*
   Returns a pair: the first unprocessed byte from buf and utf8_output
@@ -50361,7 +52562,7 @@ lasx_convert_latin1_to_utf8(const char *latin1_input, size_t len,
 
   // We always write 16 bytes, of which more than the first 8 bytes
   // are valid. A safety margin of 8 is more than sufficient.
-  while (latin1_input + 16 <= end) {
+  while (end - latin1_input >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(latin1_input), 0);
     uint32_t ascii_mask = __lsx_vpickve2gr_wu(__lsx_vmskgez_b(in8), 0);
     if (ascii_mask == 0xFFFF) {
@@ -50413,6 +52614,8 @@ lasx_convert_latin1_to_utf8(const char *latin1_input, size_t len,
   return std::make_pair(latin1_input, reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lasx/lasx_convert_latin1_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_latin1_to_utf16.cpp */
 std::pair<const char *, char16_t *>
 lasx_convert_latin1_to_utf16le(const char *buf, size_t len,
@@ -50425,7 +52628,7 @@ lasx_convert_latin1_to_utf16le(const char *buf, size_t len,
     buf++;
   }
 
-  while (buf + 32 <= end) {
+  while (end - buf >= 32) {
     __m256i in8 = __lasx_xvld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m256i inlow = __lasx_vext2xv_hu_bu(in8);
@@ -50491,6 +52694,8 @@ lasx_convert_latin1_to_utf16be(const char *buf, size_t len,
   return std::make_pair(buf, utf16_output);
 }
 /* end file src/lasx/lasx_convert_latin1_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_latin1_to_utf32.cpp */
 std::pair<const char *, char32_t *>
 lasx_convert_latin1_to_utf32(const char *buf, size_t len,
@@ -50503,7 +52708,7 @@ lasx_convert_latin1_to_utf32(const char *buf, size_t len,
     buf++;
   }
 
-  while (buf + 32 <= end) {
+  while (end - buf >= 32) {
     __m256i in8 = __lasx_xvld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m256i in32_0 = __lasx_vext2xv_wu_bu(in8);
@@ -50525,7 +52730,7 @@ lasx_convert_latin1_to_utf32(const char *buf, size_t len,
     buf += 32;
   }
 
-  if (buf + 16 <= end) {
+  if (end - buf >= 16) {
     __m128i in8 = __lsx_vld(reinterpret_cast<const uint8_t *>(buf), 0);
 
     __m128i zero = __lsx_vldi(0);
@@ -50548,7 +52753,9 @@ lasx_convert_latin1_to_utf32(const char *buf, size_t len,
   return std::make_pair(buf, utf32_output);
 }
 /* end file src/lasx/lasx_convert_latin1_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/lasx/lasx_convert_utf8_to_utf16.cpp */
 // Convert up to 16 bytes from utf8 to utf16 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -50690,6 +52897,15 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   } else if (idx < 209) {
     // THREE (3) input code-code units
     if (input_utf8_end_of_code_point_mask == 0x888) {
+      __m128i expected_mask =
+          (__m128i)v16u8{0xf8, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xc0,
+                         0xf8, 0xc0, 0xc0, 0xc0, 0x0,  0x0,  0x0,  0x0};
+      __m128i expected =
+          (__m128i)v16u8{0xf0, 0x80, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80,
+                         0xf0, 0x80, 0x80, 0x80, 0x0,  0x0,  0x0,  0x0};
+      __m128i check = __lsx_vseq_b(__lsx_vand_v(in, expected_mask), expected);
+      if (__lsx_bz_b(check))
+        return 12;
       // We want to take 3 4-byte UTF-8 code units and turn them into 3 4-byte
       // UTF-16 pairs. Generating surrogate pairs is a little tricky though, but
       // it is easier when we can assume they are all pairs. This version does
@@ -50844,6 +53060,8 @@ size_t convert_masked_utf8_to_utf16(const char *input,
   }
 }
 /* end file src/lasx/lasx_convert_utf8_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lasx/lasx_convert_utf8_to_utf32.cpp */
 // Convert up to 12 bytes from utf8 to utf32 using a mask indicating the
 // end of the code points. Only the least significant 12 bits of the mask
@@ -51014,8 +53232,7 @@ size_t convert_masked_utf8_to_utf32(const char *input,
     __m128i ascii = __lsx_vand_v(perm, __lsx_vrepli_w(0x7F));
     __m128i middle = __lsx_vand_v(perm, __lsx_vldi(-3777 /*0x00003f00*/));
     // 00000000 00000000 0000cccc ccdddddd
-    __m128i cd =
-        __lsx_vbitsel_v(__lsx_vsrli_w(middle, 2), ascii, __lsx_vrepli_w(0x3f));
+    __m128i cd = __lsx_vor_v(__lsx_vsrli_w(middle, 2), ascii);
 
     __m128i correction = __lsx_vand_v(perm, __lsx_vldi(-3520 /*0x00400000*/));
     __m128i corrected = __lsx_vadd_b(perm, __lsx_vsrli_w(correction, 1));
@@ -51039,6 +53256,8 @@ size_t convert_masked_utf8_to_utf32(const char *input,
   }
 }
 /* end file src/lasx/lasx_convert_utf8_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_utf8_to_latin1.cpp */
 size_t convert_masked_utf8_to_latin1(const char *input,
                                      uint64_t utf8_end_of_code_point_mask,
@@ -51113,14 +53332,16 @@ size_t convert_masked_utf8_to_latin1(const char *input,
   return consumed;
 }
 /* end file src/lasx/lasx_convert_utf8_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_utf16_to_latin1.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char *>
 lasx_convert_utf16_to_latin1(const char16_t *buf, size_t len,
                              char *latin1_output) {
   const char16_t *end = buf + len;
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 16);
     if (!match_system(big_endian)) {
@@ -51148,7 +53369,7 @@ lasx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                                          char *latin1_output) {
   const char16_t *start = buf;
   const char16_t *end = buf + len;
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m128i in = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 0);
     __m128i in1 = __lsx_vld(reinterpret_cast<const uint16_t *>(buf), 16);
     if (!match_system(big_endian)) {
@@ -51166,9 +53387,8 @@ lasx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
     } else {
       // Let us do a scalar fallback.
       for (int k = 0; k < 16; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if (word <= 0xff) {
           *latin1_output++ = char(word);
         } else {
@@ -51182,6 +53402,8 @@ lasx_convert_utf16_to_latin1_with_errors(const char16_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/lasx/lasx_convert_utf16_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /* begin file src/lasx/lasx_convert_utf16_to_utf8.cpp */
 /*
     The vectorized algorithm works on single LASX register i.e., it
@@ -51249,7 +53471,7 @@ lasx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
   __m256i v_07ff = __lasx_xvreplgr2vr_h(uint16_t(0x7ff));
   __m256i zero = __lasx_xvldi(0);
   __m128i zero_128 = __lsx_vldi(0);
-  while (buf + 16 + safety_margin <= end) {
+  while (end - buf >= std::ptrdiff_t(16 + safety_margin)) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lasx_swap_bytes(in);
@@ -51446,9 +53668,8 @@ lasx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -51462,7 +53683,7 @@ lasx_convert_utf16_to_utf8(const char16_t *buf, size_t len, char *utf8_out) {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -51505,7 +53726,7 @@ lasx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
   __m256i v_07ff = __lasx_xvreplgr2vr_h(uint16_t(0x7ff));
   __m256i zero = __lasx_xvldi(0);
   __m128i zero_128 = __lsx_vldi(0);
-  while (buf + 16 + safety_margin <= end) {
+  while (end - buf >= std::ptrdiff_t(16 + safety_margin)) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lasx_swap_bytes(in);
@@ -51702,9 +53923,8 @@ lasx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xFF80) == 0) {
           *utf8_output++ = char(word);
         } else if ((word & 0xF800) == 0) {
@@ -51718,7 +53938,7 @@ lasx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -51742,6 +53962,8 @@ lasx_convert_utf16_to_utf8_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lasx/lasx_convert_utf16_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lasx/lasx_convert_utf16_to_utf32.cpp */
 template <endianness big_endian>
 std::pair<const char16_t *, char32_t *>
@@ -51753,7 +53975,7 @@ lasx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
   // Performance degradation when memory address is not 32-byte aligned
   while (((uint64_t)utf32_output & 0x1f) && buf < end) {
     uint16_t word =
-        !match_system(big_endian) ? scalar::utf16::swap_bytes(buf[0]) : buf[0];
+        !match_system(big_endian) ? scalar::u16_swap_bytes(buf[0]) : buf[0];
     if ((word & 0xF800) != 0xD800) {
       *utf32_output++ = char32_t(word);
       buf++;
@@ -51764,9 +53986,8 @@ lasx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
       }
       // must be a surrogate pair
       uint16_t diff = uint16_t(word - 0xD800);
-      uint16_t next_word = !match_system(big_endian)
-                               ? scalar::utf16::swap_bytes(buf[1])
-                               : buf[1];
+      uint16_t next_word =
+          !match_system(big_endian) ? scalar::u16_swap_bytes(buf[1]) : buf[1];
       uint16_t diff2 = uint16_t(next_word - 0xDC00);
       if ((diff | diff2) > 0x3FF) {
         return std::make_pair(nullptr,
@@ -51781,7 +54002,7 @@ lasx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
   __m256i v_f800 = __lasx_xvldi(-2568); /*0xF800*/
   __m256i v_d800 = __lasx_xvldi(-2600); /*0xD800*/
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lasx_swap_bytes(in);
@@ -51810,16 +54031,15 @@ lasx_convert_utf16_to_utf32(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -51855,16 +54075,15 @@ lasx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
   // Performance degradation when memory address is not 32-byte aligned
   while (((uint64_t)utf32_output & 0x1f) && buf < end) {
     uint16_t word =
-        !match_system(big_endian) ? scalar::utf16::swap_bytes(buf[0]) : buf[0];
+        !match_system(big_endian) ? scalar::u16_swap_bytes(buf[0]) : buf[0];
     if ((word & 0xF800) != 0xD800) {
       *utf32_output++ = char32_t(word);
       buf++;
     } else if (buf + 1 < end) {
       // must be a surrogate pair
       uint16_t diff = uint16_t(word - 0xD800);
-      uint16_t next_word = !match_system(big_endian)
-                               ? scalar::utf16::swap_bytes(buf[1])
-                               : buf[1];
+      uint16_t next_word =
+          !match_system(big_endian) ? scalar::u16_swap_bytes(buf[1]) : buf[1];
       uint16_t diff2 = uint16_t(next_word - 0xDC00);
       if ((diff | diff2) > 0x3FF) {
         return std::make_pair(result(error_code::SURROGATE, buf - start),
@@ -51881,7 +54100,7 @@ lasx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
 
   __m256i v_f800 = __lasx_xvldi(-2568); /*0xF800*/
   __m256i v_d800 = __lasx_xvldi(-2600); /*0xD800*/
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint16_t *>(buf), 0);
     if (!match_system(big_endian)) {
       in = lasx_swap_bytes(in);
@@ -51910,16 +54129,15 @@ lasx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
         forward = size_t(end - buf - 1);
       }
       for (; k < forward; k++) {
-        uint16_t word = !match_system(big_endian)
-                            ? scalar::utf16::swap_bytes(buf[k])
-                            : buf[k];
+        uint16_t word =
+            !match_system(big_endian) ? scalar::u16_swap_bytes(buf[k]) : buf[k];
         if ((word & 0xF800) != 0xD800) {
           *utf32_output++ = char32_t(word);
         } else {
           // must be a surrogate pair
           uint16_t diff = uint16_t(word - 0xD800);
           uint16_t next_word = !match_system(big_endian)
-                                   ? scalar::utf16::swap_bytes(buf[k + 1])
+                                   ? scalar::u16_swap_bytes(buf[k + 1])
                                    : buf[k + 1];
           k++;
           uint16_t diff2 = uint16_t(next_word - 0xDC00);
@@ -51939,7 +54157,9 @@ lasx_convert_utf16_to_utf32_with_errors(const char16_t *buf, size_t len,
                         reinterpret_cast<char32_t *>(utf32_output));
 }
 /* end file src/lasx/lasx_convert_utf16_to_utf32.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /* begin file src/lasx/lasx_convert_utf32_to_latin1.cpp */
 std::pair<const char32_t *, char *>
 lasx_convert_utf32_to_latin1(const char32_t *buf, size_t len,
@@ -51949,7 +54169,7 @@ lasx_convert_utf32_to_latin1(const char32_t *buf, size_t len,
       (__m128i)v16u8{0, 4, 8, 12, 16, 20, 24, 28, 0, 0, 0, 0, 0, 0, 0, 0});
   __m256i v_ff = __lasx_xvrepli_w(0xFF);
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in1 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i in2 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -51982,7 +54202,7 @@ lasx_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
       (__m128i)v16u8{0, 4, 8, 12, 16, 20, 24, 28, 0, 0, 0, 0, 0, 0, 0, 0});
   __m256i v_ff = __lasx_xvrepli_w(0xFF);
 
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in1 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i in2 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -52015,6 +54235,8 @@ lasx_convert_utf32_to_latin1_with_errors(const char32_t *buf, size_t len,
                         latin1_output);
 }
 /* end file src/lasx/lasx_convert_utf32_to_latin1.cpp */
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lasx/lasx_convert_utf32_to_utf8.cpp */
 std::pair<const char32_t *, char *>
 lasx_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_out) {
@@ -52060,7 +54282,7 @@ lasx_convert_utf32_to_utf8(const char32_t *buf, size_t len, char *utf8_out) {
       12; // to avoid overruns, see issue
           // https://github.com/simdutf/simdutf/issues/92
 
-  while (buf + 16 + safety_margin < end) {
+  while (end - buf > std::ptrdiff_t(16 + safety_margin)) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i nextin = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -52355,7 +54577,7 @@ lasx_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
       12; // to avoid overruns, see issue
           // https://github.com/simdutf/simdutf/issues/92
 
-  while (buf + 16 + safety_margin < end) {
+  while (end - buf > std::ptrdiff_t(16 + safety_margin)) {
     __m256i in = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i nextin = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -52606,6 +54828,8 @@ lasx_convert_utf32_to_utf8_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char *>(utf8_output));
 }
 /* end file src/lasx/lasx_convert_utf32_to_utf8.cpp */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /* begin file src/lasx/lasx_convert_utf32_to_utf16.cpp */
 template <endianness big_endian>
 std::pair<const char32_t *, char16_t *>
@@ -52649,7 +54873,7 @@ lasx_convert_utf32_to_utf16(const char32_t *buf, size_t len,
   __m256i forbidden_bytemask = __lasx_xvrepli_h(0);
   __m256i v_d800 = __lasx_xvldi(-2600); /*0xD800*/
   __m256i v_dfff = __lasx_xvreplgr2vr_h(uint16_t(0xdfff));
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in0 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i in1 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -52756,7 +54980,7 @@ lasx_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
   __m256i forbidden_bytemask = __lasx_xvrepli_h(0);
   __m256i v_d800 = __lasx_xvldi(-2600); /*0xD800*/
   __m256i v_dfff = __lasx_xvreplgr2vr_h(uint16_t(0xdfff));
-  while (buf + 16 <= end) {
+  while (end - buf >= 16) {
     __m256i in0 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 0);
     __m256i in1 = __lasx_xvld(reinterpret_cast<const uint32_t *>(buf), 32);
 
@@ -52826,6 +55050,8 @@ lasx_convert_utf32_to_utf16_with_errors(const char32_t *buf, size_t len,
                         reinterpret_cast<char16_t *>(utf16_output));
 }
 /* end file src/lasx/lasx_convert_utf32_to_utf16.cpp */
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+#if SIMDUTF_FEATURE_BASE64
 /* begin file src/lasx/lasx_base64.cpp */
 /**
  * References and further reading:
@@ -53234,7 +55460,7 @@ static inline void base64_decode_block_safe(char *out, block64 *b) {
   std::memcpy(out + 24, buffer, 24);
 }
 
-template <bool base64_url, typename chartype>
+template <bool base64_url, bool ignore_garbage, typename chartype>
 full_result
 compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                        base64_options options,
@@ -53265,7 +55491,13 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
   }
   if (srclen == 0) {
-    if (equalsigns > 0) {
+    if (!ignore_garbage && equalsigns > 0) {
+      if (last_chunk_options == last_chunk_handling_options::strict) {
+        return {BASE64_INPUT_REMAINDER, 0, 0};
+      } else if (last_chunk_options ==
+                 last_chunk_handling_options::stop_before_partial) {
+        return {SUCCESS, 0, 0};
+      }
       return {INVALID_BASE64_CHARACTER, equallocation, 0};
     }
     return {SUCCESS, 0, 0};
@@ -53289,7 +55521,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       src += 64;
       bool error = false;
       uint64_t badcharmask = to_base64_mask<base64_url>(&b, &error);
-      if (error) {
+      if (error && !ignore_garbage) {
         src -= 64;
         while (src < srcend && scalar::base64::is_eight_byte(*src) &&
                to_base64[uint8_t(*src)] <= 64) {
@@ -53341,7 +55573,8 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     while ((bufferptr - buffer_start) % 64 != 0 && src < srcend) {
       uint8_t val = to_base64[uint8_t(*src)];
       *bufferptr = char(val);
-      if (!scalar::base64::is_eight_byte(*src) || val > 64) {
+      if ((!scalar::base64::is_eight_byte(*src) || val > 64) &&
+          !ignore_garbage) {
         return {error_code::INVALID_BASE64_CHARACTER, size_t(src - srcinit),
                 size_t(dst - dstinit)};
       }
@@ -53365,7 +55598,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 4);
 
       dst += 3;
@@ -53377,7 +55610,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
                          (uint32_t(uint8_t(buffer_start[2])) << 1 * 6) +
                          (uint32_t(uint8_t(buffer_start[3])) << 0 * 6))
                         << 8;
-      triple = scalar::utf32::swap_bytes(triple);
+      triple = scalar::u32_swap_bytes(triple);
       std::memcpy(dst, &triple, 3);
 
       dst += 3;
@@ -53387,8 +55620,14 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     // backtrack
     int leftover = int(bufferptr - buffer_start);
     while (leftover > 0) {
-      while (to_base64[uint8_t(*(src - 1))] == 64) {
-        src--;
+      if (!ignore_garbage) {
+        while (to_base64[uint8_t(*(src - 1))] == 64) {
+          src--;
+        }
+      } else {
+        while (to_base64[uint8_t(*(src - 1))] >= 64) {
+          src--;
+        }
       }
       src--;
       leftover--;
@@ -53405,7 +55644,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
       r.output_count += size_t(dst - dstinit);
     }
     if (last_chunk_options != stop_before_partial &&
-        r.error == error_code::SUCCESS && equalsigns > 0) {
+        r.error == error_code::SUCCESS && equalsigns > 0 && !ignore_garbage) {
       // additional checks
       if ((r.output_count % 3 == 0) ||
           ((r.output_count % 3) + 1 + equalsigns != 4)) {
@@ -53415,7 +55654,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
     }
     return r;
   }
-  if (equalsigns > 0) {
+  if (equalsigns > 0 && !ignore_garbage) {
     if ((size_t(dst - dstinit) % 3 == 0) ||
         ((size_t(dst - dstinit) % 3) + 1 + equalsigns != 4)) {
       return {INVALID_BASE64_CHARACTER, equallocation, size_t(dst - dstinit)};
@@ -53424,6 +55663,7 @@ compress_decode_base64(char *dst, const chartype *src, size_t srclen,
   return {SUCCESS, srclen, size_t(dst - dstinit)};
 }
 /* end file src/lasx/lasx_base64.cpp */
+#endif // SIMDUTF_FEATURE_BASE64
 
 } // namespace
 } // namespace lasx
@@ -53540,6 +55780,7 @@ simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance() {
 } // namespace lasx
 } // namespace simdutf
 /* end file src/generic/buf_block_reader.h */
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
 namespace simdutf {
 namespace lasx {
@@ -53846,9 +56087,21 @@ result generic_validate_utf8_with_errors(const char *input, size_t length) {
       reinterpret_cast<const uint8_t *>(input), length);
 }
 
-template <class checker>
-bool generic_validate_ascii(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+} // namespace utf8_validation
+} // unnamed namespace
+} // namespace lasx
+} // namespace simdutf
+/* end file src/generic/utf8_validation/utf8_validator.h */
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
+#if SIMDUTF_FEATURE_ASCII
+/* begin file src/generic/ascii_validation.h */
+namespace simdutf {
+namespace lasx {
+namespace {
+namespace ascii_validation {
+
+bool generic_validate_ascii(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   uint8_t blocks[64]{};
   simd::simd8x64<uint8_t> running_or(blocks);
   while (reader.has_full_block()) {
@@ -53863,14 +56116,8 @@ bool generic_validate_ascii(const uint8_t *input, size_t length) {
   return running_or.is_ascii();
 }
 
-bool generic_validate_ascii(const char *input, size_t length) {
-  return generic_validate_ascii<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-template <class checker>
-result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
-  buf_block_reader<64> reader(input, length);
+result generic_validate_ascii_with_errors(const char *input, size_t length) {
+  buf_block_reader<64> reader(reinterpret_cast<const uint8_t *>(input), length);
   size_t count{0};
   while (reader.has_full_block()) {
     simd::simd8x64<uint8_t> in(reader.full_block());
@@ -53895,20 +56142,16 @@ result generic_validate_ascii_with_errors(const uint8_t *input, size_t length) {
   }
 }
 
-result generic_validate_ascii_with_errors(const char *input, size_t length) {
-  return generic_validate_ascii_with_errors<utf8_checker>(
-      reinterpret_cast<const uint8_t *>(input), length);
-}
-
-} // namespace utf8_validation
+} // namespace ascii_validation
 } // unnamed namespace
 } // namespace lasx
 } // namespace simdutf
-/* end file src/generic/utf8_validation/utf8_validator.h */
+/* end file src/generic/ascii_validation.h */
+#endif // SIMDUTF_FEATURE_ASCII
 
-// transcoding from UTF-8 to Latin 1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+  // transcoding from UTF-8 to Latin 1
 /* begin file src/generic/utf8_to_latin1/utf8_to_latin1.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -54067,6 +56310,9 @@ struct validating_transcoder {
         uint64_t utf8_continuation_mask =
             input.lt(-65 + 1); // -64 is 1100 0000 in twos complement. Note: in
                                // this case, we also have ASCII to account for.
+        if (utf8_continuation_mask & 1) {
+          return 0; // error
+        }
         uint64_t utf8_leading_mask = ~utf8_continuation_mask;
         uint64_t utf8_end_of_code_point_mask = utf8_leading_mask >> 1;
         // We process in blocks of up to 12 bytes except possibly
@@ -54224,7 +56470,6 @@ struct validating_transcoder {
 } // namespace simdutf
 /* end file src/generic/utf8_to_latin1/utf8_to_latin1.h */
 /* begin file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -54304,9 +56549,10 @@ simdutf_really_inline size_t convert_valid(const char *in, size_t size,
 } // namespace simdutf
   // namespace simdutf
 /* end file src/generic/utf8_to_latin1/valid_utf8_to_latin1.h */
-// transcoding from UTF-8 to UTF-16
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+  // transcoding from UTF-8 to UTF-16
 /* begin file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -54383,7 +56629,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/valid_utf8_to_utf16.h */
 /* begin file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -54717,9 +56962,10 @@ struct validating_transcoder {
 } // namespace lasx
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf16/utf8_to_utf16.h */
-// transcoding from UTF-8 to UTF-32
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
+  // transcoding from UTF-8 to UTF-32
 /* begin file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -54764,7 +57010,6 @@ simdutf_warn_unused size_t convert_valid(const char *input, size_t size,
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/valid_utf8_to_utf32.h */
 /* begin file src/generic/utf8_to_utf32/utf8_to_utf32.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -55084,11 +57329,10 @@ struct validating_transcoder {
 } // namespace lasx
 } // namespace simdutf
 /* end file src/generic/utf8_to_utf32/utf8_to_utf32.h */
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-
-// other functions
+#if SIMDUTF_FEATURE_UTF8
 /* begin file src/generic/utf8.h */
-
 namespace simdutf {
 namespace lasx {
 namespace {
@@ -55128,6 +57372,9 @@ simdutf_really_inline size_t utf16_length_from_utf8(const char *in,
 } // namespace lasx
 } // namespace simdutf
 /* end file src/generic/utf8.h */
+#endif // SIMDUTF_FEATURE_UTF8
+
+#if SIMDUTF_FEATURE_UTF16
 /* begin file src/generic/utf16.h */
 namespace simdutf {
 namespace lasx {
@@ -55203,6 +57450,143 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 } // namespace lasx
 } // namespace simdutf
 /* end file src/generic/utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16
+
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
+/* begin file src/generic/validate_utf16.h */
+namespace simdutf {
+namespace lasx {
+namespace {
+namespace utf16 {
+/*
+    UTF-16 validation
+    --------------------------------------------------
+
+    In UTF-16 code units in range 0xD800 to 0xDFFF have special meaning.
+
+    In a vectorized algorithm we want to examine the most significant
+    nibble in order to select a fast path. If none of highest nibbles
+    are 0xD (13), than we are sure that UTF-16 chunk in a vector
+    register is valid.
+
+    Let us analyze what we need to check if the nibble is 0xD. The
+    value of the preceding nibble determines what we have:
+
+    0xd000 .. 0xd7ff - a valid word
+    0xd800 .. 0xdbff - low surrogate
+    0xdc00 .. 0xdfff - high surrogate
+
+    Other constraints we have to consider:
+    - there must not be two consecutive low surrogates (0xd800 .. 0xdbff)
+    - there must not be two consecutive high surrogates (0xdc00 .. 0xdfff)
+    - there must not be sole low surrogate nor high surrogate
+
+    We are going to build three bitmasks based on the 3rd nibble:
+    - V = valid word,
+    - L = low surrogate (0xd800 .. 0xdbff)
+    - H = high surrogate (0xdc00 .. 0xdfff)
+
+      0   1   2   3   4   5   6   7    <--- word index
+    [ V | L | H | L | H | V | V | L ]
+      1   0   0   0   0   1   1   0     - V = valid masks
+      0   1   0   1   0   0   0   1     - L = low surrogate
+      0   0   1   0   1   0   0   0     - H high surrogate
+
+
+      1   0   0   0   0   1   1   0   V = valid masks
+      0   1   0   1   0   0   0   0   a = L & (H >> 1)
+      0   0   1   0   1   0   0   0   b = a << 1
+      1   1   1   1   1   1   1   0   c = V | a | b
+                                  ^
+                                  the last bit can be zero, we just consume 7
+   code units and recheck this word in the next iteration
+*/
+template <endianness big_endian>
+const result validate_utf16_with_errors(const char16_t *input, size_t size) {
+  if (simdutf_unlikely(size == 0)) {
+    return result(error_code::SUCCESS, 0);
+  }
+
+  const char16_t *start = input;
+  const char16_t *end = input + size;
+
+  const auto v_d8 = simd8<uint8_t>::splat(0xd8);
+  const auto v_f8 = simd8<uint8_t>::splat(0xf8);
+  const auto v_fc = simd8<uint8_t>::splat(0xfc);
+  const auto v_dc = simd8<uint8_t>::splat(0xdc);
+
+  while (input + simd16<uint16_t>::SIZE * 2 < end) {
+    // 0. Load data: since the validation takes into account only higher
+    //    byte of each word, we compress the two vectors into one which
+    //    consists only the higher bytes.
+    auto in0 = simd16<uint16_t>(input);
+    auto in1 =
+        simd16<uint16_t>(input + simd16<uint16_t>::SIZE / sizeof(char16_t));
+
+    // Function `utf16_gather_high_bytes` consumes two vectors of UTF-16
+    // and yields a single vector having only higher bytes of characters.
+    const auto in = utf16_gather_high_bytes<big_endian>(in0, in1);
+
+    // 1. Check whether we have any 0xD800..DFFF word (0b1101'1xxx'yyyy'yyyy).
+    const auto surrogates_wordmask = (in & v_f8) == v_d8;
+    const uint16_t surrogates_bitmask =
+        static_cast<uint16_t>(surrogates_wordmask.to_bitmask());
+    if (surrogates_bitmask == 0x0000) {
+      input += 16;
+    } else {
+      // 2. We have some surrogates that have to be distinguished:
+      //    - low  surrogates: 0b1101'10xx'yyyy'yyyy (0xD800..0xDBFF)
+      //    - high surrogates: 0b1101'11xx'yyyy'yyyy (0xDC00..0xDFFF)
+      //
+      //    Fact: high surrogate has 11th bit set (3rd bit in the higher byte)
+
+      // V - non-surrogate code units
+      //     V = not surrogates_wordmask
+      const uint16_t V = static_cast<uint16_t>(~surrogates_bitmask);
+
+      // H - word-mask for high surrogates: the six highest bits are 0b1101'11
+      const auto vH = (in & v_fc) == v_dc;
+      const uint16_t H = static_cast<uint16_t>(vH.to_bitmask());
+
+      // L - word mask for low surrogates
+      //     L = not H and surrogates_wordmask
+      const uint16_t L = static_cast<uint16_t>(~H & surrogates_bitmask);
+
+      const uint16_t a = static_cast<uint16_t>(
+          L & (H >> 1)); // A low surrogate must be followed by high one.
+                         // (A low surrogate placed in the 7th register's word
+                         // is an exception we handle.)
+      const uint16_t b = static_cast<uint16_t>(
+          a << 1); // Just mark that the opinput - startite fact is hold,
+                   // thanks to that we have only two masks for valid case.
+      const uint16_t c = static_cast<uint16_t>(
+          V | a | b); // Combine all the masks into the final one.
+
+      if (c == 0xffff) {
+        // The whole input register contains valid UTF-16, i.e.,
+        // either single code units or proper surrogate pairs.
+        input += 16;
+      } else if (c == 0x7fff) {
+        // The 15 lower code units of the input register contains valid UTF-16.
+        // The 15th word may be either a low or high surrogate. It the next
+        // iteration we 1) check if the low surrogate is followed by a high
+        // one, 2) reject sole high surrogate.
+        input += 15;
+      } else {
+        return result(error_code::SURROGATE, input - start);
+      }
+    }
+  }
+
+  return result(error_code::SUCCESS, input - start);
+}
+
+} // namespace utf16
+} // unnamed namespace
+} // namespace lasx
+} // namespace simdutf
+/* end file src/generic/validate_utf16.h */
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
 //
 // Implementation-specific overrides
@@ -55210,6 +57594,7 @@ change_endianness_utf16(const char16_t *in, size_t size, char16_t *output) {
 namespace simdutf {
 namespace lasx {
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused int
 implementation::detect_encodings(const char *input,
                                  size_t length) const noexcept {
@@ -55236,27 +57621,35 @@ implementation::detect_encodings(const char *input,
   }
   return out;
 }
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf8(const char *buf, size_t len) const noexcept {
   return lasx::utf8_validation::generic_validate_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused result implementation::validate_utf8_with_errors(
     const char *buf, size_t len) const noexcept {
   return lasx::utf8_validation::generic_validate_utf8_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 simdutf_warn_unused bool
 implementation::validate_ascii(const char *buf, size_t len) const noexcept {
-  return lasx::utf8_validation::generic_validate_ascii(buf, len);
+  return lasx::ascii_validation::generic_validate_ascii(buf, len);
 }
 
 simdutf_warn_unused result implementation::validate_ascii_with_errors(
     const char *buf, size_t len) const noexcept {
-  return lasx::utf8_validation::generic_validate_ascii_with_errors(buf, len);
+  return lasx::ascii_validation::generic_validate_ascii_with_errors(buf, len);
 }
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf16le(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -55264,15 +57657,22 @@ implementation::validate_utf16le(const char16_t *buf,
     // empty input is valid. protected the implementation from nullptr.
     return true;
   }
-  const char16_t *tail = lasx_validate_utf16<endianness::LITTLE>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::LITTLE>(tail,
-                                                       len - (tail - buf));
-  } else {
+  const auto res =
+      lasx::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count != len) {
+    return scalar::utf16::validate<endianness::LITTLE>(buf + res.count,
+                                                       len - res.count);
+  }
+
+  return true;
 }
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused bool
 implementation::validate_utf16be(const char16_t *buf,
                                  size_t len) const noexcept {
@@ -55280,12 +57680,19 @@ implementation::validate_utf16be(const char16_t *buf,
     // empty input is valid. protected the implementation from nullptr.
     return true;
   }
-  const char16_t *tail = lasx_validate_utf16<endianness::BIG>(buf, len);
-  if (tail) {
-    return scalar::utf16::validate<endianness::BIG>(tail, len - (tail - buf));
-  } else {
+
+  const auto res =
+      lasx::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
+  if (res.is_err()) {
     return false;
   }
+
+  if (res.count != len) {
+    return scalar::utf16::validate<endianness::BIG>(buf + res.count,
+                                                    len - res.count);
+  }
+
+  return true;
 }
 
 simdutf_warn_unused result implementation::validate_utf16le_with_errors(
@@ -55293,10 +57700,12 @@ simdutf_warn_unused result implementation::validate_utf16le_with_errors(
   if (simdutf_unlikely(len == 0)) {
     return result(error_code::SUCCESS, 0);
   }
-  result res = lasx_validate_utf16_with_errors<endianness::LITTLE>(buf, len);
+  const result res =
+      lasx::utf16::validate_utf16_with_errors<endianness::LITTLE>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::LITTLE>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::LITTLE>(
+            buf + res.count, len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
@@ -55308,16 +57717,20 @@ simdutf_warn_unused result implementation::validate_utf16be_with_errors(
   if (simdutf_unlikely(len == 0)) {
     return result(error_code::SUCCESS, 0);
   }
-  result res = lasx_validate_utf16_with_errors<endianness::BIG>(buf, len);
+  const result res =
+      lasx::utf16::validate_utf16_with_errors<endianness::BIG>(buf, len);
   if (res.count != len) {
-    result scalar_res = scalar::utf16::validate_with_errors<endianness::BIG>(
-        buf + res.count, len - res.count);
+    const result scalar_res =
+        scalar::utf16::validate_with_errors<endianness::BIG>(buf + res.count,
+                                                             len - res.count);
     return result(scalar_res.error, res.count + scalar_res.count);
   } else {
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 simdutf_warn_unused bool
 implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -55331,7 +57744,9 @@ implementation::validate_utf32(const char32_t *buf, size_t len) const noexcept {
     return false;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused result implementation::validate_utf32_with_errors(
     const char32_t *buf, size_t len) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -55346,7 +57761,9 @@ simdutf_warn_unused result implementation::validate_utf32_with_errors(
     return res;
   }
 }
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
     const char *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char *, char *> ret =
@@ -55360,7 +57777,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf8(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char *, char16_t *> ret =
@@ -55388,7 +57807,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf16be(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char *, char32_t *> ret =
@@ -55401,7 +57822,9 @@ simdutf_warn_unused size_t implementation::convert_latin1_to_utf32(
   }
   return converted_chars;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf8_to_latin1(
     const char *buf, size_t len, char *latin1_output) const noexcept {
   size_t pos = 0;
@@ -55516,7 +57939,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_latin1(
       lasx::utf8_to_latin1::convert_valid(buf + pos, len - pos, latin1_output);
   return convert_result ? convert_size + convert_result : 0;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf16le(
     const char *buf, size_t len, char16_t *utf16_output) const noexcept {
   utf8_to_utf16::validating_transcoder converter;
@@ -55553,7 +57978,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf16be(
   return utf8_to_utf16::convert_valid<endianness::BIG>(input, size,
                                                        utf16_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf8_to_utf32(
     const char *buf, size_t len, char32_t *utf32_output) const noexcept {
   utf8_to_utf32::validating_transcoder converter;
@@ -55570,7 +57997,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf8_to_utf32(
     const char *input, size_t size, char32_t *utf32_output) const noexcept {
   return utf8_to_utf32::convert_valid(input, size, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf16le_to_latin1(
     const char16_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -55678,7 +58107,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16le_to_latin1(
   // optimization opportunity: implement a custom function.
   return convert_utf16le_to_latin1(buf, len, latin1_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   std::pair<const char16_t *, char *> ret =
@@ -55784,7 +58215,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf8(
     const char16_t *buf, size_t len, char *utf8_output) const noexcept {
   return convert_utf16be_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   if (simdutf_unlikely(len == 0)) {
@@ -55831,7 +58264,9 @@ simdutf_warn_unused result implementation::convert_utf32_to_utf8_with_errors(
       utf8_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf16le_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   std::pair<const char16_t *, char32_t *> ret =
@@ -55927,7 +58362,9 @@ simdutf_warn_unused result implementation::convert_utf16be_to_utf32_with_errors(
       utf32_output; // Set count to the number of 8-bit code units written
   return ret.first;
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::convert_utf32_to_latin1(
     const char32_t *buf, size_t len, char *latin1_output) const noexcept {
   std::pair<const char32_t *, char *> ret =
@@ -55988,13 +58425,17 @@ simdutf_warn_unused size_t implementation::convert_valid_utf32_to_latin1(
   }
   return saved_bytes;
 }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_valid_utf32_to_utf8(
     const char32_t *buf, size_t len, char *utf8_output) const noexcept {
   // optimization opportunity: implement a custom function.
   return convert_utf32_to_utf8(buf, len, utf8_output);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::convert_utf32_to_utf16le(
     const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept {
   std::pair<const char32_t *, char16_t *> ret =
@@ -56103,7 +58544,9 @@ simdutf_warn_unused size_t implementation::convert_valid_utf16be_to_utf32(
     const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept {
   return convert_utf16be_to_utf32(buf, len, utf32_output);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 void implementation::change_endianness_utf16(const char16_t *input,
                                              size_t length,
                                              char16_t *output) const noexcept {
@@ -56119,7 +58562,9 @@ simdutf_warn_unused size_t implementation::count_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::count_code_points<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 simdutf_warn_unused size_t
 implementation::count_utf8(const char *input, size_t length) const noexcept {
   size_t pos = 0;
@@ -56140,28 +58585,22 @@ implementation::count_utf8(const char *input, size_t length) const noexcept {
   }
   return count + scalar::utf8::count_code_points(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::latin1_length_from_utf8(
     const char *buf, size_t len) const noexcept {
   return count_utf8(buf, len);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf16(size_t length) const noexcept {
-  return length;
-}
-
-simdutf_warn_unused size_t
-implementation::latin1_length_from_utf32(size_t length) const noexcept {
-  return length;
-}
-
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
     const char *input, size_t length) const noexcept {
   const uint8_t *data = reinterpret_cast<const uint8_t *>(input);
   const uint8_t *data_end = data + length;
   uint64_t result = 0;
-  while (data + 16 < data_end) {
+  while (data_end - data > 16) {
     uint64_t two_bytes = 0;
     __m128i input_vec = __lsx_vld(data, 0);
     two_bytes =
@@ -56172,7 +58611,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_latin1(
   return result + scalar::latin1::utf8_length_from_latin1((const char *)data,
                                                           data_end - data);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf8_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::LITTLE>(input, length);
@@ -56182,17 +58623,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf8_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
-simdutf_warn_unused size_t
-implementation::utf16_length_from_latin1(size_t length) const noexcept {
-  return length;
-}
-
-simdutf_warn_unused size_t
-implementation::utf32_length_from_latin1(size_t length) const noexcept {
-  return length;
-}
-
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf16le(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::LITTLE>(input, length);
@@ -56202,12 +58635,16 @@ simdutf_warn_unused size_t implementation::utf32_length_from_utf16be(
     const char16_t *input, size_t length) const noexcept {
   return utf16::utf32_length_from_utf16<endianness::BIG>(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 simdutf_warn_unused size_t implementation::utf16_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::utf16_length_from_utf8(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   __m256i v_80 = __lasx_xvrepli_w(0x80); /*0x00000080*/
@@ -56243,7 +58680,9 @@ simdutf_warn_unused size_t implementation::utf8_length_from_utf32(
   return count +
          scalar::utf32::utf8_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
     const char32_t *input, size_t length) const noexcept {
   __m128i v_ffff = __lsx_vldi(-2304); /*0x0000ffff*/
@@ -56259,65 +58698,102 @@ simdutf_warn_unused size_t implementation::utf16_length_from_utf32(
   return count +
          scalar::utf32::utf16_length_from_utf32(input + pos, length - pos);
 }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
     const char *input, size_t length) const noexcept {
   return utf8::count_code_points(input, length);
 }
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
-}
-
+#if SIMDUTF_FEATURE_BASE64
 simdutf_warn_unused result implementation::base64_to_binary(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::maximal_binary_length_from_base64(
-    const char16_t *input, size_t length) const noexcept {
-  return scalar::base64::maximal_binary_length_from_base64(input, length);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused result implementation::base64_to_binary(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 simdutf_warn_unused full_result implementation::base64_to_binary_details(
     const char16_t *input, size_t length, char *output, base64_options options,
     last_chunk_handling_options last_chunk_options) const noexcept {
-  return (options & base64_url)
-             ? compress_decode_base64<true>(output, input, length, options,
-                                            last_chunk_options)
-             : compress_decode_base64<false>(output, input, length, options,
-                                             last_chunk_options);
-}
-
-simdutf_warn_unused size_t implementation::base64_length_from_binary(
-    size_t length, base64_options options) const noexcept {
-  return scalar::base64::base64_length_from_binary(length, options);
+  if (options & base64_url) {
+    if (options == base64_options::base64_url_accept_garbage) {
+      return compress_decode_base64<true, true>(output, input, length, options,
+                                                last_chunk_options);
+    } else {
+      return compress_decode_base64<true, false>(output, input, length, options,
+                                                 last_chunk_options);
+    }
+  } else {
+    if (options == base64_options::base64_default_accept_garbage) {
+      return compress_decode_base64<false, true>(output, input, length, options,
+                                                 last_chunk_options);
+    } else {
+      return compress_decode_base64<false, false>(output, input, length,
+                                                  options, last_chunk_options);
+    }
+  }
 }
 
 size_t implementation::binary_to_base64(const char *input, size_t length,
@@ -56329,6 +58805,7 @@ size_t implementation::binary_to_base64(const char *input, size_t length,
     return encode_base64<false>(output, input, length, options);
   }
 }
+#endif // SIMDUTF_FEATURE_BASE64
 } // namespace lasx
 } // namespace simdutf
 
diff --git a/deps/simdutf/simdutf.h b/deps/simdutf/simdutf.h
index 2d984f40..5cdb2511 100644
--- a/deps/simdutf/simdutf.h
+++ b/deps/simdutf/simdutf.h
@@ -1,4 +1,4 @@
-/* auto-generated on 2024-12-10 14:54:53 -0500. Do not edit! */
+/* auto-generated on 2025-03-04 12:05:54 -0500. Do not edit! */
 /* begin file include/simdutf.h */
 #ifndef SIMDUTF_H
 #define SIMDUTF_H
@@ -55,21 +55,38 @@
 #ifndef SIMDUTF_COMMON_DEFS_H
 #define SIMDUTF_COMMON_DEFS_H
 
-#include <cassert>
 /* begin file include/simdutf/portability.h */
 #ifndef SIMDUTF_PORTABILITY_H
 #define SIMDUTF_PORTABILITY_H
 
+
+#include <cfloat>
 #include <cstddef>
 #include <cstdint>
 #include <cstdlib>
-#include <cfloat>
-#include <cassert>
 #ifndef _WIN32
   // strcasecmp, strncasecmp
   #include <strings.h>
 #endif
 
+#if defined(__apple_build_version__)
+  #if __apple_build_version__ < 14000000
+    #define SIMDUTF_SPAN_DISABLED                                              \
+      1 // apple-clang/13 doesn't support std::convertible_to
+  #endif
+#endif
+
+#if SIMDUTF_CPLUSPLUS20
+  #include <version>
+  #if __cpp_concepts >= 201907L && __cpp_lib_span >= 202002L &&                \
+      !defined(SIMDUTF_SPAN_DISABLED)
+    #define SIMDUTF_SPAN 1
+  #endif // __cpp_concepts >= 201907L && __cpp_lib_span >= 202002L
+  #if __cpp_lib_atomic_ref >= 201806L
+    #define SIMDUTF_ATOMIC_REF 1
+  #endif // __cpp_lib_atomic_ref
+#endif
+
 /**
  * We want to check that it is actually a little endian system at
  * compile-time.
@@ -291,27 +308,6 @@
   #define simdutf_strncasecmp strncasecmp
 #endif
 
-#ifdef NDEBUG
-
-  #ifdef SIMDUTF_VISUAL_STUDIO
-    #define SIMDUTF_UNREACHABLE() __assume(0)
-    #define SIMDUTF_ASSUME(COND) __assume(COND)
-  #else
-    #define SIMDUTF_UNREACHABLE() __builtin_unreachable();
-    #define SIMDUTF_ASSUME(COND)                                               \
-      do {                                                                     \
-        if (!(COND))                                                           \
-          __builtin_unreachable();                                             \
-      } while (0)
-  #endif
-
-#else // NDEBUG
-
-  #define SIMDUTF_UNREACHABLE() assert(0);
-  #define SIMDUTF_ASSUME(COND) assert(COND)
-
-#endif
-
 #if defined(__GNUC__) && !defined(__clang__)
   #if __GNUC__ >= 11
     #define SIMDUTF_GCC11ORMORE 1
@@ -402,27 +398,6 @@
 #endif // SIMDUTF_AVX512_H_
 /* end file include/simdutf/avx512.h */
 
-#if defined(__GNUC__)
-  // Marks a block with a name so that MCA analysis can see it.
-  #define SIMDUTF_BEGIN_DEBUG_BLOCK(name)                                      \
-    __asm volatile("# LLVM-MCA-BEGIN " #name);
-  #define SIMDUTF_END_DEBUG_BLOCK(name) __asm volatile("# LLVM-MCA-END " #name);
-  #define SIMDUTF_DEBUG_BLOCK(name, block)                                     \
-    BEGIN_DEBUG_BLOCK(name);                                                   \
-    block;                                                                     \
-    END_DEBUG_BLOCK(name);
-#else
-  #define SIMDUTF_BEGIN_DEBUG_BLOCK(name)
-  #define SIMDUTF_END_DEBUG_BLOCK(name)
-  #define SIMDUTF_DEBUG_BLOCK(name, block)
-#endif
-
-// Align to N-byte boundary
-#define SIMDUTF_ROUNDUP_N(a, n) (((a) + ((n) - 1)) & ~((n) - 1))
-#define SIMDUTF_ROUNDDOWN_N(a, n) ((a) & ~((n) - 1))
-
-#define SIMDUTF_ISALIGNED_N(ptr, n) (((uintptr_t)(ptr) & ((n) - 1)) == 0)
-
 #if defined(SIMDUTF_REGULAR_VISUAL_STUDIO)
   #define SIMDUTF_DEPRECATED __declspec(deprecated)
 
@@ -536,18 +511,11 @@
   #endif
 #endif
 
-/// If EXPR is an error, returns it.
-#define SIMDUTF_TRY(EXPR)                                                      \
-  {                                                                            \
-    auto _err = (EXPR);                                                        \
-    if (_err) {                                                                \
-      return _err;                                                             \
-    }                                                                          \
-  }
-
 #endif // SIMDUTF_COMMON_DEFS_H
 /* end file include/simdutf/common_defs.h */
 /* begin file include/simdutf/encoding_types.h */
+#ifndef SIMDUTF_ENCODING_TYPES_H
+#define SIMDUTF_ENCODING_TYPES_H
 #include <string>
 
 namespace simdutf {
@@ -591,6 +559,7 @@ size_t bom_byte_size(encoding_type bom);
 
 } // namespace BOM
 } // namespace simdutf
+#endif
 /* end file include/simdutf/encoding_types.h */
 /* begin file include/simdutf/error.h */
 #ifndef SIMDUTF_ERROR_H
@@ -636,6 +605,14 @@ struct result {
 
   simdutf_really_inline result(error_code err, size_t pos)
       : error{err}, count{pos} {}
+
+  simdutf_really_inline bool is_ok() const {
+    return error == error_code::SUCCESS;
+  }
+
+  simdutf_really_inline bool is_err() const {
+    return error != error_code::SUCCESS;
+  }
 };
 
 struct full_result {
@@ -675,22 +652,22 @@ SIMDUTF_DISABLE_UNDESIRED_WARNINGS
 #define SIMDUTF_SIMDUTF_VERSION_H
 
 /** The version of simdutf being used (major.minor.revision) */
-#define SIMDUTF_VERSION "5.6.4"
+#define SIMDUTF_VERSION "6.3.0"
 
 namespace simdutf {
 enum {
   /**
    * The major version (MAJOR.minor.revision) of simdutf being used.
    */
-  SIMDUTF_VERSION_MAJOR = 5,
+  SIMDUTF_VERSION_MAJOR = 6,
   /**
    * The minor version (major.MINOR.revision) of simdutf being used.
    */
-  SIMDUTF_VERSION_MINOR = 6,
+  SIMDUTF_VERSION_MINOR = 3,
   /**
    * The revision (major.minor.REVISION) of simdutf being used.
    */
-  SIMDUTF_VERSION_REVISION = 4
+  SIMDUTF_VERSION_REVISION = 0
 };
 } // namespace simdutf
 
@@ -699,11 +676,10 @@ enum {
 /* begin file include/simdutf/implementation.h */
 #ifndef SIMDUTF_IMPLEMENTATION_H
 #define SIMDUTF_IMPLEMENTATION_H
-#include <string>
 #if !defined(SIMDUTF_NO_THREADS)
   #include <atomic>
 #endif
-#include <tuple>
+#include <string>
 #include <vector>
 /* begin file include/simdutf/internal/isadetection.h */
 /* From
@@ -777,6 +753,13 @@ struct simdutf_riscv_hwprobe {
   #define SIMDUTF_RISCV_HWPROBE_EXT_ZVBB (1 << 17)
 #endif // SIMDUTF_IS_RISCV64 && defined(__linux__)
 
+#if defined(__loongarch__) && defined(__linux__)
+  #include <sys/auxv.h>
+// bits/hwcap.h
+// #define HWCAP_LOONGARCH_LSX             (1 << 4)
+// #define HWCAP_LOONGARCH_LASX            (1 << 5)
+#endif
+
 namespace simdutf {
 namespace internal {
 
@@ -995,12 +978,6 @@ static inline uint32_t detect_supported_architectures() {
   return host_isa;
 }
 #elif defined(__loongarch__)
-  #if defined(__linux__)
-    #include <sys/auxv.h>
-  // bits/hwcap.h
-  // #define HWCAP_LOONGARCH_LSX             (1 << 4)
-  // #define HWCAP_LOONGARCH_LASX            (1 << 5)
-  #endif
 
 static inline uint32_t detect_supported_architectures() {
   uint32_t host_isa = instruction_set::DEFAULT;
@@ -1031,8 +1008,79 @@ static inline uint32_t detect_supported_architectures() {
 #endif // SIMDutf_INTERNAL_ISADETECTION_H
 /* end file include/simdutf/internal/isadetection.h */
 
+#if SIMDUTF_SPAN
+  #include <concepts>
+  #include <type_traits>
+  #include <span>
+#endif
+
+// The following defines are conditionally enabled/disabled during amalgamation.
+// By default all features are enabled, regular code shouldn't check them. Only
+// when user code really relies of a selected subset, it's good to verify these
+// flags, like:
+//
+//      #if !SIMDUTF_FEATURE_UTF16
+//      #   error("Please amalgamate simdutf with UTF-16 support")
+//      #endif
+//
+#define SIMDUTF_FEATURE_DETECT_ENCODING 1
+#define SIMDUTF_FEATURE_ASCII 1
+#define SIMDUTF_FEATURE_LATIN1 1
+#define SIMDUTF_FEATURE_UTF8 1
+#define SIMDUTF_FEATURE_UTF16 1
+#define SIMDUTF_FEATURE_UTF32 1
+#define SIMDUTF_FEATURE_BASE64 1
+
 namespace simdutf {
 
+#if SIMDUTF_SPAN
+/// helpers placed in namespace detail are not a part of the public API
+namespace detail {
+/**
+ * matches a byte, in the many ways C++ allows. note that these
+ * are all distinct types.
+ */
+template <typename T>
+concept byte_like = std::is_same_v<T, std::byte> ||   //
+                    std::is_same_v<T, char> ||        //
+                    std::is_same_v<T, signed char> || //
+                    std::is_same_v<T, unsigned char>;
+
+template <typename T>
+concept is_byte_like = byte_like<std::remove_cvref_t<T>>;
+
+template <typename T>
+concept is_pointer = std::is_pointer_v<T>;
+
+/**
+ * matches anything that behaves like std::span and points to character-like
+ * data such as: std::byte, char, unsigned char, signed char, std::int8_t,
+ * std::uint8_t
+ */
+template <typename T>
+concept input_span_of_byte_like = requires(const T &t) {
+  { t.size() } noexcept -> std::convertible_to<std::size_t>;
+  { t.data() } noexcept -> is_pointer;
+  { *t.data() } noexcept -> is_byte_like;
+};
+
+template <typename T>
+concept is_mutable = !std::is_const_v<std::remove_reference_t<T>>;
+
+/**
+ * like span_of_byte_like, but for an output span (intended to be written to)
+ */
+template <typename T>
+concept output_span_of_byte_like = requires(T &t) {
+  { t.size() } noexcept -> std::convertible_to<std::size_t>;
+  { t.data() } noexcept -> is_pointer;
+  { *t.data() } noexcept -> is_byte_like;
+  { *t.data() } noexcept -> is_mutable;
+};
+} // namespace detail
+#endif
+
+#if SIMDUTF_FEATURE_DETECT_ENCODING
 /**
  * Autodetect the encoding of the input, a single encoding is recommended.
  * E.g., the function might return simdutf::encoding_type::UTF8,
@@ -1049,6 +1097,25 @@ simdutf_really_inline simdutf_warn_unused simdutf::encoding_type
 autodetect_encoding(const uint8_t *input, size_t length) noexcept {
   return autodetect_encoding(reinterpret_cast<const char *>(input), length);
 }
+  #if SIMDUTF_SPAN
+/**
+ * Autodetect the encoding of the input, a single encoding is recommended.
+ * E.g., the function might return simdutf::encoding_type::UTF8,
+ * simdutf::encoding_type::UTF16_LE, simdutf::encoding_type::UTF16_BE, or
+ * simdutf::encoding_type::UTF32_LE.
+ *
+ * @param input the string to analyze. can be a anything span-like that has a
+ * data() and size() that points to character data: std::string,
+ * std::string_view, std::vector<char>, std::span<const std::byte> etc.
+ * @return the detected encoding type
+ */
+simdutf_really_inline simdutf_warn_unused simdutf::encoding_type
+autodetect_encoding(
+    const detail::input_span_of_byte_like auto &input) noexcept {
+  return autodetect_encoding(reinterpret_cast<const char *>(input.data()),
+                             input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Autodetect the possible encodings of the input in one pass.
@@ -1067,7 +1134,16 @@ simdutf_really_inline simdutf_warn_unused int
 detect_encodings(const uint8_t *input, size_t length) noexcept {
   return detect_encodings(reinterpret_cast<const char *>(input), length);
 }
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused int
+detect_encodings(const detail::input_span_of_byte_like auto &input) noexcept {
+  return detect_encodings(reinterpret_cast<const char *>(input.data()),
+                          input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 /**
  * Validate the UTF-8 string. This function may be best when you expect
  * the input to be almost always valid. Otherwise, consider using
@@ -1080,7 +1156,16 @@ detect_encodings(const uint8_t *input, size_t length) noexcept {
  * @return true if and only if the string is valid UTF-8.
  */
 simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_utf8(const detail::input_span_of_byte_like auto &input) noexcept {
+  return validate_utf8(reinterpret_cast<const char *>(input.data()),
+                       input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
 /**
  * Validate the UTF-8 string and stop on error.
  *
@@ -1095,7 +1180,16 @@ simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept;
  */
 simdutf_warn_unused result validate_utf8_with_errors(const char *buf,
                                                      size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result validate_utf8_with_errors(
+    const detail::input_span_of_byte_like auto &input) noexcept {
+  return validate_utf8_with_errors(reinterpret_cast<const char *>(input.data()),
+                                   input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
 /**
  * Validate the ASCII string.
  *
@@ -1106,6 +1200,13 @@ simdutf_warn_unused result validate_utf8_with_errors(const char *buf,
  * @return true if and only if the string is valid ASCII.
  */
 simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_ascii(const detail::input_span_of_byte_like auto &input) noexcept {
+  return validate_ascii(reinterpret_cast<const char *>(input.data()),
+                        input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Validate the ASCII string and stop on error. It might be faster than
@@ -1122,7 +1223,16 @@ simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept;
  */
 simdutf_warn_unused result validate_ascii_with_errors(const char *buf,
                                                       size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result validate_ascii_with_errors(
+    const detail::input_span_of_byte_like auto &input) noexcept {
+  return validate_ascii_with_errors(
+      reinterpret_cast<const char *>(input.data()), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness; Validate the UTF-16 string.
  * This function may be best when you expect the input to be almost always
@@ -1139,7 +1249,15 @@ simdutf_warn_unused result validate_ascii_with_errors(const char *buf,
  */
 simdutf_warn_unused bool validate_utf16(const char16_t *buf,
                                         size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_utf16(std::span<const char16_t> input) noexcept {
+  return validate_utf16(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 /**
  * Validate the UTF-16LE string. This function may be best when you expect
  * the input to be almost always valid. Otherwise, consider using
@@ -1156,7 +1274,15 @@ simdutf_warn_unused bool validate_utf16(const char16_t *buf,
  */
 simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
                                           size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_utf16le(std::span<const char16_t> input) noexcept {
+  return validate_utf16le(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
 /**
  * Validate the UTF-16BE string. This function may be best when you expect
  * the input to be almost always valid. Otherwise, consider using
@@ -1173,6 +1299,12 @@ simdutf_warn_unused bool validate_utf16le(const char16_t *buf,
  */
 simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
                                           size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_utf16be(std::span<const char16_t> input) noexcept {
+  return validate_utf16be(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness; Validate the UTF-16 string and stop on error.
@@ -1193,6 +1325,12 @@ simdutf_warn_unused bool validate_utf16be(const char16_t *buf,
  */
 simdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf,
                                                       size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+validate_utf16_with_errors(std::span<const char16_t> input) noexcept {
+  return validate_utf16_with_errors(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Validate the UTF-16LE string and stop on error. It might be faster than
@@ -1212,6 +1350,12 @@ simdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf,
  */
 simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf,
                                                         size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+validate_utf16le_with_errors(std::span<const char16_t> input) noexcept {
+  return validate_utf16le_with_errors(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Validate the UTF-16BE string and stop on error. It might be faster than
@@ -1231,7 +1375,15 @@ simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf,
  */
 simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf,
                                                         size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+validate_utf16be_with_errors(std::span<const char16_t> input) noexcept {
+  return validate_utf16be_with_errors(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 /**
  * Validate the UTF-32 string. This function may be best when you expect
  * the input to be almost always valid. Otherwise, consider using
@@ -1248,7 +1400,15 @@ simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf,
  */
 simdutf_warn_unused bool validate_utf32(const char32_t *buf,
                                         size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused bool
+validate_utf32(std::span<const char32_t> input) noexcept {
+  return validate_utf32(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
 /**
  * Validate the UTF-32 string and stop on error. It might be faster than
  * validate_utf32 when an error is expected to occur early.
@@ -1267,7 +1427,15 @@ simdutf_warn_unused bool validate_utf32(const char32_t *buf,
  */
 simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf,
                                                       size_t len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+validate_utf32_with_errors(std::span<const char32_t> input) noexcept {
+  return validate_utf32_with_errors(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert Latin1 string into UTF8 string.
  *
@@ -1281,6 +1449,15 @@ simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf,
 simdutf_warn_unused size_t convert_latin1_to_utf8(const char *input,
                                                   size_t length,
                                                   char *utf8_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_latin1_to_utf8(
+    const detail::input_span_of_byte_like auto &latin1_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_latin1_to_utf8(
+      reinterpret_cast<const char *>(latin1_input.data()), latin1_input.size(),
+      utf8_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert Latin1 string into UTF8 string with output limit.
@@ -1296,7 +1473,24 @@ simdutf_warn_unused size_t convert_latin1_to_utf8(const char *input,
 simdutf_warn_unused size_t
 convert_latin1_to_utf8_safe(const char *input, size_t length, char *utf8_output,
                             size_t utf8_len) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_latin1_to_utf8_safe(
+    const detail::input_span_of_byte_like auto &input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  // implementation note: outputspan is a forwarding ref to avoid copying and
+  // allow both lvalues and rvalues. std::span can be copied without problems,
+  // but std::vector should not, and this function should accept both. it will
+  // allow using an owning rvalue ref (example: passing a temporary std::string)
+  // as output, but the user will quickly find out that he has no way of getting
+  // the data out of the object in that case.
+  return convert_latin1_to_utf8_safe(
+      input.data(), input.size(), reinterpret_cast<char *>(utf8_output.data()),
+      utf8_output.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert possibly Latin1 string into UTF-16LE string.
  *
@@ -1309,6 +1503,15 @@ convert_latin1_to_utf8_safe(const char *input, size_t length, char *utf8_output,
  */
 simdutf_warn_unused size_t convert_latin1_to_utf16le(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_latin1_to_utf16le(
+    const detail::input_span_of_byte_like auto &latin1_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_latin1_to_utf16le(
+      reinterpret_cast<const char *>(latin1_input.data()), latin1_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert Latin1 string into UTF-16BE string.
@@ -1322,7 +1525,36 @@ simdutf_warn_unused size_t convert_latin1_to_utf16le(
  */
 simdutf_warn_unused size_t convert_latin1_to_utf16be(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_latin1_to_utf16be(const detail::input_span_of_byte_like auto &input,
+                          std::span<char16_t> output) noexcept {
+  return convert_latin1_to_utf16be(reinterpret_cast<const char *>(input.data()),
+                                   input.size(), output.data());
+}
+  #endif // SIMDUTF_SPAN
+/**
+ * Compute the number of bytes that this UTF-16 string would require in Latin1
+ * format.
+ *
+ * @param length        the length of the string in Latin1 code units (char)
+ * @return the length of the string in Latin1 code units (char) required to
+ * encode the UTF-16 string as Latin1
+ */
+simdutf_warn_unused size_t latin1_length_from_utf16(size_t length) noexcept;
 
+/**
+ * Compute the number of code units that this Latin1 string would require in
+ * UTF-16 format.
+ *
+ * @param length        the length of the string in Latin1 code units (char)
+ * @return the length of the string in 2-byte code units (char16_t) required to
+ * encode the Latin1 string as UTF-16
+ */
+simdutf_warn_unused size_t utf16_length_from_latin1(size_t length) noexcept;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert Latin1 string into UTF-32 string.
  *
@@ -1335,7 +1567,18 @@ simdutf_warn_unused size_t convert_latin1_to_utf16be(
  */
 simdutf_warn_unused size_t convert_latin1_to_utf32(
     const char *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_latin1_to_utf32(
+    const detail::input_span_of_byte_like auto &latin1_input,
+    std::span<char32_t> utf32_output) noexcept {
+  return convert_latin1_to_utf32(
+      reinterpret_cast<const char *>(latin1_input.data()), latin1_input.size(),
+      utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert possibly broken UTF-8 string into latin1 string.
  *
@@ -1351,7 +1594,18 @@ simdutf_warn_unused size_t convert_latin1_to_utf32(
 simdutf_warn_unused size_t convert_utf8_to_latin1(const char *input,
                                                   size_t length,
                                                   char *latin1_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf8_to_latin1(
+    const detail::input_span_of_byte_like auto &input,
+    detail::output_span_of_byte_like auto &&output) noexcept {
+  return convert_utf8_to_latin1(reinterpret_cast<const char *>(input.data()),
+                                input.size(),
+                                reinterpret_cast<char *>(output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness, convert possibly broken UTF-8 string into a UTF-16
  * string.
@@ -1367,7 +1621,17 @@ simdutf_warn_unused size_t convert_utf8_to_latin1(const char *input,
  */
 simdutf_warn_unused size_t convert_utf8_to_utf16(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf8_to_utf16(const detail::input_span_of_byte_like auto &input,
+                      std::span<char16_t> output) noexcept {
+  return convert_utf8_to_utf16(reinterpret_cast<const char *>(input.data()),
+                               input.size(), output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /**
  * Using native endianness, convert a Latin1 string into a UTF-16 string.
  *
@@ -1378,7 +1642,17 @@ simdutf_warn_unused size_t convert_utf8_to_utf16(
  */
 simdutf_warn_unused size_t convert_latin1_to_utf16(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_latin1_to_utf16(const detail::input_span_of_byte_like auto &input,
+                        std::span<char16_t> output) noexcept {
+  return convert_latin1_to_utf16(reinterpret_cast<const char *>(input.data()),
+                                 input.size(), output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Convert possibly broken UTF-8 string into UTF-16LE string.
  *
@@ -1393,6 +1667,15 @@ simdutf_warn_unused size_t convert_latin1_to_utf16(
  */
 simdutf_warn_unused size_t convert_utf8_to_utf16le(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf8_to_utf16le(const detail::input_span_of_byte_like auto &utf8_input,
+                        std::span<char16_t> utf16_output) noexcept {
+  return convert_utf8_to_utf16le(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-8 string into UTF-16BE string.
@@ -1408,7 +1691,18 @@ simdutf_warn_unused size_t convert_utf8_to_utf16le(
  */
 simdutf_warn_unused size_t convert_utf8_to_utf16be(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf8_to_utf16be(const detail::input_span_of_byte_like auto &utf8_input,
+                        std::span<char16_t> utf16_output) noexcept {
+  return convert_utf8_to_utf16be(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert possibly broken UTF-8 string into latin1 string with errors.
  * If the string cannot be represented as Latin1, an error
@@ -1427,7 +1721,19 @@ simdutf_warn_unused size_t convert_utf8_to_utf16be(
  */
 simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
     const char *input, size_t length, char *latin1_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf8_to_latin1_with_errors(
+    const detail::input_span_of_byte_like auto &utf8_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf8_to_latin1_with_errors(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness, convert possibly broken UTF-8 string into UTF-16
  * string and stop on error.
@@ -1445,6 +1751,16 @@ simdutf_warn_unused result convert_utf8_to_latin1_with_errors(
  */
 simdutf_warn_unused result convert_utf8_to_utf16_with_errors(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf8_to_utf16_with_errors(
+    const detail::input_span_of_byte_like auto &utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_utf8_to_utf16_with_errors(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.
@@ -1462,6 +1778,16 @@ simdutf_warn_unused result convert_utf8_to_utf16_with_errors(
  */
 simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf8_to_utf16le_with_errors(
+    const detail::input_span_of_byte_like auto &utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_utf8_to_utf16le_with_errors(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.
@@ -1479,7 +1805,19 @@ simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(
  */
 simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
     const char *input, size_t length, char16_t *utf16_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf8_to_utf16be_with_errors(
+    const detail::input_span_of_byte_like auto &utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_utf8_to_utf16be_with_errors(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /**
  * Convert possibly broken UTF-8 string into UTF-32 string.
  *
@@ -1494,6 +1832,15 @@ simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(
  */
 simdutf_warn_unused size_t convert_utf8_to_utf32(
     const char *input, size_t length, char32_t *utf32_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf8_to_utf32(const detail::input_span_of_byte_like auto &utf8_input,
+                      std::span<char32_t> utf32_output) noexcept {
+  return convert_utf8_to_utf32(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-8 string into UTF-32 string and stop on error.
@@ -1511,7 +1858,19 @@ simdutf_warn_unused size_t convert_utf8_to_utf32(
  */
 simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
     const char *input, size_t length, char32_t *utf32_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf8_to_utf32_with_errors(
+    const detail::input_span_of_byte_like auto &utf8_input,
+    std::span<char32_t> utf32_output) noexcept {
+  return convert_utf8_to_utf32_with_errors(
+      reinterpret_cast<const char *>(utf8_input.data()), utf8_input.size(),
+      utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert valid UTF-8 string into latin1 string.
  *
@@ -1533,7 +1892,18 @@ simdutf_warn_unused result convert_utf8_to_utf32_with_errors(
  */
 simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
     const char *input, size_t length, char *latin1_output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
+    const detail::input_span_of_byte_like auto &valid_utf8_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_valid_utf8_to_latin1(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size(), latin1_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness, convert valid UTF-8 string into a UTF-16 string.
  *
@@ -1546,6 +1916,15 @@ simdutf_warn_unused size_t convert_valid_utf8_to_latin1(
  */
 simdutf_warn_unused size_t convert_valid_utf8_to_utf16(
     const char *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf8_to_utf16(
+    const detail::input_span_of_byte_like auto &valid_utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf8_to_utf16(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-8 string into UTF-16LE string.
@@ -1559,6 +1938,15 @@ simdutf_warn_unused size_t convert_valid_utf8_to_utf16(
  */
 simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
     const char *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
+    const detail::input_span_of_byte_like auto &valid_utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf8_to_utf16le(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-8 string into UTF-16BE string.
@@ -1572,7 +1960,18 @@ simdutf_warn_unused size_t convert_valid_utf8_to_utf16le(
  */
 simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
     const char *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
+    const detail::input_span_of_byte_like auto &valid_utf8_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf8_to_utf16be(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /**
  * Convert valid UTF-8 string into UTF-32 string.
  *
@@ -1585,7 +1984,18 @@ simdutf_warn_unused size_t convert_valid_utf8_to_utf16be(
  */
 simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
     const char *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
+    const detail::input_span_of_byte_like auto &valid_utf8_input,
+    std::span<char32_t> utf32_output) noexcept {
+  return convert_valid_utf8_to_utf32(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 /**
  * Return the number of bytes that this Latin1 string would require in UTF-8
  * format.
@@ -1596,6 +2006,13 @@ simdutf_warn_unused size_t convert_valid_utf8_to_utf32(
  */
 simdutf_warn_unused size_t utf8_length_from_latin1(const char *input,
                                                    size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t utf8_length_from_latin1(
+    const detail::input_span_of_byte_like auto &latin1_input) noexcept {
+  return utf8_length_from_latin1(
+      reinterpret_cast<const char *>(latin1_input.data()), latin1_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Compute the number of bytes that this UTF-8 string would require in Latin1
@@ -1612,7 +2029,17 @@ simdutf_warn_unused size_t utf8_length_from_latin1(const char *input,
  */
 simdutf_warn_unused size_t latin1_length_from_utf8(const char *input,
                                                    size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t latin1_length_from_utf8(
+    const detail::input_span_of_byte_like auto &valid_utf8_input) noexcept {
+  return latin1_length_from_utf8(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Compute the number of 2-byte code units that this UTF-8 string would require
  * in UTF-16LE format.
@@ -1629,7 +2056,17 @@ simdutf_warn_unused size_t latin1_length_from_utf8(const char *input,
  */
 simdutf_warn_unused size_t utf16_length_from_utf8(const char *input,
                                                   size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t utf16_length_from_utf8(
+    const detail::input_span_of_byte_like auto &valid_utf8_input) noexcept {
+  return utf16_length_from_utf8(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /**
  * Compute the number of 4-byte code units that this UTF-8 string would require
  * in UTF-32 format.
@@ -1648,7 +2085,17 @@ simdutf_warn_unused size_t utf16_length_from_utf8(const char *input,
  */
 simdutf_warn_unused size_t utf32_length_from_utf8(const char *input,
                                                   size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t utf32_length_from_utf8(
+    const detail::input_span_of_byte_like auto &valid_utf8_input) noexcept {
+  return utf32_length_from_utf8(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness, convert possibly broken UTF-16 string into UTF-8
  * string.
@@ -1667,7 +2114,17 @@ simdutf_warn_unused size_t utf32_length_from_utf8(const char *input,
 simdutf_warn_unused size_t convert_utf16_to_utf8(const char16_t *input,
                                                  size_t length,
                                                  char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16_to_utf8(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16_to_utf8(utf16_input.data(), utf16_input.size(),
+                               reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /**
  * Using native endianness, convert possibly broken UTF-16 string into Latin1
  * string.
@@ -1685,6 +2142,15 @@ simdutf_warn_unused size_t convert_utf16_to_utf8(const char16_t *input,
  */
 simdutf_warn_unused size_t convert_utf16_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16_to_latin1(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16_to_latin1(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16LE string into Latin1 string.
@@ -1704,6 +2170,15 @@ simdutf_warn_unused size_t convert_utf16_to_latin1(
  */
 simdutf_warn_unused size_t convert_utf16le_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16le_to_latin1(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16le_to_latin1(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into Latin1 string.
@@ -1721,7 +2196,18 @@ simdutf_warn_unused size_t convert_utf16le_to_latin1(
  */
 simdutf_warn_unused size_t convert_utf16be_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16be_to_latin1(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16be_to_latin1(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Convert possibly broken UTF-16LE string into UTF-8 string.
  *
@@ -1739,6 +2225,14 @@ simdutf_warn_unused size_t convert_utf16be_to_latin1(
 simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t *input,
                                                    size_t length,
                                                    char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16le_to_utf8(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16le_to_utf8(utf16_input.data(), utf16_input.size(),
+                                 reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into UTF-8 string.
@@ -1757,7 +2251,17 @@ simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t *input,
 simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t *input,
                                                    size_t length,
                                                    char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf16be_to_utf8(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16be_to_utf8(utf16_input.data(), utf16_input.size(),
+                                 reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /**
  * Using native endianness, convert possibly broken UTF-16 string into Latin1
  * string.
@@ -1776,6 +2280,16 @@ simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t *input,
  */
 simdutf_warn_unused result convert_utf16_to_latin1_with_errors(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16_to_latin1_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16_to_latin1_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16LE string into Latin1 string.
@@ -1794,6 +2308,16 @@ simdutf_warn_unused result convert_utf16_to_latin1_with_errors(
  */
 simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16le_to_latin1_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16le_to_latin1_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into Latin1 string.
@@ -1814,7 +2338,19 @@ simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(
  */
 simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16be_to_latin1_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf16be_to_latin1_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Using native endianness, convert possibly broken UTF-16 string into UTF-8
  * string and stop on error.
@@ -1834,6 +2370,16 @@ simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(
  */
 simdutf_warn_unused result convert_utf16_to_utf8_with_errors(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16_to_utf8_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16_to_utf8_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.
@@ -1853,6 +2399,16 @@ simdutf_warn_unused result convert_utf16_to_utf8_with_errors(
  */
 simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16le_to_utf8_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16le_to_utf8_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.
@@ -1872,6 +2428,16 @@ simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(
  */
 simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16be_to_utf8_with_errors(
+    std::span<char16_t> utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf16be_to_utf8_with_errors(
+      utf16_input.data(), utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness, convert valid UTF-16 string into UTF-8 string.
@@ -1882,13 +2448,24 @@ simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(
  *
  * @param input         the UTF-16 string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf8_buffer   the pointer to buffer that can hold the conversion
+ * @param utf8_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16_to_utf8(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf16_to_utf8(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_valid_utf16_to_utf8(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 /**
  * Using native endianness, convert UTF-16 string into Latin1 string.
  *
@@ -1910,6 +2487,15 @@ simdutf_warn_unused size_t convert_valid_utf16_to_utf8(
  */
 simdutf_warn_unused size_t convert_valid_utf16_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf16_to_latin1(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_valid_utf16_to_latin1(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-16LE string into Latin1 string.
@@ -1932,6 +2518,16 @@ simdutf_warn_unused size_t convert_valid_utf16_to_latin1(
  */
 simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf16le_to_latin1(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_valid_utf16le_to_latin1(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-16BE string into Latin1 string.
@@ -1954,7 +2550,19 @@ simdutf_warn_unused size_t convert_valid_utf16le_to_latin1(
  */
 simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
     const char16_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf16be_to_latin1(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_valid_utf16be_to_latin1(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Convert valid UTF-16LE string into UTF-8 string.
  *
@@ -1965,12 +2573,21 @@ simdutf_warn_unused size_t convert_valid_utf16be_to_latin1(
  *
  * @param input         the UTF-16LE string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf8_buffer   the pointer to buffer that can hold the conversion
+ * @param utf8_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_valid_utf16le_to_utf8(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-16BE string into UTF-8 string.
@@ -1981,13 +2598,24 @@ simdutf_warn_unused size_t convert_valid_utf16le_to_utf8(
  *
  * @param input         the UTF-16BE string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf8_buffer   the pointer to buffer that can hold the conversion
+ * @param utf8_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
     const char16_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
+    std::span<char16_t> valid_utf16_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_valid_utf16be_to_utf8(
+      valid_utf16_input.data(), valid_utf16_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /**
  * Using native endianness, convert possibly broken UTF-16 string into UTF-32
  * string.
@@ -2005,6 +2633,14 @@ simdutf_warn_unused size_t convert_valid_utf16be_to_utf8(
  */
 simdutf_warn_unused size_t convert_utf16_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf16_to_utf32(std::span<const char16_t> utf16_input,
+                       std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16_to_utf32(utf16_input.data(), utf16_input.size(),
+                                utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16LE string into UTF-32 string.
@@ -2022,6 +2658,14 @@ simdutf_warn_unused size_t convert_utf16_to_utf32(
  */
 simdutf_warn_unused size_t convert_utf16le_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf16le_to_utf32(std::span<const char16_t> utf16_input,
+                         std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16le_to_utf32(utf16_input.data(), utf16_input.size(),
+                                  utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into UTF-32 string.
@@ -2039,6 +2683,14 @@ simdutf_warn_unused size_t convert_utf16le_to_utf32(
  */
 simdutf_warn_unused size_t convert_utf16be_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf16be_to_utf32(std::span<const char16_t> utf16_input,
+                         std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16be_to_utf32(utf16_input.data(), utf16_input.size(),
+                                  utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness, convert possibly broken UTF-16 string into
@@ -2059,6 +2711,14 @@ simdutf_warn_unused size_t convert_utf16be_to_utf32(
  */
 simdutf_warn_unused result convert_utf16_to_utf32_with_errors(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16_to_utf32_with_errors(std::span<const char16_t> utf16_input,
+                                   std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16_to_utf32_with_errors(
+      utf16_input.data(), utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.
@@ -2078,6 +2738,15 @@ simdutf_warn_unused result convert_utf16_to_utf32_with_errors(
  */
 simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16le_to_utf32_with_errors(
+    std::span<const char16_t> utf16_input,
+    std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16le_to_utf32_with_errors(
+      utf16_input.data(), utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.
@@ -2097,6 +2766,15 @@ simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(
  */
 simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf16be_to_utf32_with_errors(
+    std::span<const char16_t> utf16_input,
+    std::span<char32_t> utf32_output) noexcept {
+  return convert_utf16be_to_utf32_with_errors(
+      utf16_input.data(), utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness, convert valid UTF-16 string into UTF-32 string.
@@ -2108,12 +2786,20 @@ simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(
  *
  * @param input         the UTF-16 string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf32_buffer   the pointer to buffer that can hold the conversion
+ * @param utf32_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf16_to_utf32(std::span<const char16_t> valid_utf16_input,
+                             std::span<char32_t> utf32_output) noexcept {
+  return convert_valid_utf16_to_utf32(
+      valid_utf16_input.data(), valid_utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-16LE string into UTF-32 string.
@@ -2124,12 +2810,20 @@ simdutf_warn_unused size_t convert_valid_utf16_to_utf32(
  *
  * @param input         the UTF-16LE string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf32_buffer   the pointer to buffer that can hold the conversion
+ * @param utf32_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf16le_to_utf32(std::span<const char16_t> valid_utf16_input,
+                               std::span<char32_t> utf32_output) noexcept {
+  return convert_valid_utf16le_to_utf32(
+      valid_utf16_input.data(), valid_utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-16BE string into UTF-32 string.
@@ -2140,14 +2834,24 @@ simdutf_warn_unused size_t convert_valid_utf16le_to_utf32(
  *
  * @param input         the UTF-16BE string to convert
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param utf32_buffer   the pointer to buffer that can hold the conversion
+ * @param utf32_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf16be_to_utf32(
     const char16_t *input, size_t length, char32_t *utf32_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf16be_to_utf32(std::span<const char16_t> valid_utf16_input,
+                               std::span<char32_t> utf32_output) noexcept {
+  return convert_valid_utf16be_to_utf32(
+      valid_utf16_input.data(), valid_utf16_input.size(), utf32_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
-/*
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+/**
  * Compute the number of bytes that this UTF-16LE/BE string would require in
  * Latin1 format.
  *
@@ -2174,7 +2878,16 @@ simdutf_warn_unused size_t latin1_length_from_utf16(size_t length) noexcept;
  */
 simdutf_warn_unused size_t utf8_length_from_utf16(const char16_t *input,
                                                   size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf8_length_from_utf16(std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf8_length_from_utf16(valid_utf16_input.data(),
+                                valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 /**
  * Compute the number of bytes that this UTF-16LE string would require in UTF-8
  * format.
@@ -2188,6 +2901,13 @@ simdutf_warn_unused size_t utf8_length_from_utf16(const char16_t *input,
  */
 simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t *input,
                                                     size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf8_length_from_utf16le(std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf8_length_from_utf16le(valid_utf16_input.data(),
+                                  valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Compute the number of bytes that this UTF-16BE string would require in UTF-8
@@ -2202,7 +2922,16 @@ simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t *input,
  */
 simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t *input,
                                                     size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf8_length_from_utf16be(std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf8_length_from_utf16be(valid_utf16_input.data(),
+                                  valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /**
  * Convert possibly broken UTF-32 string into UTF-8 string.
  *
@@ -2219,6 +2948,14 @@ simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t *input,
 simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t *input,
                                                  size_t length,
                                                  char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf32_to_utf8(
+    std::span<const char32_t> utf32_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf32_to_utf8(utf32_input.data(), utf32_input.size(),
+                               reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-32 string into UTF-8 string and stop on error.
@@ -2238,6 +2975,16 @@ simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t *input,
  */
 simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
     const char32_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf32_to_utf8_with_errors(
+    std::span<const char32_t> utf32_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_utf32_to_utf8_with_errors(
+      utf32_input.data(), utf32_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-32 string into UTF-8 string.
@@ -2248,13 +2995,24 @@ simdutf_warn_unused result convert_utf32_to_utf8_with_errors(
  *
  * @param input         the UTF-32 string to convert
  * @param length        the length of the string in 4-byte code units (char32_t)
- * @param utf8_buffer   the pointer to buffer that can hold the conversion
+ * @param utf8_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
     const char32_t *input, size_t length, char *utf8_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
+    std::span<const char32_t> valid_utf32_input,
+    detail::output_span_of_byte_like auto &&utf8_output) noexcept {
+  return convert_valid_utf32_to_utf8(
+      valid_utf32_input.data(), valid_utf32_input.size(),
+      reinterpret_cast<char *>(utf8_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /**
  * Using native endianness, convert possibly broken UTF-32 string into a UTF-16
  * string.
@@ -2271,6 +3029,14 @@ simdutf_warn_unused size_t convert_valid_utf32_to_utf8(
  */
 simdutf_warn_unused size_t convert_utf32_to_utf16(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf32_to_utf16(std::span<const char32_t> utf32_input,
+                       std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16(utf32_input.data(), utf32_input.size(),
+                                utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-32 string into UTF-16LE string.
@@ -2287,7 +3053,17 @@ simdutf_warn_unused size_t convert_utf32_to_utf16(
  */
 simdutf_warn_unused size_t convert_utf32_to_utf16le(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf32_to_utf16le(std::span<const char32_t> utf32_input,
+                         std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16le(utf32_input.data(), utf32_input.size(),
+                                  utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 /**
  * Convert possibly broken UTF-32 string into Latin1 string.
  *
@@ -2304,6 +3080,15 @@ simdutf_warn_unused size_t convert_utf32_to_utf16le(
  */
 simdutf_warn_unused size_t convert_utf32_to_latin1(
     const char32_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_utf32_to_latin1(
+    std::span<char32_t> utf32_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf32_to_latin1(
+      utf32_input.data(), utf32_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-32 string into Latin1 string and stop on error.
@@ -2324,6 +3109,16 @@ simdutf_warn_unused size_t convert_utf32_to_latin1(
  */
 simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
     const char32_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf32_to_latin1_with_errors(
+    std::span<char32_t> utf32_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_utf32_to_latin1_with_errors(
+      utf32_input.data(), utf32_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-32 string into Latin1 string.
@@ -2341,13 +3136,48 @@ simdutf_warn_unused result convert_utf32_to_latin1_with_errors(
  *
  * @param input         the UTF-32 string to convert
  * @param length        the length of the string in 4-byte code units (char32_t)
- * @param latin1_buffer   the pointer to buffer that can hold the conversion
+ * @param latin1_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
     const char32_t *input, size_t length, char *latin1_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
+    std::span<char32_t> valid_utf32_input,
+    detail::output_span_of_byte_like auto &&latin1_output) noexcept {
+  return convert_valid_utf32_to_latin1(
+      valid_utf32_input.data(), valid_utf32_input.size(),
+      reinterpret_cast<char *>(latin1_output.data()));
+}
+  #endif // SIMDUTF_SPAN
+
+/**
+ * Compute the number of bytes that this UTF-32 string would require in Latin1
+ * format.
+ *
+ * This function does not validate the input. It is acceptable to pass invalid
+ * UTF-32 strings but in such cases the result is implementation defined.
+ *
+ * This function is not BOM-aware.
+ *
+ * @param length        the length of the string in 4-byte code units (char32_t)
+ * @return the number of bytes required to encode the UTF-32 string as Latin1
+ */
+simdutf_warn_unused size_t latin1_length_from_utf32(size_t length) noexcept;
 
+/**
+ * Compute the number of bytes that this Latin1 string would require in UTF-32
+ * format.
+ *
+ * @param length        the length of the string in Latin1 code units (char)
+ * @return the length of the string in 4-byte code units (char32_t) required to
+ * encode the Latin1 string as UTF-32
+ */
+simdutf_warn_unused size_t utf32_length_from_latin1(size_t length) noexcept;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
+
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /**
  * Convert possibly broken UTF-32 string into UTF-16BE string.
  *
@@ -2363,6 +3193,14 @@ simdutf_warn_unused size_t convert_valid_utf32_to_latin1(
  */
 simdutf_warn_unused size_t convert_utf32_to_utf16be(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_utf32_to_utf16be(std::span<const char32_t> utf32_input,
+                         std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16be(utf32_input.data(), utf32_input.size(),
+                                  utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness, convert possibly broken UTF-32 string into UTF-16
@@ -2383,6 +3221,14 @@ simdutf_warn_unused size_t convert_utf32_to_utf16be(
  */
 simdutf_warn_unused result convert_utf32_to_utf16_with_errors(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf32_to_utf16_with_errors(std::span<const char32_t> utf32_input,
+                                   std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16_with_errors(
+      utf32_input.data(), utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.
@@ -2402,6 +3248,15 @@ simdutf_warn_unused result convert_utf32_to_utf16_with_errors(
  */
 simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf32_to_utf16le_with_errors(
+    std::span<const char32_t> utf32_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16le_with_errors(
+      utf32_input.data(), utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.
@@ -2421,6 +3276,15 @@ simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(
  */
 simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result
+convert_utf32_to_utf16be_with_errors(
+    std::span<const char32_t> utf32_input,
+    std::span<char16_t> utf16_output) noexcept {
+  return convert_utf32_to_utf16be_with_errors(
+      utf32_input.data(), utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness, convert valid UTF-32 string into a UTF-16 string.
@@ -2431,12 +3295,20 @@ simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(
  *
  * @param input         the UTF-32 string to convert
  * @param length        the length of the string in 4-byte code units (char32_t)
- * @param utf16_buffer   the pointer to buffer that can hold the conversion
+ * @param utf16_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf32_to_utf16(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf32_to_utf16(std::span<const char32_t> valid_utf32_input,
+                             std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf32_to_utf16(
+      valid_utf32_input.data(), valid_utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-32 string into UTF-16LE string.
@@ -2447,12 +3319,20 @@ simdutf_warn_unused size_t convert_valid_utf32_to_utf16(
  *
  * @param input         the UTF-32 string to convert
  * @param length        the length of the string in 4-byte code units (char32_t)
- * @param utf16_buffer   the pointer to buffer that can hold the conversion
+ * @param utf16_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf32_to_utf16le(std::span<const char32_t> valid_utf32_input,
+                               std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf32_to_utf16le(
+      valid_utf32_input.data(), valid_utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert valid UTF-32 string into UTF-16BE string.
@@ -2463,13 +3343,23 @@ simdutf_warn_unused size_t convert_valid_utf32_to_utf16le(
  *
  * @param input         the UTF-32 string to convert
  * @param length        the length of the string in 4-byte code units (char32_t)
- * @param utf16_buffer   the pointer to buffer that can hold the conversion
+ * @param utf16_buffer   the pointer to a buffer that can hold the conversion
  * result
  * @return number of written code units; 0 if conversion is not possible
  */
 simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
     const char32_t *input, size_t length, char16_t *utf16_buffer) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+convert_valid_utf32_to_utf16be(std::span<const char32_t> valid_utf32_input,
+                               std::span<char16_t> utf16_output) noexcept {
+  return convert_valid_utf32_to_utf16be(
+      valid_utf32_input.data(), valid_utf32_input.size(), utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 /**
  * Change the endianness of the input. Can be used to go from UTF-16LE to
  * UTF-16BE or from UTF-16BE to UTF-16LE.
@@ -2480,12 +3370,22 @@ simdutf_warn_unused size_t convert_valid_utf32_to_utf16be(
  *
  * @param input         the UTF-16 string to process
  * @param length        the length of the string in 2-byte code units (char16_t)
- * @param output        the pointer to buffer that can hold the conversion
+ * @param output        the pointer to a buffer that can hold the conversion
  * result
  */
 void change_endianness_utf16(const char16_t *input, size_t length,
                              char16_t *output) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline void
+change_endianness_utf16(std::span<const char16_t> utf16_input,
+                        std::span<char16_t> utf16_output) noexcept {
+  return change_endianness_utf16(utf16_input.data(), utf16_input.size(),
+                                 utf16_output.data());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 /**
  * Compute the number of bytes that this UTF-32 string would require in UTF-8
  * format.
@@ -2499,7 +3399,16 @@ void change_endianness_utf16(const char16_t *input, size_t length,
  */
 simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t *input,
                                                   size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf8_length_from_utf32(std::span<const char32_t> valid_utf32_input) noexcept {
+  return utf8_length_from_utf32(valid_utf32_input.data(),
+                                valid_utf32_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 /**
  * Compute the number of two-byte code units that this UTF-32 string would
  * require in UTF-16 format.
@@ -2513,6 +3422,13 @@ simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t *input,
  */
 simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t *input,
                                                    size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf16_length_from_utf32(std::span<const char32_t> valid_utf32_input) noexcept {
+  return utf16_length_from_utf32(valid_utf32_input.data(),
+                                 valid_utf32_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Using native endianness; Compute the number of bytes that this UTF-16
@@ -2531,6 +3447,13 @@ simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t *input,
  */
 simdutf_warn_unused size_t utf32_length_from_utf16(const char16_t *input,
                                                    size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+utf32_length_from_utf16(std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf32_length_from_utf16(valid_utf16_input.data(),
+                                 valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Compute the number of bytes that this UTF-16LE string would require in UTF-32
@@ -2549,6 +3472,13 @@ simdutf_warn_unused size_t utf32_length_from_utf16(const char16_t *input,
  */
 simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t *input,
                                                      size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t utf32_length_from_utf16le(
+    std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf32_length_from_utf16le(valid_utf16_input.data(),
+                                   valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Compute the number of bytes that this UTF-16BE string would require in UTF-32
@@ -2567,7 +3497,16 @@ simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t *input,
  */
 simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t *input,
                                                      size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t utf32_length_from_utf16be(
+    std::span<const char16_t> valid_utf16_input) noexcept {
+  return utf32_length_from_utf16be(valid_utf16_input.data(),
+                                   valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
 /**
  * Count the number of code points (characters) in the string assuming that
  * it is valid.
@@ -2584,6 +3523,12 @@ simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t *input,
  */
 simdutf_warn_unused size_t count_utf16(const char16_t *input,
                                        size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+count_utf16(std::span<const char16_t> valid_utf16_input) noexcept {
+  return count_utf16(valid_utf16_input.data(), valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Count the number of code points (characters) in the string assuming that
@@ -2601,6 +3546,12 @@ simdutf_warn_unused size_t count_utf16(const char16_t *input,
  */
 simdutf_warn_unused size_t count_utf16le(const char16_t *input,
                                          size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+count_utf16le(std::span<const char16_t> valid_utf16_input) noexcept {
+  return count_utf16le(valid_utf16_input.data(), valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Count the number of code points (characters) in the string assuming that
@@ -2618,7 +3569,15 @@ simdutf_warn_unused size_t count_utf16le(const char16_t *input,
  */
 simdutf_warn_unused size_t count_utf16be(const char16_t *input,
                                          size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+count_utf16be(std::span<const char16_t> valid_utf16_input) noexcept {
+  return count_utf16be(valid_utf16_input.data(), valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
 /**
  * Count the number of code points (characters) in the string assuming that
  * it is valid.
@@ -2633,6 +3592,13 @@ simdutf_warn_unused size_t count_utf16be(const char16_t *input,
  */
 simdutf_warn_unused size_t count_utf8(const char *input,
                                       size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t count_utf8(
+    const detail::input_span_of_byte_like auto &valid_utf8_input) noexcept {
+  return count_utf8(reinterpret_cast<const char *>(valid_utf8_input.data()),
+                    valid_utf8_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Given a valid UTF-8 string having a possibly truncated last character,
@@ -2649,7 +3615,17 @@ simdutf_warn_unused size_t count_utf8(const char *input,
  * @return the length of the string in bytes, possibly shorter by 1 to 3 bytes
  */
 simdutf_warn_unused size_t trim_partial_utf8(const char *input, size_t length);
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t trim_partial_utf8(
+    const detail::input_span_of_byte_like auto &valid_utf8_input) noexcept {
+  return trim_partial_utf8(
+      reinterpret_cast<const char *>(valid_utf8_input.data()),
+      valid_utf8_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_UTF16
 /**
  * Given a valid UTF-16BE string having a possibly truncated last character,
  * this function checks the end of string. If the last character is truncated
@@ -2666,6 +3642,13 @@ simdutf_warn_unused size_t trim_partial_utf8(const char *input, size_t length);
  */
 simdutf_warn_unused size_t trim_partial_utf16be(const char16_t *input,
                                                 size_t length);
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+trim_partial_utf16be(std::span<const char16_t> valid_utf16_input) noexcept {
+  return trim_partial_utf16be(valid_utf16_input.data(),
+                              valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Given a valid UTF-16LE string having a possibly truncated last character,
@@ -2683,6 +3666,13 @@ simdutf_warn_unused size_t trim_partial_utf16be(const char16_t *input,
  */
 simdutf_warn_unused size_t trim_partial_utf16le(const char16_t *input,
                                                 size_t length);
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+trim_partial_utf16le(std::span<const char16_t> valid_utf16_input) noexcept {
+  return trim_partial_utf16le(valid_utf16_input.data(),
+                              valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Given a valid UTF-16 string having a possibly truncated last character,
@@ -2700,8 +3690,19 @@ simdutf_warn_unused size_t trim_partial_utf16le(const char16_t *input,
  */
 simdutf_warn_unused size_t trim_partial_utf16(const char16_t *input,
                                               size_t length);
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+trim_partial_utf16(std::span<const char16_t> valid_utf16_input) noexcept {
+  return trim_partial_utf16(valid_utf16_input.data(), valid_utf16_input.size());
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_BASE64
 // base64_options are used to specify the base64 encoding options.
+// ASCII spaces are ' ', '\t', '\n', '\r', '\f'
+// garbage characters are characters that are not part of the base64 alphabet
+// nor ASCII spaces.
 enum base64_options : uint64_t {
   base64_default = 0,         /* standard base64 format (with padding) */
   base64_url = 1,             /* base64url format (no padding) */
@@ -2711,6 +3712,10 @@ enum base64_options : uint64_t {
       base64_reverse_padding, /* standard base64 format without padding */
   base64_url_with_padding =
       base64_url | base64_reverse_padding, /* base64url with padding */
+  base64_default_accept_garbage =
+      4, /* standard base64 format accepting garbage characters */
+  base64_url_accept_garbage =
+      5, /* base64url format accepting garbage characters */
 };
 
 // last_chunk_handling_options are used to specify the handling of the last
@@ -2735,6 +3740,14 @@ enum last_chunk_handling_options : uint64_t {
  */
 simdutf_warn_unused size_t
 maximal_binary_length_from_base64(const char *input, size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+maximal_binary_length_from_base64(
+    const detail::input_span_of_byte_like auto &input) noexcept {
+  return maximal_binary_length_from_base64(
+      reinterpret_cast<const char *>(input.data()), input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Provide the maximal binary length in bytes given the base64 input.
@@ -2748,6 +3761,12 @@ maximal_binary_length_from_base64(const char *input, size_t length) noexcept;
  */
 simdutf_warn_unused size_t maximal_binary_length_from_base64(
     const char16_t *input, size_t length) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+maximal_binary_length_from_base64(std::span<const char16_t> input) noexcept {
+  return maximal_binary_length_from_base64(input.data(), input.size());
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert a base64 input to a binary output.
@@ -2790,7 +3809,7 @@ simdutf_warn_unused size_t maximal_binary_length_from_base64(
  *
  * @param input         the base64 string to process
  * @param length        the length of the string in bytes
- * @param output        the pointer to buffer that can hold the conversion
+ * @param output        the pointer to a buffer that can hold the conversion
  * result (should be at least maximal_binary_length_from_base64(input, length)
  * bytes long).
  * @param options       the base64 options to use, usually base64_default or
@@ -2807,6 +3826,18 @@ simdutf_warn_unused result base64_to_binary(
     const char *input, size_t length, char *output,
     base64_options options = base64_default,
     last_chunk_handling_options last_chunk_options = loose) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result base64_to_binary(
+    const detail::input_span_of_byte_like auto &input,
+    detail::output_span_of_byte_like auto &&binary_output,
+    base64_options options = base64_default,
+    last_chunk_handling_options last_chunk_options = loose) noexcept {
+  return base64_to_binary(reinterpret_cast<const char *>(input.data()),
+                          input.size(),
+                          reinterpret_cast<char *>(binary_output.data()),
+                          options, last_chunk_options);
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Provide the base64 length in bytes given the length of a binary input.
@@ -2831,7 +3862,7 @@ simdutf_warn_unused size_t base64_length_from_binary(
  *
  * @param input         the binary to process
  * @param length        the length of the input in bytes
- * @param output        the pointer to buffer that can hold the conversion
+ * @param output        the pointer to a buffer that can hold the conversion
  * result (should be at least base64_length_from_binary(length) bytes long)
  * @param options       the base64 options to use, can be base64_default or
  * base64_url, is base64_default by default.
@@ -2840,6 +3871,67 @@ simdutf_warn_unused size_t base64_length_from_binary(
  */
 size_t binary_to_base64(const char *input, size_t length, char *output,
                         base64_options options = base64_default) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+binary_to_base64(const detail::input_span_of_byte_like auto &input,
+                 detail::output_span_of_byte_like auto &&binary_output,
+                 base64_options options = base64_default) noexcept {
+  return binary_to_base64(
+      reinterpret_cast<const char *>(input.data()), input.size(),
+      reinterpret_cast<char *>(binary_output.data()), options);
+}
+  #endif // SIMDUTF_SPAN
+
+  #if SIMDUTF_ATOMIC_REF
+/**
+ * Convert a binary input to a base64 output, using atomic accesses.
+ * This function comes with a potentially significant performance
+ * penalty, but it may be useful in some cases where the input and
+ * output buffers are shared between threads, to avoid undefined
+ * behavior in case of data races.
+ *
+ * The function is for advanced users. Its main use case is when
+ * to silence sanitizer warnings. We have no documented use case
+ * where this function is actually necessary in terms of practical correctness.
+ *
+ * This function is only available when simdutf is compiled with
+ * C++20 support and __cpp_lib_atomic_ref >= 201806L. You may check
+ * the availability of this function by checking the macro
+ * SIMDUTF_ATOMIC_REF.
+ *
+ * The default option (simdutf::base64_default) uses the characters `+` and `/`
+ * as part of its alphabet. Further, it adds padding (`=`) at the end of the
+ * output to ensure that the output length is a multiple of four.
+ *
+ * The URL option (simdutf::base64_url) uses the characters `-` and `_` as part
+ * of its alphabet. No padding is added at the end of the output.
+ *
+ * This function always succeeds.
+ *
+ * @brief atomic_binary_to_base64
+ * @param input         the binary to process
+ * @param length        the length of the input in bytes
+ * @param output        the pointer to a buffer that can hold the conversion
+ * result (should be at least base64_length_from_binary(length) bytes long)
+ * @param options       the base64 options to use, can be base64_default or
+ * base64_url, is base64_default by default.
+ * @return number of written bytes, will be equal to
+ * base64_length_from_binary(length, options)
+ */
+size_t
+atomic_binary_to_base64(const char *input, size_t length, char *output,
+                        base64_options options = base64_default) noexcept;
+    #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused size_t
+atomic_binary_to_base64(const detail::input_span_of_byte_like auto &input,
+                        detail::output_span_of_byte_like auto &&binary_output,
+                        base64_options options = base64_default) noexcept {
+  return atomic_binary_to_base64(
+      reinterpret_cast<const char *>(input.data()), input.size(),
+      reinterpret_cast<char *>(binary_output.data()), options);
+}
+    #endif // SIMDUTF_SPAN
+  #endif   // SIMDUTF_ATOMIC_REF
 
 /**
  * Convert a base64 input to a binary output.
@@ -2883,7 +3975,7 @@ size_t binary_to_base64(const char *input, size_t length, char *output,
  * @param input         the base64 string to process, in ASCII stored as 16-bit
  * units
  * @param length        the length of the string in 16-bit units
- * @param output        the pointer to buffer that can hold the conversion
+ * @param output        the pointer to a buffer that can hold the conversion
  * result (should be at least maximal_binary_length_from_base64(input, length)
  * bytes long).
  * @param options       the base64 options to use, can be base64_default or
@@ -2902,6 +3994,17 @@ base64_to_binary(const char16_t *input, size_t length, char *output,
                  base64_options options = base64_default,
                  last_chunk_handling_options last_chunk_options =
                      last_chunk_handling_options::loose) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result base64_to_binary(
+    std::span<const char16_t> input,
+    detail::output_span_of_byte_like auto &&binary_output,
+    base64_options options = base64_default,
+    last_chunk_handling_options last_chunk_options = loose) noexcept {
+  return base64_to_binary(input.data(), input.size(),
+                          reinterpret_cast<char *>(binary_output.data()),
+                          options, last_chunk_options);
+}
+  #endif // SIMDUTF_SPAN
 
 /**
  * Convert a base64 input to a binary output.
@@ -2949,7 +4052,7 @@ base64_to_binary(const char16_t *input, size_t length, char *output,
  * @param input         the base64 string to process, in ASCII stored as 8-bit
  * or 16-bit units
  * @param length        the length of the string in 8-bit or 16-bit units.
- * @param output        the pointer to buffer that can hold the conversion
+ * @param output        the pointer to a buffer that can hold the conversion
  * result.
  * @param outlen        the number of bytes that can be written in the output
  * buffer. Upon return, it is modified to reflect how many bytes were written.
@@ -2969,11 +4072,44 @@ base64_to_binary_safe(const char *input, size_t length, char *output,
                       size_t &outlen, base64_options options = base64_default,
                       last_chunk_handling_options last_chunk_options =
                           last_chunk_handling_options::loose) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result base64_to_binary_safe(
+    const detail::input_span_of_byte_like auto &input,
+    detail::output_span_of_byte_like auto &&binary_output,
+    base64_options options = base64_default,
+    last_chunk_handling_options last_chunk_options = loose) noexcept {
+  // we can't write the outlen to the provided output span, the user will have
+  // to pick it up from the returned value instead (assuming success). we still
+  // get the benefit of providing info of how long the output buffer is.
+  size_t outlen = binary_output.size();
+  return base64_to_binary_safe(reinterpret_cast<const char *>(input.data()),
+                               input.size(),
+                               reinterpret_cast<char *>(binary_output.data()),
+                               outlen, options, last_chunk_options);
+}
+  #endif // SIMDUTF_SPAN
+
 simdutf_warn_unused result
 base64_to_binary_safe(const char16_t *input, size_t length, char *output,
                       size_t &outlen, base64_options options = base64_default,
                       last_chunk_handling_options last_chunk_options =
                           last_chunk_handling_options::loose) noexcept;
+  #if SIMDUTF_SPAN
+simdutf_really_inline simdutf_warn_unused result base64_to_binary_safe(
+    std::span<const char16_t> input,
+    detail::output_span_of_byte_like auto &&binary_output,
+    base64_options options = base64_default,
+    last_chunk_handling_options last_chunk_options = loose) noexcept {
+  // we can't write the outlen to the provided output span, the user will have
+  // to pick it up from the returned value instead (assuming success). we still
+  // get the benefit of providing info of how long the output buffer is.
+  size_t outlen = binary_output.size();
+  return base64_to_binary_safe(input.data(), input.size(),
+                               reinterpret_cast<char *>(binary_output.data()),
+                               outlen, options, last_chunk_options);
+}
+  #endif // SIMDUTF_SPAN
+#endif   // SIMDUTF_FEATURE_BASE64
 
 /**
  * An implementation of simdutf for a particular CPU architecture.
@@ -3017,6 +4153,7 @@ public:
    */
   bool supported_by_runtime_system() const;
 
+#if SIMDUTF_FEATURE_DETECT_ENCODING
   /**
    * This function will try to detect the encoding
    * @param input the string to identify
@@ -3034,6 +4171,7 @@ public:
    */
   virtual int detect_encodings(const char *input,
                                size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_DETECT_ENCODING
 
   /**
    * @private For internal implementation use
@@ -3046,6 +4184,7 @@ public:
     return _required_instruction_sets;
   }
 
+#if SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
   /**
    * Validate the UTF-8 string.
    *
@@ -3057,7 +4196,9 @@ public:
    */
   simdutf_warn_unused virtual bool validate_utf8(const char *buf,
                                                  size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF8
   /**
    * Validate the UTF-8 string and stop on errors.
    *
@@ -3072,7 +4213,9 @@ public:
    */
   simdutf_warn_unused virtual result
   validate_utf8_with_errors(const char *buf, size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_ASCII
   /**
    * Validate the ASCII string.
    *
@@ -3099,7 +4242,9 @@ public:
    */
   simdutf_warn_unused virtual result
   validate_ascii_with_errors(const char *buf, size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_ASCII
 
+#if SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
   /**
    * Validate the UTF-16LE string.This function may be best when you expect
    * the input to be almost always valid. Otherwise, consider using
@@ -3116,7 +4261,9 @@ public:
    */
   simdutf_warn_unused virtual bool
   validate_utf16le(const char16_t *buf, size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF16
   /**
    * Validate the UTF-16BE string. This function may be best when you expect
    * the input to be almost always valid. Otherwise, consider using
@@ -3173,7 +4320,9 @@ public:
   simdutf_warn_unused virtual result
   validate_utf16be_with_errors(const char16_t *buf,
                                size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
   /**
    * Validate the UTF-32 string.
    *
@@ -3188,7 +4337,9 @@ public:
    */
   simdutf_warn_unused virtual bool
   validate_utf32(const char32_t *buf, size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF32 || SIMDUTF_FEATURE_DETECT_ENCODING
 
+#if SIMDUTF_FEATURE_UTF32
   /**
    * Validate the UTF-32 string and stop on error.
    *
@@ -3207,7 +4358,9 @@ public:
   simdutf_warn_unused virtual result
   validate_utf32_with_errors(const char32_t *buf,
                              size_t len) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert Latin1 string into UTF8 string.
    *
@@ -3221,7 +4374,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_latin1_to_utf8(const char *input, size_t length,
                          char *utf8_output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert possibly Latin1 string into UTF-16LE string.
    *
@@ -3249,7 +4404,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_latin1_to_utf16be(const char *input, size_t length,
                             char16_t *utf16_output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert Latin1 string into UTF-32 string.
    *
@@ -3263,7 +4420,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_latin1_to_utf32(const char *input, size_t length,
                           char32_t *utf32_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert possibly broken UTF-8 string into latin1 string.
    *
@@ -3322,7 +4481,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_valid_utf8_to_latin1(const char *input, size_t length,
                                char *latin1_output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
   /**
    * Convert possibly broken UTF-8 string into UTF-16LE string.
    *
@@ -3392,7 +4553,9 @@ public:
   simdutf_warn_unused virtual result convert_utf8_to_utf16be_with_errors(
       const char *input, size_t length,
       char16_t *utf16_output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
   /**
    * Convert possibly broken UTF-8 string into UTF-32 string.
    *
@@ -3426,7 +4589,9 @@ public:
   simdutf_warn_unused virtual result
   convert_utf8_to_utf32_with_errors(const char *input, size_t length,
                                     char32_t *utf32_output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
   /**
    * Convert valid UTF-8 string into UTF-16LE string.
    *
@@ -3454,7 +4619,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_valid_utf8_to_utf16be(const char *input, size_t length,
                                 char16_t *utf16_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
   /**
    * Convert valid UTF-8 string into UTF-32 string.
    *
@@ -3468,7 +4635,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_valid_utf8_to_utf32(const char *input, size_t length,
                               char32_t *utf32_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
   /**
    * Compute the number of 2-byte code units that this UTF-8 string would
    * require in UTF-16LE format.
@@ -3483,7 +4652,9 @@ public:
    */
   simdutf_warn_unused virtual size_t
   utf16_length_from_utf8(const char *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
   /**
    * Compute the number of 4-byte code units that this UTF-8 string would
    * require in UTF-32 format.
@@ -3500,7 +4671,9 @@ public:
    */
   simdutf_warn_unused virtual size_t
   utf32_length_from_utf8(const char *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert possibly broken UTF-16LE string into Latin1 string.
    *
@@ -3634,7 +4807,9 @@ public:
   simdutf_warn_unused virtual size_t
   convert_valid_utf16be_to_latin1(const char16_t *input, size_t length,
                                   char *latin1_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
   /**
    * Convert possibly broken UTF-16LE string into UTF-8 string.
    *
@@ -3727,7 +4902,7 @@ public:
    * @param input         the UTF-16LE string to convert
    * @param length        the length of the string in 2-byte code units
    * (char16_t)
-   * @param utf8_buffer   the pointer to buffer that can hold the conversion
+   * @param utf8_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
@@ -3745,14 +4920,16 @@ public:
    * @param input         the UTF-16BE string to convert
    * @param length        the length of the string in 2-byte code units
    * (char16_t)
-   * @param utf8_buffer   the pointer to buffer that can hold the conversion
+   * @param utf8_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
   simdutf_warn_unused virtual size_t
   convert_valid_utf16be_to_utf8(const char16_t *input, size_t length,
                                 char *utf8_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
   /**
    * Convert possibly broken UTF-16LE string into UTF-32 string.
    *
@@ -3845,7 +5022,7 @@ public:
    * @param input         the UTF-16LE string to convert
    * @param length        the length of the string in 2-byte code units
    * (char16_t)
-   * @param utf32_buffer   the pointer to buffer that can hold the conversion
+   * @param utf32_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
@@ -3863,14 +5040,16 @@ public:
    * @param input         the UTF-16BE string to convert
    * @param length        the length of the string in 2-byte code units
    * (char16_t)
-   * @param utf32_buffer   the pointer to buffer that can hold the conversion
+   * @param utf32_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
   simdutf_warn_unused virtual size_t
   convert_valid_utf16be_to_utf32(const char16_t *input, size_t length,
                                  char32_t *utf32_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
   /**
    * Compute the number of bytes that this UTF-16LE string would require in
    * UTF-8 format.
@@ -3906,7 +5085,9 @@ public:
   simdutf_warn_unused virtual size_t
   utf8_length_from_utf16be(const char16_t *input,
                            size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert possibly broken UTF-32 string into Latin1 string.
    *
@@ -3923,11 +5104,12 @@ public:
    * @return number of written code units; 0 if input is not a valid UTF-32
    * string
    */
-
   simdutf_warn_unused virtual size_t
   convert_utf32_to_latin1(const char32_t *input, size_t length,
                           char *latin1_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
   /**
    * Convert possibly broken UTF-32 string into Latin1 string and stop on error.
    * If the string cannot be represented as Latin1, an error is returned.
@@ -3967,14 +5149,16 @@ public:
    * @param input         the UTF-32 string to convert
    * @param length        the length of the string in 4-byte code units
    * (char32_t)
-   * @param latin1_buffer   the pointer to buffer that can hold the conversion
+   * @param latin1_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
   simdutf_warn_unused virtual size_t
   convert_valid_utf32_to_latin1(const char32_t *input, size_t length,
                                 char *latin1_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
   /**
    * Convert possibly broken UTF-32 string into UTF-8 string.
    *
@@ -4025,14 +5209,16 @@ public:
    * @param input         the UTF-32 string to convert
    * @param length        the length of the string in 4-byte code units
    * (char32_t)
-   * @param utf8_buffer   the pointer to buffer that can hold the conversion
+   * @param utf8_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
   simdutf_warn_unused virtual size_t
   convert_valid_utf32_to_utf8(const char32_t *input, size_t length,
                               char *utf8_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
   /**
    * Return the number of bytes that this UTF-16 string would require in Latin1
    * format.
@@ -4044,8 +5230,12 @@ public:
    * @return the number of bytes required to encode the UTF-16 string as Latin1
    */
   simdutf_warn_unused virtual size_t
-  utf16_length_from_latin1(size_t length) const noexcept = 0;
+  utf16_length_from_latin1(size_t length) const noexcept {
+    return length;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
   /**
    * Convert possibly broken UTF-32 string into UTF-16LE string.
    *
@@ -4138,7 +5328,7 @@ public:
    * @param input         the UTF-32 string to convert
    * @param length        the length of the string in 4-byte code units
    * (char32_t)
-   * @param utf16_buffer   the pointer to buffer that can hold the conversion
+   * @param utf16_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
@@ -4156,14 +5346,16 @@ public:
    * @param input         the UTF-32 string to convert
    * @param length        the length of the string in 4-byte code units
    * (char32_t)
-   * @param utf16_buffer   the pointer to buffer that can hold the conversion
+   * @param utf16_buffer   the pointer to a buffer that can hold the conversion
    * result
    * @return number of written code units; 0 if conversion is not possible
    */
   simdutf_warn_unused virtual size_t
   convert_valid_utf32_to_utf16be(const char32_t *input, size_t length,
                                  char16_t *utf16_buffer) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
   /**
    * Change the endianness of the input. Can be used to go from UTF-16LE to
    * UTF-16BE or from UTF-16BE to UTF-16LE.
@@ -4175,12 +5367,14 @@ public:
    * @param input         the UTF-16 string to process
    * @param length        the length of the string in 2-byte code units
    * (char16_t)
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result
    */
   virtual void change_endianness_utf16(const char16_t *input, size_t length,
                                        char16_t *output) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
   /**
    * Return the number of bytes that this Latin1 string would require in UTF-8
    * format.
@@ -4191,7 +5385,9 @@ public:
    */
   simdutf_warn_unused virtual size_t
   utf8_length_from_latin1(const char *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
   /**
    * Compute the number of bytes that this UTF-32 string would require in UTF-8
    * format.
@@ -4207,7 +5403,9 @@ public:
   simdutf_warn_unused virtual size_t
   utf8_length_from_utf32(const char32_t *input,
                          size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
   /**
    * Compute the number of bytes that this UTF-32 string would require in Latin1
    * format.
@@ -4220,8 +5418,12 @@ public:
    * @return the number of bytes required to encode the UTF-32 string as Latin1
    */
   simdutf_warn_unused virtual size_t
-  latin1_length_from_utf32(size_t length) const noexcept = 0;
+  latin1_length_from_utf32(size_t length) const noexcept {
+    return length;
+  }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
   /**
    * Compute the number of bytes that this UTF-8 string would require in Latin1
    * format.
@@ -4235,8 +5437,10 @@ public:
    */
   simdutf_warn_unused virtual size_t
   latin1_length_from_utf8(const char *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8 && SIMDUTF_FEATURE_LATIN1
 
-  /*
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
+  /**
    * Compute the number of bytes that this UTF-16LE/BE string would require in
    * Latin1 format.
    *
@@ -4252,8 +5456,12 @@ public:
    * Latin1
    */
   simdutf_warn_unused virtual size_t
-  latin1_length_from_utf16(size_t length) const noexcept = 0;
+  latin1_length_from_utf16(size_t length) const noexcept {
+    return length;
+  }
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_LATIN1
 
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
   /**
    * Compute the number of two-byte code units that this UTF-32 string would
    * require in UTF-16 format.
@@ -4269,20 +5477,25 @@ public:
   simdutf_warn_unused virtual size_t
   utf16_length_from_utf32(const char32_t *input,
                           size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
   /**
    * Return the number of bytes that this UTF-32 string would require in Latin1
    * format.
    *
-   * @param input         the UTF-32 string to convert
    * @param length        the length of the string in 4-byte code units
    * (char32_t)
    * @return the number of bytes required to encode the UTF-32 string as Latin1
    */
   simdutf_warn_unused virtual size_t
-  utf32_length_from_latin1(size_t length) const noexcept = 0;
+  utf32_length_from_latin1(size_t length) const noexcept {
+    return length;
+  }
+#endif // SIMDUTF_FEATURE_UTF32 && SIMDUTF_FEATURE_LATIN1
 
-  /*
+#if SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
+  /**
    * Compute the number of bytes that this UTF-16LE string would require in
    * UTF-32 format.
    *
@@ -4303,7 +5516,7 @@ public:
   utf32_length_from_utf16le(const char16_t *input,
                             size_t length) const noexcept = 0;
 
-  /*
+  /**
    * Compute the number of bytes that this UTF-16BE string would require in
    * UTF-32 format.
    *
@@ -4323,7 +5536,9 @@ public:
   simdutf_warn_unused virtual size_t
   utf32_length_from_utf16be(const char16_t *input,
                             size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16 && SIMDUTF_FEATURE_UTF32
 
+#if SIMDUTF_FEATURE_UTF16
   /**
    * Count the number of code points (characters) in the string assuming that
    * it is valid.
@@ -4359,7 +5574,9 @@ public:
    */
   simdutf_warn_unused virtual size_t
   count_utf16be(const char16_t *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF16
 
+#if SIMDUTF_FEATURE_UTF8
   /**
    * Count the number of code points (characters) in the string assuming that
    * it is valid.
@@ -4374,7 +5591,9 @@ public:
    */
   simdutf_warn_unused virtual size_t
   count_utf8(const char *input, size_t length) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_UTF8
 
+#if SIMDUTF_FEATURE_BASE64
   /**
    * Provide the maximal binary length in bytes given the base64 input.
    * In general, if the input contains ASCII spaces, the result will be less
@@ -4385,9 +5604,8 @@ public:
    * @param length        the length of the base64 input in bytes
    * @return maximal number of binary bytes
    */
-  simdutf_warn_unused virtual size_t
-  maximal_binary_length_from_base64(const char *input,
-                                    size_t length) const noexcept = 0;
+  simdutf_warn_unused size_t maximal_binary_length_from_base64(
+      const char *input, size_t length) const noexcept;
 
   /**
    * Provide the maximal binary length in bytes given the base64 input.
@@ -4400,9 +5618,8 @@ public:
    * @param length        the length of the base64 input in 16-bit units
    * @return maximal number of binary bytes
    */
-  simdutf_warn_unused virtual size_t
-  maximal_binary_length_from_base64(const char16_t *input,
-                                    size_t length) const noexcept = 0;
+  simdutf_warn_unused size_t maximal_binary_length_from_base64(
+      const char16_t *input, size_t length) const noexcept;
 
   /**
    * Convert a base64 input to a binary output.
@@ -4426,7 +5643,7 @@ public:
    *
    * @param input         the base64 string to process
    * @param length        the length of the string in bytes
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result (should be at least maximal_binary_length_from_base64(input, length)
    * bytes long).
    * @param options       the base64 options to use, can be base64_default or
@@ -4465,7 +5682,7 @@ public:
    *
    * @param input         the base64 string to process
    * @param length        the length of the string in bytes
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result (should be at least maximal_binary_length_from_base64(input, length)
    * bytes long).
    * @param options       the base64 options to use, can be base64_default or
@@ -4501,7 +5718,7 @@ public:
    * @param input         the base64 string to process, in ASCII stored as
    * 16-bit units
    * @param length        the length of the string in 16-bit units
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result (should be at least maximal_binary_length_from_base64(input, length)
    * bytes long).
    * @param options       the base64 options to use, can be base64_default or
@@ -4540,7 +5757,7 @@ public:
    *
    * @param input         the base64 string to process
    * @param length        the length of the string in bytes
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result (should be at least maximal_binary_length_from_base64(input, length)
    * bytes long).
    * @param options       the base64 options to use, can be base64_default or
@@ -4561,9 +5778,8 @@ public:
    * base64_url, is base64_default by default.
    * @return number of base64 bytes
    */
-  simdutf_warn_unused virtual size_t base64_length_from_binary(
-      size_t length,
-      base64_options options = base64_default) const noexcept = 0;
+  simdutf_warn_unused size_t base64_length_from_binary(
+      size_t length, base64_options options = base64_default) const noexcept;
 
   /**
    * Convert a binary input to a base64 output.
@@ -4579,7 +5795,7 @@ public:
    *
    * @param input         the binary to process
    * @param length        the length of the input in bytes
-   * @param output        the pointer to buffer that can hold the conversion
+   * @param output        the pointer to a buffer that can hold the conversion
    * result (should be at least base64_length_from_binary(length) bytes long)
    * @param options       the base64 options to use, can be base64_default or
    * base64_url, is base64_default by default.
@@ -4589,6 +5805,7 @@ public:
   virtual size_t
   binary_to_base64(const char *input, size_t length, char *output,
                    base64_options options = base64_default) const noexcept = 0;
+#endif // SIMDUTF_FEATURE_BASE64
 
 protected:
   /** @private Construct an implementation with the given name and description.
